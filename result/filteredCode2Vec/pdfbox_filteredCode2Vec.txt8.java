public void pdfbox_f8096_0() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3964-c687766d68ac766be3f02aaec5e0d713_2.pdf"))) {        assertEquals(10, doc.getNumberOfPages());    }}
public void pdfbox_f8097_0() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3977-63NGFQRI44HQNPIPEJH5W2TBM6DJZWMI.pdf"))) {        PDDocumentInformation di = doc.getDocumentInformation();        assertEquals("QuarkXPress(tm) 6.52", di.getCreator());        assertEquals("Acrobat Distiller 7.0 pour Macintosh", di.getProducer());        assertEquals("Fich sal Fabr corr1 (Page 6)", di.getTitle());        assertEquals(DateConverter.toCalendar("D:20070608151915+02'00'"), di.getCreationDate());        assertEquals(DateConverter.toCalendar("D:20080604152122+02'00'"), di.getModificationDate());    }}
public void pdfbox_f8098_0() throws IOException
{    PDDocument.load(new File(TARGETPDFDIR, "genko_oc_shiryo1.pdf")).close();}
public void pdfbox_f8099_0() throws IOException
{    PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4338.pdf")).close();}
public void pdfbox_f8100_0() throws IOException
{    PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4339.pdf")).close();}
private void pdfbox_f8101_0(RandomAccessRead source, MemoryUsageSetting memUsageSetting) throws IOException
{    ScratchFile scratchFile = new ScratchFile(memUsageSetting);    PDFParser pdfParser = new PDFParser(source, scratchFile);    pdfParser.parse();    try (COSDocument doc = pdfParser.getDocument()) {        assertNotNull(doc);    }    source.close();        assertEquals(numberOfTmpFiles, getNumberOfTempFile());}
public void pdfbox_f8102_0() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        doc.save(new BufferedOutputStream(new ByteArrayOutputStream(1024) {            private boolean open = true;            @Override            public void close() throws IOException {                                open = false;                super.close();            }            @Override            public void flush() throws IOException {                if (!open) {                    throw new IOException("Stream already closed");                }                        }        }));    }}
public void pdfbox_f8103_0() throws IOException
{        open = false;    super.close();}
public void pdfbox_f8104_0() throws IOException
{    if (!open) {        throw new IOException("Stream already closed");    }}
public void pdfbox_f8105_0()
{        final COSWriterXRefEntry objectUnderTest = new COSWriterXRefEntry(0L, null, null);    final COSWriterXRefEntry obj = null;        final int retval = objectUnderTest.compareTo(obj);        Assert.assertEquals(-1, retval);}
public static void pdfbox_f8106_0(String[] args)
{    String[] arg = { TestFunctions.class.getName() };    junit.textui.TestRunner.main(arg);}
public static Test pdfbox_f8107_0()
{    TestSuite suite = new TestSuite(TestFunctions.class.getName());    suite.addTestSuite(TestOperators.class);    suite.addTestSuite(TestParser.class);    suite.addTestSuite(TestPDFunctionType4.class);    return suite;}
private PDFunctionType4 pdfbox_f8108_0(String function, float[] domain, float[] range) throws IOException
{    COSStream stream = new COSStream();    stream.setInt("FunctionType", 4);    COSArray domainArray = new COSArray();    domainArray.setFloatArray(domain);    stream.setItem("Domain", domainArray);    COSArray rangeArray = new COSArray();    rangeArray.setFloatArray(range);    stream.setItem("Range", rangeArray);    try (OutputStream out = stream.createOutputStream()) {        byte[] data = function.getBytes("US-ASCII");        out.write(data, 0, data.length);    }    return new PDFunctionType4(stream);}
public void pdfbox_f8109_0() throws Exception
{    String functionText = "{ add }";        PDFunctionType4 function = createFunction(functionText, new float[] { -1.0f, 1.0f, -1.0f, 1.0f }, new float[] { -1.0f, 1.0f });    float[] input = new float[] { 0.8f, 0.1f };    float[] output = function.eval(input);    assertEquals(1, output.length);    assertEquals(0.9f, output[0], 0.0001f);        input = new float[] { 0.8f, 0.3f };    output = function.eval(input);    assertEquals(1, output.length);    assertEquals(1f, output[0]);        input = new float[] { 0.8f, 1.2f };    output = function.eval(input);    assertEquals(1, output.length);    assertEquals(1f, output[0]);}
public void pdfbox_f8110_0() throws Exception
{    String functionText = "{ pop }";        PDFunctionType4 function = createFunction(functionText, new float[] { -1.0f, 1.0f, -1.0f, 1.0f }, new float[] { -1.0f, 1.0f });    float[] input = new float[] { -0.7f, 0.0f };    float[] output = function.eval(input);    assertEquals(1, output.length);    assertEquals(-0.7f, output[0], 0.0001f);}
public void pdfbox_f8111_0() throws Exception
{    Type4Tester.create("5 6 add").pop(11).isEmpty();    Type4Tester.create("5 0.23 add").pop(5.23f).isEmpty();    int bigValue = Integer.MAX_VALUE - 2;    ExecutionContext context = Type4Tester.create(bigValue + " " + bigValue + " add").toExecutionContext();    float floatResult = (Float) context.getStack().pop();    assertEquals(2 * (long) Integer.MAX_VALUE - 4, floatResult, 1);    assertTrue(context.getStack().isEmpty());}
public void pdfbox_f8112_0() throws Exception
{    Type4Tester.create("-3 abs 2.1 abs -2.1 abs -7.5 abs").pop(7.5f).pop(2.1f).pop(2.1f).pop(3).isEmpty();}
public void pdfbox_f8113_0() throws Exception
{    Type4Tester.create("true true and true false and").pop(false).pop(true).isEmpty();    Type4Tester.create("99 1 and 52 7 and").pop(4).pop(1).isEmpty();}
public void pdfbox_f8114_0() throws Exception
{    Type4Tester.create("0 1 atan").pop(0f).isEmpty();    Type4Tester.create("1 0 atan").pop(90f).isEmpty();    Type4Tester.create("-100 0 atan").pop(270f).isEmpty();    Type4Tester.create("4 4 atan").pop(45f).isEmpty();}
public void pdfbox_f8115_0() throws Exception
{    Type4Tester.create("3.2 ceiling -4.8 ceiling 99 ceiling").pop(99).pop(-4f).pop(4f).isEmpty();}
public void pdfbox_f8116_0() throws Exception
{    Type4Tester.create("0 cos").popReal(1f).isEmpty();    Type4Tester.create("90 cos").popReal(0f).isEmpty();}
public void pdfbox_f8117_0() throws Exception
{    Type4Tester.create("-47.8 cvi").pop(-47).isEmpty();    Type4Tester.create("520.9 cvi").pop(520).isEmpty();}
public void pdfbox_f8118_0() throws Exception
{    Type4Tester.create("-47.8 cvr").popReal(-47.8f).isEmpty();    Type4Tester.create("520.9 cvr").popReal(520.9f).isEmpty();    Type4Tester.create("77 cvr").popReal(77f).isEmpty();        ExecutionContext context = Type4Tester.create("77 77 cvr").toExecutionContext();    Assert.assertTrue("Expected a real as the result of 'cvr'", context.getStack().pop() instanceof Float);    Assert.assertTrue("Expected an int from an integer literal", context.getStack().pop() instanceof Integer);}
public void pdfbox_f8119_0() throws Exception
{    Type4Tester.create("3 2 div").popReal(1.5f).isEmpty();    Type4Tester.create("4 2 div").popReal(2.0f).isEmpty();}
public void pdfbox_f8120_0() throws Exception
{    Type4Tester.create("9 0.5 exp").popReal(3.0f).isEmpty();    Type4Tester.create("-9 -1 exp").popReal(-0.111111f, 0.000001).isEmpty();}
public void pdfbox_f8121_0() throws Exception
{    Type4Tester.create("3.2 floor -4.8 floor 99 floor").pop(99).pop(-5f).pop(3f).isEmpty();}
public void pdfbox_f8122_0() throws Exception
{    Type4Tester.create("3 2 idiv").pop(1).isEmpty();    Type4Tester.create("4 2 idiv").pop(2).isEmpty();    Type4Tester.create("-5 2 idiv").pop(-2).isEmpty();    try {        Type4Tester.create("4.4 2 idiv");        Assert.fail("Expected typecheck");    } catch (ClassCastException cce) {        }}
public void pdfbox_f8123_0() throws Exception
{    Type4Tester.create("10 ln").popReal(2.30259f, 0.00001f).isEmpty();    Type4Tester.create("100 ln").popReal(4.60517f, 0.00001f).isEmpty();}
public void pdfbox_f8124_0() throws Exception
{    Type4Tester.create("10 log").popReal(1.0f).isEmpty();    Type4Tester.create("100 log").popReal(2.0f).isEmpty();}
public void pdfbox_f8125_0() throws Exception
{    Type4Tester.create("5 3 mod").pop(2).isEmpty();    Type4Tester.create("5 2 mod").pop(1).isEmpty();    Type4Tester.create("-5 3 mod").pop(-2).isEmpty();    try {        Type4Tester.create("4.4 2 mod");        Assert.fail("Expected typecheck");    } catch (ClassCastException cce) {        }}
public void pdfbox_f8126_0() throws Exception
{    Type4Tester.create("1 2 mul").pop(2).isEmpty();    Type4Tester.create("1.5 2 mul").popReal(3.0f).isEmpty();    Type4Tester.create("1.5 2.1 mul").popReal(3.15f, 0.001).isEmpty();        Type4Tester.create((Integer.MAX_VALUE - 3) + " 2 mul").popReal(2L * (Integer.MAX_VALUE - 3), 0.001).isEmpty();}
public void pdfbox_f8127_0() throws Exception
{    Type4Tester.create("4.5 neg").popReal(-4.5f).isEmpty();    Type4Tester.create("-3 neg").pop(3).isEmpty();        Type4Tester.create((Integer.MIN_VALUE + 1) + " neg").pop(Integer.MAX_VALUE).isEmpty();    Type4Tester.create(Integer.MIN_VALUE + " neg").popReal(-(float) Integer.MIN_VALUE).isEmpty();}
public void pdfbox_f8128_0() throws Exception
{    Type4Tester.create("3.2 round").popReal(3.0f).isEmpty();    Type4Tester.create("6.5 round").popReal(7.0f).isEmpty();    Type4Tester.create("-4.8 round").popReal(-5.0f).isEmpty();    Type4Tester.create("-6.5 round").popReal(-6.0f).isEmpty();    Type4Tester.create("99 round").pop(99).isEmpty();}
public void pdfbox_f8129_0() throws Exception
{    Type4Tester.create("0 sin").popReal(0f).isEmpty();    Type4Tester.create("90 sin").popReal(1f).isEmpty();    Type4Tester.create("-90.0 sin").popReal(-1f).isEmpty();}
public void pdfbox_f8130_0() throws Exception
{    Type4Tester.create("0 sqrt").popReal(0f).isEmpty();    Type4Tester.create("1 sqrt").popReal(1f).isEmpty();    Type4Tester.create("4 sqrt").popReal(2f).isEmpty();    Type4Tester.create("4.4 sqrt").popReal(2.097617f, 0.000001).isEmpty();    try {        Type4Tester.create("-4.1 sqrt");        Assert.fail("Expected rangecheck");    } catch (IllegalArgumentException iae) {        }}
public void pdfbox_f8131_0() throws Exception
{    Type4Tester.create("5 2 sub -7.5 1 sub").pop(-8.5f).pop(3).isEmpty();}
public void pdfbox_f8132_0() throws Exception
{    Type4Tester.create("3.2 truncate").popReal(3.0f).isEmpty();    Type4Tester.create("-4.8 truncate").popReal(-4.0f).isEmpty();    Type4Tester.create("99 truncate").pop(99).isEmpty();}
public void pdfbox_f8133_0() throws Exception
{    Type4Tester.create("7 3 bitshift 142 -3 bitshift").pop(17).pop(56).isEmpty();}
public void pdfbox_f8134_0() throws Exception
{    Type4Tester.create("7 7 eq 7 6 eq 7 -7 eq true true eq false true eq 7.7 7.7 eq").pop(true).pop(false).pop(true).pop(false).pop(false).pop(true).isEmpty();}
public void pdfbox_f8135_0() throws Exception
{    Type4Tester.create("5 7 ge 7 5 ge 7 7 ge -1 2 ge").pop(false).pop(true).pop(true).pop(false).isEmpty();}
public void pdfbox_f8136_0() throws Exception
{    Type4Tester.create("5 7 gt 7 5 gt 7 7 gt -1 2 gt").pop(false).pop(false).pop(true).pop(false).isEmpty();}
public void pdfbox_f8137_0() throws Exception
{    Type4Tester.create("5 7 le 7 5 le 7 7 le -1 2 le").pop(true).pop(true).pop(false).pop(true).isEmpty();}
public void pdfbox_f8138_0() throws Exception
{    Type4Tester.create("5 7 lt 7 5 lt 7 7 lt -1 2 lt").pop(true).pop(false).pop(false).pop(true).isEmpty();}
public void pdfbox_f8139_0() throws Exception
{    Type4Tester.create("7 7 ne 7 6 ne 7 -7 ne true true ne false true ne 7.7 7.7 ne").pop(false).pop(true).pop(false).pop(true).pop(true).pop(false).isEmpty();}
public void pdfbox_f8140_0() throws Exception
{    Type4Tester.create("true not false not").pop(true).pop(false).isEmpty();    Type4Tester.create("52 not -37 not").pop(37).pop(-52).isEmpty();}
public void pdfbox_f8141_0() throws Exception
{    Type4Tester.create("true true or true false or false false or").pop(false).pop(true).pop(true).isEmpty();    Type4Tester.create("17 5 or 1 1 or").pop(1).pop(21).isEmpty();}
public void pdfbox_f8142_0() throws Exception
{    Type4Tester.create("true true xor true false xor false false xor").pop(false).pop(true).pop(false).isEmpty();    Type4Tester.create("7 3 xor 12 3 or").pop(15).pop(4);}
public void pdfbox_f8143_0() throws Exception
{    Type4Tester.create("true { 2 1 add } if").pop(3).isEmpty();    Type4Tester.create("false { 2 1 add } if").isEmpty();    try {        Type4Tester.create("0 { 2 1 add } if");        fail("Need typecheck error for the '0'");    } catch (ClassCastException cce) {        }}
public void pdfbox_f8144_0() throws Exception
{    Type4Tester.create("true { 2 1 add } { 2 1 sub } ifelse").pop(3).isEmpty();    Type4Tester.create("false { 2 1 add } { 2 1 sub } ifelse").pop(1).isEmpty();}
public void pdfbox_f8145_0() throws Exception
{    Type4Tester.create("true 1 2 3 3 copy").pop(3).pop(2).pop(1).pop(3).pop(2).pop(1).pop(true).isEmpty();}
public void pdfbox_f8146_0() throws Exception
{    Type4Tester.create("true 1 2 dup").pop(2).pop(2).pop(1).pop(true).isEmpty();    Type4Tester.create("true dup").pop(true).pop(true).isEmpty();}
public void pdfbox_f8147_0() throws Exception
{    Type4Tester.create("true 1 exch").pop(true).pop(1).isEmpty();    Type4Tester.create("1 2.5 exch").pop(1).pop(2.5f).isEmpty();}
public void pdfbox_f8148_0() throws Exception
{    Type4Tester.create("1 2 3 4 0 index").pop(4).pop(4).pop(3).pop(2).pop(1).isEmpty();    Type4Tester.create("1 2 3 4 3 index").pop(1).pop(4).pop(3).pop(2).pop(1).isEmpty();}
public void pdfbox_f8149_0() throws Exception
{    Type4Tester.create("1 pop 7 2 pop").pop(7).isEmpty();    Type4Tester.create("1 2 3 pop pop").pop(1).isEmpty();}
public void pdfbox_f8150_0() throws Exception
{    Type4Tester.create("1 2 3 4 5 5 -2 roll").pop(2).pop(1).pop(5).pop(4).pop(3).isEmpty();    Type4Tester.create("1 2 3 4 5 5 2 roll").pop(3).pop(2).pop(1).pop(5).pop(4).isEmpty();    Type4Tester.create("1 2 3 3 0 roll").pop(3).pop(2).pop(1).isEmpty();}
public void pdfbox_f8151_0() throws Exception
{    Type4Tester.create("3 4 add 2 sub").pop(5).isEmpty();}
public void pdfbox_f8152_0() throws Exception
{    Type4Tester.create("true { 2 1 add } { 2 1 sub } ifelse").pop(3).isEmpty();    Type4Tester.create("{ true }").pop(true).isEmpty();}
public void pdfbox_f8153_0() throws Exception
{    assertEquals(0, InstructionSequenceBuilder.parseReal("0"), 0.00001f);    assertEquals(1, InstructionSequenceBuilder.parseReal("1"), 0.00001f);    assertEquals(1, InstructionSequenceBuilder.parseReal("+1"), 0.00001f);    assertEquals(-1, InstructionSequenceBuilder.parseReal("-1"), 0.00001f);    assertEquals(3.14157, InstructionSequenceBuilder.parseReal("3.14157"), 0.00001f);    assertEquals(-1.2, InstructionSequenceBuilder.parseReal("-1.2"), 0.00001f);    assertEquals(1.0E-5, InstructionSequenceBuilder.parseReal("1.0E-5"), 0.00001f);}
public void pdfbox_f8154_0() throws Exception
{                    Type4Tester.create("1 {dup dup .72 mul exch 0 exch .38 mul}\n").pop(0.38f).pop(0f).pop(0.72f).pop(1.0f).isEmpty();}
public static Type4Tester pdfbox_f8155_0(String text)
{    InstructionSequence instructions = InstructionSequenceBuilder.parse(text);    ExecutionContext context = new ExecutionContext(new Operators());    instructions.execute(context);    return new Type4Tester(context);}
public Type4Tester pdfbox_f8156_0(boolean expected)
{    boolean value = (Boolean) context.getStack().pop();    Assert.assertEquals(expected, value);    return this;}
public Type4Tester pdfbox_f8157_0(float expected)
{    return popReal(expected, 0.0000001);}
public Type4Tester pdfbox_f8158_0(float expected, double delta)
{    Float value = (Float) context.getStack().pop();    Assert.assertEquals(expected, value, delta);    return this;}
public Type4Tester pdfbox_f8159_0(int expected)
{    int value = context.popInt();    Assert.assertEquals(expected, value);    return this;}
public Type4Tester pdfbox_f8160_0(float expected)
{    return pop(expected, 0.0000001);}
public Type4Tester pdfbox_f8161_0(float expected, double delta)
{    Number value = context.popNumber();    Assert.assertEquals(expected, value.doubleValue(), delta);    return this;}
public Type4Tester pdfbox_f8162_0()
{    Assert.assertTrue(context.getStack().isEmpty());    return this;}
public ExecutionContext pdfbox_f8163_0()
{    return this.context;}
protected COSInteger pdfbox_f8164_0(COSBase base) throws IOException
{    return (COSInteger) base;}
protected PDIntegerNameTreeNode pdfbox_f8165_0(COSDictionary dic)
{    return new PDIntegerNameTreeNode(dic);}
public void pdfbox_f8166_0() throws Exception
{    try (PDDocument doc = new PDDocument()) {        InputStream is = new ByteArrayInputStream(new byte[] { 12, 34, 56, 78 });        PDStream pdStream = new PDStream(doc, is, (COSArray) null);        Assert.assertNull(pdStream.getFilters());        List<String> stopFilters = new ArrayList<>();        stopFilters.add(COSName.DCT_DECODE.toString());        stopFilters.add(COSName.DCT_DECODE_ABBREVIATION.toString());        is = pdStream.createInputStream(stopFilters);        Assert.assertEquals(12, is.read());        Assert.assertEquals(34, is.read());        Assert.assertEquals(56, is.read());        Assert.assertEquals(78, is.read());        Assert.assertEquals(-1, is.read());    }}
public void pdfbox_f8167_0() throws Exception
{    try (PDDocument doc = new PDDocument()) {        InputStream is = new ByteArrayInputStream(new byte[] { 12, 34, 56, 78 });        PDStream pdStream = new PDStream(doc, is, new COSArray());        Assert.assertEquals(0, pdStream.getFilters().size());        List<String> stopFilters = new ArrayList<>();        stopFilters.add(COSName.DCT_DECODE.toString());        stopFilters.add(COSName.DCT_DECODE_ABBREVIATION.toString());        is = pdStream.createInputStream(stopFilters);        Assert.assertEquals(12, is.read());        Assert.assertEquals(34, is.read());        Assert.assertEquals(56, is.read());        Assert.assertEquals(78, is.read());        Assert.assertEquals(-1, is.read());    }}
public void pdfbox_f8168_0() throws Exception
{    try (PDDocument doc = new PDDocument()) {        InputStream is = new ByteArrayInputStream(new byte[] { 12, 34, 56, 78 });        PDStream pdStream = new PDStream(doc, is, new COSArray());        Assert.assertEquals(0, pdStream.getFilters().size());        is = pdStream.createInputStream((List<String>) null);        Assert.assertEquals(12, is.read());        Assert.assertEquals(34, is.read());        Assert.assertEquals(56, is.read());        Assert.assertEquals(78, is.read());        Assert.assertEquals(-1, is.read());    }}
public void pdfbox_f8169_0() throws IOException
{    PDEmbeddedFile embeddedFile = null;    boolean ok = false;    try {        PDDocument doc = PDDocument.load(TestEmbeddedFiles.class.getResourceAsStream("null_PDComplexFileSpecification.pdf"));        PDDocumentCatalog catalog = doc.getDocumentCatalog();        PDDocumentNameDictionary names = catalog.getNames();        assertEquals("expected two files", 2, names.getEmbeddedFiles().getNames().size());        PDEmbeddedFilesNameTreeNode embeddedFiles = names.getEmbeddedFiles();        PDComplexFileSpecification spec = embeddedFiles.getNames().get("non-existent-file.docx");        if (spec != null) {            embeddedFile = spec.getEmbeddedFile();            ok = true;        }                spec = embeddedFiles.getNames().get("My first attachment");        assertNotNull("one attachment actually exists", spec);        assertEquals("existing file length", 17660, spec.getEmbeddedFile().getLength());        spec = embeddedFiles.getNames().get("non-existent-file.docx");    } catch (NullPointerException e) {        assertNotNull("null pointer exception", null);    }    assertTrue("Was able to get file without exception", ok);    assertNull("EmbeddedFile was correctly null", embeddedFile);}
public void pdfbox_f8170_0() throws IOException
{    PDEmbeddedFile nonOSFile = null;    PDEmbeddedFile macFile = null;    PDEmbeddedFile dosFile = null;    PDEmbeddedFile unixFile = null;    PDDocument doc = PDDocument.load(TestEmbeddedFiles.class.getResourceAsStream("testPDF_multiFormatEmbFiles.pdf"));    PDDocumentCatalog catalog = doc.getDocumentCatalog();    PDDocumentNameDictionary names = catalog.getNames();    PDEmbeddedFilesNameTreeNode treeNode = names.getEmbeddedFiles();    List<PDNameTreeNode<PDComplexFileSpecification>> kids = treeNode.getKids();    for (PDNameTreeNode<PDComplexFileSpecification> kid : kids) {        Map<String, PDComplexFileSpecification> tmpNames = kid.getNames();        COSObjectable obj = tmpNames.get("My first attachment");        PDComplexFileSpecification spec = (PDComplexFileSpecification) obj;        nonOSFile = spec.getEmbeddedFile();        macFile = spec.getEmbeddedFileMac();        dosFile = spec.getEmbeddedFileDos();        unixFile = spec.getEmbeddedFileUnix();    }    assertTrue("non os specific", byteArrayContainsLC("non os specific", nonOSFile.toByteArray(), "ISO-8859-1"));    assertTrue("mac", byteArrayContainsLC("mac embedded", macFile.toByteArray(), "ISO-8859-1"));    assertTrue("dos", byteArrayContainsLC("dos embedded", dosFile.toByteArray(), "ISO-8859-1"));    assertTrue("unix", byteArrayContainsLC("unix embedded", unixFile.toByteArray(), "ISO-8859-1"));}
private boolean pdfbox_f8171_0(String target, byte[] bytes, String encoding) throws UnsupportedEncodingException
{    String s = new String(bytes, encoding);    return s.toLowerCase().contains(target);}
protected void pdfbox_f8172_0() throws Exception
{    this.node5 = new PDIntegerNameTreeNode();    Map<String, COSInteger> names = new TreeMap<>();    names.put("Actinium", COSInteger.get(89));    names.put("Aluminum", COSInteger.get(13));    names.put("Americium", COSInteger.get(95));    names.put("Antimony", COSInteger.get(51));    names.put("Argon", COSInteger.get(18));    names.put("Arsenic", COSInteger.get(33));    names.put("Astatine", COSInteger.get(85));    this.node5.setNames(names);    this.node24 = new PDIntegerNameTreeNode();    names = new TreeMap<>();    names.put("Xenon", COSInteger.get(54));    names.put("Ytterbium", COSInteger.get(70));    names.put("Yttrium", COSInteger.get(39));    names.put("Zinc", COSInteger.get(30));    names.put("Zirconium", COSInteger.get(40));    this.node24.setNames(names);    this.node2 = new PDIntegerNameTreeNode();    List<PDNameTreeNode<COSInteger>> kids = this.node2.getKids();    if (kids == null) {        kids = new COSArrayList<>();    }    kids.add(this.node5);    this.node2.setKids(kids);    this.node4 = new PDIntegerNameTreeNode();    kids = this.node4.getKids();    if (kids == null) {        kids = new COSArrayList<>();    }    kids.add(this.node24);    this.node4.setKids(kids);    this.node1 = new PDIntegerNameTreeNode();    kids = this.node1.getKids();    if (kids == null) {        kids = new COSArrayList<>();    }    kids.add(this.node2);    kids.add(this.node4);    this.node1.setKids(kids);}
public void pdfbox_f8173_0() throws IOException
{    Assert.assertEquals("Astatine", this.node5.getUpperLimit());    Assert.assertEquals("Astatine", this.node2.getUpperLimit());    Assert.assertEquals("Zirconium", this.node24.getUpperLimit());    Assert.assertEquals("Zirconium", this.node4.getUpperLimit());    Assert.assertEquals(null, this.node1.getUpperLimit());}
public void pdfbox_f8174_0() throws IOException
{    Assert.assertEquals("Actinium", this.node5.getLowerLimit());    Assert.assertEquals("Actinium", this.node2.getLowerLimit());    Assert.assertEquals("Xenon", this.node24.getLowerLimit());    Assert.assertEquals("Xenon", this.node4.getLowerLimit());    Assert.assertEquals(null, this.node1.getLowerLimit());}
public COSBase pdfbox_f8175_0()
{    return COSInteger.get(value);}
public int pdfbox_f8176_0()
{    final int prime = 31;    int result = 1;    result = prime * result + value;    return result;}
public boolean pdfbox_f8177_0(Object obj)
{    if (this == obj) {        return true;    }    if (obj == null) {        return false;    }    if (getClass() != obj.getClass()) {        return false;    }    PDTest other = (PDTest) obj;    return value == other.value;}
protected void pdfbox_f8178_0() throws Exception
{    this.node5 = new PDNumberTreeNode(PDTest.class);    Map<Integer, PDTest> Numbers = new TreeMap<>();    Numbers.put(1, new PDTest(89));    Numbers.put(2, new PDTest(13));    Numbers.put(3, new PDTest(95));    Numbers.put(4, new PDTest(51));    Numbers.put(5, new PDTest(18));    Numbers.put(6, new PDTest(33));    Numbers.put(7, new PDTest(85));    this.node5.setNumbers(Numbers);    this.node24 = new PDNumberTreeNode(PDTest.class);    Numbers = new TreeMap<>();    Numbers.put(8, new PDTest(54));    Numbers.put(9, new PDTest(70));    Numbers.put(10, new PDTest(39));    Numbers.put(11, new PDTest(30));    Numbers.put(12, new PDTest(40));    this.node24.setNumbers(Numbers);    this.node2 = new PDNumberTreeNode(PDTest.class);    List<PDNumberTreeNode> kids = this.node2.getKids();    if (kids == null) {        kids = new COSArrayList<>();    }    kids.add(this.node5);    this.node2.setKids(kids);    this.node4 = new PDNumberTreeNode(PDTest.class);    kids = this.node4.getKids();    if (kids == null) {        kids = new COSArrayList<>();    }    kids.add(this.node24);    this.node4.setKids(kids);    this.node1 = new PDNumberTreeNode(PDTest.class);    kids = this.node1.getKids();    if (kids == null) {        kids = new COSArrayList<>();    }    kids.add(this.node2);    kids.add(this.node4);    this.node1.setKids(kids);}
public void pdfbox_f8179_0() throws IOException
{    Assert.assertEquals(new PDTest(51), this.node5.getValue(4));    Assert.assertEquals(new PDTest(70), this.node1.getValue(9));    this.node1.setKids(null);    this.node1.setNumbers(null);    Assert.assertNull(this.node1.getValue(0));}
public void pdfbox_f8180_0() throws IOException
{    Assert.assertEquals(7, (int) this.node5.getUpperLimit());    Assert.assertEquals(7, (int) this.node2.getUpperLimit());    Assert.assertEquals(12, (int) this.node24.getUpperLimit());    Assert.assertEquals(12, (int) this.node4.getUpperLimit());    Assert.assertEquals(12, (int) this.node1.getUpperLimit());    this.node24.setNumbers(new HashMap<Integer, COSObjectable>());    Assert.assertNull(this.node24.getUpperLimit());    this.node5.setNumbers(null);    Assert.assertNull(this.node5.getUpperLimit());    this.node1.setKids(null);    Assert.assertNull(this.node1.getUpperLimit());}
public void pdfbox_f8181_0() throws IOException
{    Assert.assertEquals(1, (int) this.node5.getLowerLimit());    Assert.assertEquals(1, (int) this.node2.getLowerLimit());    Assert.assertEquals(8, (int) this.node24.getLowerLimit());    Assert.assertEquals(8, (int) this.node4.getLowerLimit());    Assert.assertEquals(1, (int) this.node1.getLowerLimit());    this.node24.setNumbers(new HashMap<Integer, COSObjectable>());    Assert.assertNull(this.node24.getLowerLimit());    this.node5.setNumbers(null);    Assert.assertNull(this.node5.getLowerLimit());    this.node1.setKids(null);    Assert.assertNull(this.node1.getLowerLimit());}
public void pdfbox_f8182_0() throws IOException
{    Set<Revisions<PDAttributeObject>> attributeSet = new HashSet<>();    try (PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4197.pdf"))) {        PDStructureTreeRoot structureTreeRoot = doc.getDocumentCatalog().getStructureTreeRoot();        checkElement(structureTreeRoot.getK(), attributeSet);    }        Assert.assertEquals(117, attributeSet.size());    int cnt = 0;    for (Revisions<PDAttributeObject> attributes : attributeSet) {        cnt += attributes.size();    }        Assert.assertEquals(111, cnt);}
private void pdfbox_f8183_0(COSBase base, Set<Revisions<PDAttributeObject>> attributeSet)
{    if (base instanceof COSArray) {        for (COSBase base2 : (COSArray) base) {            if (base2 instanceof COSObject) {                base2 = ((COSObject) base2).getObject();            }            checkElement(base2, attributeSet);        }    } else if (base instanceof COSDictionary) {        COSDictionary kdict = (COSDictionary) base;        if (kdict.containsKey(COSName.PG)) {            PDStructureElement structureElement = new PDStructureElement(kdict);            Revisions<PDAttributeObject> attributes = structureElement.getAttributes();            attributeSet.add(attributes);            Revisions<String> classNames = structureElement.getClassNames();                }        if (kdict.containsKey(COSName.K)) {            checkElement(kdict.getDictionaryObject(COSName.K), attributeSet);        }    }}
public void pdfbox_f8184_0() throws IOException, URISyntaxException
{    File f = new File(FDFAnnotationTest.class.getResource("xfdf-test-document-annotations.xml").toURI());    try (FDFDocument fdfDoc = FDFDocument.loadXFDF(f)) {        List<FDFAnnotation> fdfAnnots = fdfDoc.getCatalog().getFDF().getAnnotations();        assertEquals(18, fdfAnnots.size());                                        boolean testedPDFBox4345andPDFBox3646 = false;        for (FDFAnnotation ann : fdfAnnots) {            if (ann instanceof FDFAnnotationFreeText) {                FDFAnnotationFreeText annotationFreeText = (FDFAnnotationFreeText) ann;                if ("P&1 P&2 P&3".equals(annotationFreeText.getContents())) {                    testedPDFBox4345andPDFBox3646 = true;                    Assert.assertEquals("<body style=\"font:12pt Helvetica; " + "color:#D66C00;\" xfa:APIVersion=\"Acrobat:7.0.8\" " + "xfa:spec=\"2.0.2\" xmlns=\"http://www.w3.org/1999/xhtml\" " + "xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n" + "          <p dir=\"ltr\">P&amp;1 <span style=\"text-" + "decoration:word;font-family:Helvetica\">P&amp;2</span> " + "P&amp;3</p>\n" + "        </body>", annotationFreeText.getRichContents().trim());                }            }        }        Assert.assertTrue(testedPDFBox4345andPDFBox3646);    }}
public void pdfbox_f8185_0() throws IOException
{    String testString = "Test value";    COSString testCOSString = new COSString(testString);    FDFField field = new FDFField();    field.setValue(testCOSString);    assertEquals(testCOSString, (COSString) field.getCOSValue());    assertEquals(testString, field.getValue());}
public void pdfbox_f8186_0() throws IOException
{    String testString = "Test value";    byte[] testBytes = testString.getBytes("ASCII");    COSStream stream = createStream(testBytes, null);    FDFField field = new FDFField();    field.setValue(stream);    assertEquals(testString, field.getValue());}
public void pdfbox_f8187_0() throws IOException
{    String testString = "Yes";    COSName testCOSSName = COSName.getPDFName(testString);    FDFField field = new FDFField();    field.setValue(testCOSSName);    assertEquals(testCOSSName, (COSName) field.getCOSValue());    assertEquals(testString, field.getValue());}
public void pdfbox_f8188_0() throws IOException
{    List<String> testList = new ArrayList<>();    testList.add("A");    testList.add("B");    COSArray testCOSArray = COSArrayList.convertStringListToCOSStringCOSArray(testList);    FDFField field = new FDFField();    field.setValue(testCOSArray);    assertEquals(testCOSArray, (COSArray) field.getCOSValue());    assertEquals(testList, field.getValue());}
private COSStream pdfbox_f8189_0(byte[] testString, COSBase filters) throws IOException
{    COSStream stream = new COSStream();    OutputStream output = stream.createOutputStream(filters);    output.write(testString);    output.close();    return stream;}
public void pdfbox_f8190_0() throws Exception
{    OUT_DIR.mkdirs();}
public void pdfbox_f8191_0() throws IOException, URISyntaxException
{    try (PDDocument doc = PDDocument.load(new File(PDFontTest.class.getResource("F001u_3_7j.pdf").toURI()))) {        PDFRenderer renderer = new PDFRenderer(doc);        renderer.renderImage(0);        }}
public void pdfbox_f8192_0() throws IOException
{    File file = new File("c:/windows/fonts", "calibri.ttf");    if (!file.exists()) {        System.out.println("testPDFBox3747 skipped");        return;    }    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDFont font = PDType0Font.load(doc, file);        try (PDPageContentStream cs = new PDPageContentStream(doc, page)) {            cs.beginText();            cs.setFont(font, 10);            cs.showText("PDFBOX-3747");            cs.endText();        }        doc.save(baos);    }    try (PDDocument doc = PDDocument.load(baos.toByteArray())) {        PDFTextStripper stripper = new PDFTextStripper();        String text = stripper.getText(doc);        Assert.assertEquals("PDFBOX-3747", text.trim());    }}
public void pdfbox_f8193_0() throws IOException, URISyntaxException
{    URL url = PDFont.class.getResource("/org/apache/pdfbox/resources/ttf/LiberationSans-Regular.ttf");    File fontFile = new File(url.toURI());    try (TrueTypeFont ttf1 = new TTFParser().parse(fontFile)) {        testPDFBox3826checkFonts(testPDFBox3826createDoc(ttf1), fontFile);    }    try (TrueTypeFont ttf2 = new TTFParser().parse(new FileInputStream(fontFile))) {        testPDFBox3826checkFonts(testPDFBox3826createDoc(ttf2), fontFile);    }}
public void pdfbox_f8194_0() throws IOException
{    File fontFile = new File("target/fonts", "n019003l.pfb");    File outputFile = new File(OUT_DIR, "FontType1.pdf");    String text = "äöüÄÖÜ";    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page)) {            PDType1Font font = new PDType1Font(doc, new FileInputStream(fontFile), WinAnsiEncoding.INSTANCE);            contentStream.beginText();            contentStream.setFont(font, 10);            contentStream.newLineAtOffset(10, 700);            contentStream.showText(text);            contentStream.endText();        }        doc.addPage(page);        doc.save(outputFile);    }    try (PDDocument doc = PDDocument.load(outputFile)) {        PDType1Font font = (PDType1Font) doc.getPage(0).getResources().getFont(COSName.getPDFName("F1"));        Assert.assertEquals(font.getEncoding(), WinAnsiEncoding.INSTANCE);        for (char c : text.toCharArray()) {            String name = font.getEncoding().getName(c);            Assert.assertEquals("dieresis", name.substring(1));            Assert.assertFalse(font.getPath(name).getBounds2D().isEmpty());        }        PDFTextStripper stripper = new PDFTextStripper();        Assert.assertEquals(text, stripper.getText(doc).trim());    }}
public void pdfbox_f8195_0() throws IOException
{    try {        PDType1Font.HELVETICA_BOLD.encode("\u0080");        Assert.fail("should have thrown IllegalArgumentException");    } catch (IllegalArgumentException ex) {    }    PDType1Font.HELVETICA_BOLD.encode("€");    try {        PDType1Font.HELVETICA_BOLD.encode("\u0080");        Assert.fail("should have thrown IllegalArgumentException");    } catch (IllegalArgumentException ex) {    }}
private void pdfbox_f8196_0(byte[] byteArray, File fontFile) throws IOException
{    try (PDDocument doc = PDDocument.load(byteArray)) {        PDPage page2 = doc.getPage(0);                PDType0Font fontF1 = (PDType0Font) page2.getResources().getFont(COSName.getPDFName("F1"));        Assert.assertTrue(fontF1.getName().contains("+"));        Assert.assertTrue(fontFile.length() > fontF1.getFontDescriptor().getFontFile2().toByteArray().length);                PDType0Font fontF2 = (PDType0Font) page2.getResources().getFont(COSName.getPDFName("F2"));        Assert.assertFalse(fontF2.getName().contains("+"));        Assert.assertEquals(fontFile.length(), fontF2.getFontDescriptor().getFontFile2().toByteArray().length);                PDTrueTypeFont fontF3 = (PDTrueTypeFont) page2.getResources().getFont(COSName.getPDFName("F3"));        Assert.assertFalse(fontF2.getName().contains("+"));        Assert.assertEquals(fontFile.length(), fontF3.getFontDescriptor().getFontFile2().toByteArray().length);        new PDFRenderer(doc).renderImage(0);        PDFTextStripper stripper = new PDFTextStripper();        stripper.setLineSeparator("\n");        String text = stripper.getText(doc);        Assert.assertEquals("testMultipleFontFileReuse1\ntestMultipleFontFileReuse2\ntestMultipleFontFileReuse3", text.trim());    }}
private byte[] pdfbox_f8197_0(TrueTypeFont ttf) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);                PDFont font = PDType0Font.load(doc, ttf, true);        try (PDPageContentStream cs = new PDPageContentStream(doc, page)) {            cs.beginText();            cs.newLineAtOffset(10, 700);            cs.setFont(font, 10);            cs.showText("testMultipleFontFileReuse1");            cs.endText();                        font = PDType0Font.load(doc, ttf, false);            cs.beginText();            cs.newLineAtOffset(10, 650);            cs.setFont(font, 10);            cs.showText("testMultipleFontFileReuse2");            cs.endText();                        font = PDTrueTypeFont.load(doc, ttf, WinAnsiEncoding.INSTANCE);            cs.beginText();            cs.newLineAtOffset(10, 600);            cs.setFont(font, 10);            cs.showText("testMultipleFontFileReuse3");            cs.endText();        }        doc.save(baos);    }    return baos.toByteArray();}
protected void pdfbox_f8198_0()
{    OUT_DIR.mkdirs();}
public void pdfbox_f8199_0() throws IOException
{    validateCIDFontType2(false);}
public void pdfbox_f8200_0() throws IOException
{    validateCIDFontType2(true);}
public void pdfbox_f8201_0() throws IOException
{    String text = "「ABC」";    String expectedExtractedtext = "「\nA\nB\nC\n」";    File pdf = new File(OUT_DIR, "CIDFontType2VM.pdf");    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);        File ipafont = new File("target/fonts/ipag00303", "ipag.ttf");        PDType0Font vfont = PDType0Font.loadVertical(document, ipafont);        try (PDPageContentStream contentStream = new PDPageContentStream(document, page)) {            contentStream.beginText();            contentStream.setFont(vfont, 20);            contentStream.newLineAtOffset(50, 700);            contentStream.showText(text);            contentStream.endText();        }                byte[] encode = vfont.encode(text);        int cid = ((encode[0] & 0xFF) << 8) + (encode[1] & 0xFF);                assertEquals(7392, cid);                COSDictionary fontDict = vfont.getCOSObject();        assertEquals(COSName.IDENTITY_V, fontDict.getDictionaryObject(COSName.ENCODING));        document.save(pdf);                COSDictionary descFontDict = vfont.getDescendantFont().getCOSObject();        COSArray dw2 = (COSArray) descFontDict.getDictionaryObject(COSName.DW2);                assertNull(dw2);        COSArray w2 = (COSArray) descFontDict.getDictionaryObject(COSName.W2);                assertEquals(0, w2.size());    }        String extracted = getUnicodeText(pdf);    assertEquals(expectedExtractedtext, extracted.replaceAll("\r", "").trim());}
public void pdfbox_f8202_0() throws IOException
{    String text = "「ABC」";    String expectedExtractedtext = "「\nA\nB\nC\n」";    File pdf = new File(OUT_DIR, "CIDFontType2VP.pdf");    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);        File ipafont = new File("target/fonts/ipagp00303", "ipagp.ttf");        PDType0Font vfont = PDType0Font.loadVertical(document, ipafont);        try (PDPageContentStream contentStream = new PDPageContentStream(document, page)) {            contentStream.beginText();            contentStream.setFont(vfont, 20);            contentStream.newLineAtOffset(50, 700);            contentStream.showText(text);            contentStream.endText();        }                byte[] encode = vfont.encode(text);        int cid = ((encode[0] & 0xFF) << 8) + (encode[1] & 0xFF);                assertEquals(12607, cid);                COSDictionary fontDict = vfont.getCOSObject();        assertEquals(COSName.IDENTITY_V, fontDict.getDictionaryObject(COSName.ENCODING));        document.save(pdf);                COSDictionary descFontDict = vfont.getDescendantFont().getCOSObject();        COSArray dw2 = (COSArray) descFontDict.getDictionaryObject(COSName.DW2);                assertNull(dw2);                COSArray w2 = (COSArray) descFontDict.getDictionaryObject(COSName.W2);        assertEquals(2, w2.size());                assertEquals(12607, w2.getInt(0));        COSArray metrics = (COSArray) w2.getObject(1);        int i = 0;        for (int n : new int[] { -570, 500, 450, -570, 500, 880 }) {            assertEquals(n, metrics.getInt(i++));        }    }        String extracted = getUnicodeText(pdf);    assertEquals(expectedExtractedtext, extracted.replaceAll("\r", "").trim());}
public void pdfbox_f8203_0() throws IOException
{    String BANGLA_TEXT_1 = "আমি কোন পথে ক্ষীরের লক্ষ্মী ষন্ড পুতুল রুপো গঙ্গা ঋষি";    String BANGLA_TEXT_2 = "দ্রুত গাঢ় শেয়াল অলস কুকুর জুড়ে জাম্প ধুর্ত  হঠাৎ ভাঙেনি মৌলিক ঐশি দৈ";    String BANGLA_TEXT_3 = "ঋষি কল্লোল ব্যাস নির্ভয় ";    String expectedExtractedtext = BANGLA_TEXT_1 + "\n" + BANGLA_TEXT_2 + "\n" + BANGLA_TEXT_3;    File pdf = new File(OUT_DIR, "Bengali.pdf");    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);        PDFont font = PDType0Font.load(document, this.getClass().getResourceAsStream("/org/apache/pdfbox/ttf/Lohit-Bengali.ttf"));        try (PDPageContentStream contentStream = new PDPageContentStream(document, page)) {            contentStream.beginText();            contentStream.setFont(font, 18);            contentStream.newLineAtOffset(10, 750);            contentStream.showText(BANGLA_TEXT_1);            contentStream.newLineAtOffset(0, -30);            contentStream.showText(BANGLA_TEXT_2);            contentStream.newLineAtOffset(0, -30);            contentStream.showText(BANGLA_TEXT_3);            contentStream.endText();        }        document.save(pdf);    }    File IN_DIR = new File("src/test/resources/org/apache/pdfbox/ttf");        TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(pdf, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.err.println("Rendering of " + pdf + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }        String extracted = getUnicodeText(pdf);}
public void pdfbox_f8204_0() throws IOException
{    File file;    String text;    text = "あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん" + "アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン" + "１２３４５６７８";        Set<Character> set = new HashSet<>(ToUnicodeWriter.MAX_ENTRIES_PER_OPERATOR);    for (int i = 0; i < text.length(); ++i) {        set.add(text.charAt(i));    }    assertEquals(ToUnicodeWriter.MAX_ENTRIES_PER_OPERATOR, set.size());    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A0);        document.addPage(page);        File ipafont = new File("target/fonts/ipag00303", "ipag.ttf");        PDType0Font font = PDType0Font.load(document, ipafont);        try (PDPageContentStream contentStream = new PDPageContentStream(document, page)) {            contentStream.beginText();            contentStream.setFont(font, 20);            contentStream.newLineAtOffset(50, 3000);            contentStream.showText(text);            contentStream.endText();        }        file = new File(OUT_DIR, "PDFBOX-4302-test.pdf");        document.save(file);    }        String extracted = getUnicodeText(file);    assertEquals(text, extracted.trim());}
private void pdfbox_f8205_0(boolean useSubset) throws IOException
{    String text;    File file;    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);        InputStream input = PDFont.class.getResourceAsStream("/org/apache/pdfbox/resources/ttf/LiberationSans-Regular.ttf");        PDType0Font font = PDType0Font.load(document, input, useSubset);        try (PDPageContentStream stream = new PDPageContentStream(document, page)) {            stream.beginText();            stream.setFont(font, 12);            text = "Unicode русский язык Tiếng Việt";            stream.newLineAtOffset(50, 600);            stream.showText(text);            stream.endText();        }        file = new File(OUT_DIR, "CIDFontType2.pdf");        document.save(file);    }        String extracted = getUnicodeText(file);    assertEquals(text, extracted.trim());}
private String pdfbox_f8206_0(File file) throws IOException
{    PDDocument document = PDDocument.load(file);    PDFTextStripper stripper = new PDFTextStripper();    return stripper.getText(document);}
public void pdfbox_f8207_0() throws Exception
{        int codeForSpace = WinAnsiEncoding.INSTANCE.getNameToCodeMap().get("space");    assertEquals(32, codeForSpace);    codeForSpace = MacRomanEncoding.INSTANCE.getNameToCodeMap().get("space");    assertEquals(32, codeForSpace);}
public void pdfbox_f8208_0() throws Exception
{        COSDictionary dictEncodingDict = new COSDictionary();    dictEncodingDict.setItem(COSName.TYPE, COSName.ENCODING);    dictEncodingDict.setItem(COSName.BASE_ENCODING, COSName.WIN_ANSI_ENCODING);    COSArray differences = new COSArray();    differences.add(COSInteger.get(32));    differences.add(COSName.getPDFName("a"));    dictEncodingDict.setItem(COSName.DIFFERENCES, differences);    DictionaryEncoding dictEncoding = new DictionaryEncoding(dictEncodingDict, false, null);    assertNull(dictEncoding.getNameToCodeMap().get("space"));    assertEquals(32, dictEncoding.getNameToCodeMap().get("a").intValue());}
public void pdfbox_f8209_0() throws IOException
{    PDDocument doc = new PDDocument();    PDPage page = new PDPage();    doc.addPage(page);    PDPageContentStream cs = new PDPageContentStream(doc, page);    cs.setFont(PDType1Font.HELVETICA, 20);    cs.beginText();    cs.newLineAtOffset(100, 700);            cs.showText("~˜");    cs.endText();    cs.close();    ByteArrayOutputStream baos = new ByteArrayOutputStream();    doc.save(baos);    doc.close();        doc = PDDocument.load(baos.toByteArray());    PDFTextStripper stripper = new PDFTextStripper();    String text = stripper.getText(doc);    assertEquals("~˜", text.trim());    doc.close();}
public void pdfbox_f8210_0() throws IOException
{    InputStream input = PDFont.class.getResourceAsStream("/org/apache/pdfbox/resources/ttf/LiberationSans-Regular.ttf");    Assert.assertNotNull(input);    TTFParser parser = new TTFParser();    TrueTypeFont font = parser.parse(input);    CmapTable cmapTable = font.getCmap();    Assert.assertNotNull(cmapTable);    CmapSubtable[] cmaps = cmapTable.getCmaps();    Assert.assertNotNull(cmaps);    CmapSubtable cmap = null;    for (CmapSubtable e : cmaps) {        if (e.getPlatformId() == NameRecord.PLATFORM_WINDOWS && e.getPlatformEncodingId() == NameRecord.ENCODING_WINDOWS_UNICODE_BMP) {            cmap = e;            break;        }    }    Assert.assertNotNull(cmap);    PostScriptTable post = font.getPostScript();    Assert.assertNotNull(post);    String[] glyphNames = font.getPostScript().getGlyphNames();    Assert.assertNotNull(glyphNames);            int gid = cmap.getGlyphId(0x2122);    Assert.assertEquals("trademark", glyphNames[gid]);            gid = cmap.getGlyphId(0x20AC);    Assert.assertEquals("Euro", glyphNames[gid]);}
public void pdfbox_f8211_0()
{    assertEquals(BlendMode.NORMAL, BlendMode.getInstance(COSName.NORMAL));    assertEquals(BlendMode.NORMAL, BlendMode.getInstance(COSName.COMPATIBLE));    assertEquals(BlendMode.MULTIPLY, BlendMode.getInstance(COSName.MULTIPLY));    assertEquals(BlendMode.SCREEN, BlendMode.getInstance(COSName.SCREEN));    assertEquals(BlendMode.OVERLAY, BlendMode.getInstance(COSName.OVERLAY));    assertEquals(BlendMode.DARKEN, BlendMode.getInstance(COSName.DARKEN));    assertEquals(BlendMode.LIGHTEN, BlendMode.getInstance(COSName.LIGHTEN));    assertEquals(BlendMode.COLOR_DODGE, BlendMode.getInstance(COSName.COLOR_DODGE));    assertEquals(BlendMode.COLOR_BURN, BlendMode.getInstance(COSName.COLOR_BURN));    assertEquals(BlendMode.HARD_LIGHT, BlendMode.getInstance(COSName.HARD_LIGHT));    assertEquals(BlendMode.SOFT_LIGHT, BlendMode.getInstance(COSName.SOFT_LIGHT));    assertEquals(BlendMode.DIFFERENCE, BlendMode.getInstance(COSName.DIFFERENCE));    assertEquals(BlendMode.EXCLUSION, BlendMode.getInstance(COSName.EXCLUSION));    assertEquals(BlendMode.HUE, BlendMode.getInstance(COSName.HUE));    assertEquals(BlendMode.SATURATION, BlendMode.getInstance(COSName.SATURATION));    assertEquals(BlendMode.LUMINOSITY, BlendMode.getInstance(COSName.LUMINOSITY));    assertEquals(BlendMode.COLOR, BlendMode.getInstance(COSName.COLOR));}
public void pdfbox_f8212_0()
{    assertEquals(COSName.NORMAL, BlendMode.getCOSName(BlendMode.NORMAL));    assertEquals(COSName.NORMAL, BlendMode.getCOSName(BlendMode.COMPATIBLE));    assertEquals(COSName.MULTIPLY, BlendMode.getCOSName(BlendMode.MULTIPLY));    assertEquals(COSName.SCREEN, BlendMode.getCOSName(BlendMode.SCREEN));    assertEquals(COSName.OVERLAY, BlendMode.getCOSName(BlendMode.OVERLAY));    assertEquals(COSName.DARKEN, BlendMode.getCOSName(BlendMode.DARKEN));    assertEquals(COSName.LIGHTEN, BlendMode.getCOSName(BlendMode.LIGHTEN));    assertEquals(COSName.COLOR_DODGE, BlendMode.getCOSName(BlendMode.COLOR_DODGE));    assertEquals(COSName.COLOR_BURN, BlendMode.getCOSName(BlendMode.COLOR_BURN));    assertEquals(COSName.HARD_LIGHT, BlendMode.getCOSName(BlendMode.HARD_LIGHT));    assertEquals(COSName.SOFT_LIGHT, BlendMode.getCOSName(BlendMode.SOFT_LIGHT));    assertEquals(COSName.DIFFERENCE, BlendMode.getCOSName(BlendMode.DIFFERENCE));    assertEquals(COSName.EXCLUSION, BlendMode.getCOSName(BlendMode.EXCLUSION));    assertEquals(COSName.HUE, BlendMode.getCOSName(BlendMode.HUE));    assertEquals(COSName.SATURATION, BlendMode.getCOSName(BlendMode.SATURATION));    assertEquals(COSName.LUMINOSITY, BlendMode.getCOSName(BlendMode.LUMINOSITY));    assertEquals(COSName.COLOR, BlendMode.getCOSName(BlendMode.COLOR));}
public void pdfbox_f8213_0() throws IOException
{    PDDeviceCMYK.INSTANCE = new CustomDeviceCMYK();}
public void pdfbox_f8214_0()
{    PDDocument doc = new PDDocument();    PDICCBased iccBased = new PDICCBased(doc);    assertEquals("ICCBased", iccBased.getName());    assertNotNull(iccBased.getPDStream());}
public void pdfbox_f8215_0()
{    PDLab pdLab = new PDLab();    COSArray cosArray = (COSArray) pdLab.getCOSObject();    COSDictionary dict = (COSDictionary) cosArray.getObject(1);        assertEquals("Lab", pdLab.getName());    assertEquals(3, pdLab.getNumberOfComponents());    assertNotNull(pdLab.getInitialColor());    assertTrue(Arrays.equals(new float[] { 0, 0, 0 }, pdLab.getInitialColor().getComponents()));    assertEquals(0f, pdLab.getBlackPoint().getX());    assertEquals(0f, pdLab.getBlackPoint().getY());    assertEquals(0f, pdLab.getBlackPoint().getZ());    assertEquals(1f, pdLab.getWhitepoint().getX());    assertEquals(1f, pdLab.getWhitepoint().getY());    assertEquals(1f, pdLab.getWhitepoint().getZ());    assertEquals(-100f, pdLab.getARange().getMin());    assertEquals(100f, pdLab.getARange().getMax());    assertEquals(-100f, pdLab.getBRange().getMin());    assertEquals(100f, pdLab.getBRange().getMax());    assertEquals("read operations should not change the size of /Lab objects", 0, dict.size());        dict.toString();        PDRange pdRange = new PDRange();    pdRange.setMin(-1);    pdRange.setMax(2);    pdLab.setARange(pdRange);    pdRange = new PDRange();    pdRange.setMin(3);    pdRange.setMax(4);    pdLab.setBRange(pdRange);    assertEquals(-1f, pdLab.getARange().getMin());    assertEquals(2f, pdLab.getARange().getMax());    assertEquals(3f, pdLab.getBRange().getMin());    assertEquals(4f, pdLab.getBRange().getMax());    PDTristimulus pdTristimulus = new PDTristimulus();    pdTristimulus.setX(5);    pdTristimulus.setY(6);    pdTristimulus.setZ(7);    pdLab.setWhitePoint(pdTristimulus);    pdTristimulus = new PDTristimulus();    pdTristimulus.setX(8);    pdTristimulus.setY(9);    pdTristimulus.setZ(10);    pdLab.setBlackPoint(pdTristimulus);    assertEquals(5f, pdLab.getWhitepoint().getX());    assertEquals(6f, pdLab.getWhitepoint().getY());    assertEquals(7f, pdLab.getWhitepoint().getZ());    assertEquals(8f, pdLab.getBlackPoint().getX());    assertEquals(9f, pdLab.getBlackPoint().getY());    assertEquals(10f, pdLab.getBlackPoint().getZ());    assertTrue(Arrays.equals(new float[] { 0, 0, 3 }, pdLab.getInitialColor().getComponents()));}
protected void pdfbox_f8216_0() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
public void pdfbox_f8217_0() throws IOException
{    String tiffG3Path = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg3.tif";    String tiffG4Path = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg4.tif";    PDDocument document = new PDDocument();    PDImageXObject ximage3 = CCITTFactory.createFromFile(document, new File(tiffG3Path));    validate(ximage3, 1, 344, 287, "tiff", PDDeviceGray.INSTANCE.getName());    BufferedImage bim3 = ImageIO.read(new File(tiffG3Path));    checkIdent(bim3, ximage3.getOpaqueImage());    PDPage page = new PDPage(PDRectangle.A4);    document.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(ximage3, 0, 0, ximage3.getWidth(), ximage3.getHeight());    contentStream.close();    PDImageXObject ximage4 = CCITTFactory.createFromFile(document, new File(tiffG4Path));    validate(ximage4, 1, 344, 287, "tiff", PDDeviceGray.INSTANCE.getName());    BufferedImage bim4 = ImageIO.read(new File(tiffG3Path));    checkIdent(bim4, ximage4.getOpaqueImage());    page = new PDPage(PDRectangle.A4);    document.addPage(page);    contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(ximage4, 0, 0);    contentStream.close();    document.save(testResultsDir + "/singletiff.pdf");    document.close();    document = PDDocument.load(new File(testResultsDir, "singletiff.pdf"));    assertEquals(2, document.getNumberOfPages());    document.close();}
public void pdfbox_f8218_0() throws IOException
{    String tiffPath = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg4multi.tif";    ImageInputStream is = ImageIO.createImageInputStream(new File(tiffPath));    ImageReader imageReader = ImageIO.getImageReaders(is).next();    imageReader.setInput(is);    int countTiffImages = imageReader.getNumImages(true);    assertTrue(countTiffImages > 1);    PDDocument document = new PDDocument();    int pdfPageNum = 0;    while (true) {        PDImageXObject ximage = CCITTFactory.createFromFile(document, new File(tiffPath), pdfPageNum);        if (ximage == null) {            break;        }        BufferedImage bim = imageReader.read(pdfPageNum);        validate(ximage, 1, bim.getWidth(), bim.getHeight(), "tiff", PDDeviceGray.INSTANCE.getName());        checkIdent(bim, ximage.getOpaqueImage());        PDPage page = new PDPage(PDRectangle.A4);        float fX = ximage.getWidth() / page.getMediaBox().getWidth();        float fY = ximage.getHeight() / page.getMediaBox().getHeight();        float factor = Math.max(fX, fY);        document.addPage(page);        PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);        contentStream.drawImage(ximage, 0, 0, ximage.getWidth() / factor, ximage.getHeight() / factor);        contentStream.close();        ++pdfPageNum;    }    assertEquals(countTiffImages, pdfPageNum);    document.save(testResultsDir + "/multitiff.pdf");    document.close();    document = PDDocument.load(new File(testResultsDir, "multitiff.pdf"), (String) null);    assertEquals(countTiffImages, document.getNumberOfPages());    document.close();    imageReader.dispose();}
public void pdfbox_f8219_0() throws IOException
{    String tiffG4Path = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg4.tif";    PDDocument document = new PDDocument();    BufferedImage bim = ImageIO.read(new File(tiffG4Path));    PDImageXObject ximage3 = CCITTFactory.createFromImage(document, bim);    validate(ximage3, 1, 344, 287, "tiff", PDDeviceGray.INSTANCE.getName());    checkIdent(bim, ximage3.getOpaqueImage());    PDPage page = new PDPage(PDRectangle.A4);    document.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(ximage3, 0, 0, ximage3.getWidth(), ximage3.getHeight());    contentStream.close();    document.save(testResultsDir + "/singletifffrombi.pdf");    document.close();    document = PDDocument.load(new File(testResultsDir, "singletifffrombi.pdf"));    assertEquals(1, document.getNumberOfPages());    document.close();}
public void pdfbox_f8220_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage bim = new BufferedImage(343, 287, BufferedImage.TYPE_BYTE_BINARY);        assertTrue((bim.getWidth() / 8) * 8 != bim.getWidth());    int col = 0;    for (int x = 0; x < bim.getWidth(); ++x) {        for (int y = 0; y < bim.getHeight(); ++y) {            bim.setRGB(x, y, col & 0xFFFFFF);            col = ~col;        }    }    PDImageXObject ximage3 = CCITTFactory.createFromImage(document, bim);    validate(ximage3, 1, 343, 287, "tiff", PDDeviceGray.INSTANCE.getName());    checkIdent(bim, ximage3.getOpaqueImage());    PDPage page = new PDPage(PDRectangle.A4);    document.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(ximage3, 0, 0, ximage3.getWidth(), ximage3.getHeight());    contentStream.close();    document.save(testResultsDir + "/singletifffromchessbi.pdf");    document.close();    document = PDDocument.load(new File(testResultsDir, "singletifffromchessbi.pdf"));    assertEquals(1, document.getNumberOfPages());    document.close();}
public void pdfbox_f8221_0() throws IOException
{        String tiffG3Path = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg3.tif";    File copiedTiffFile = new File(testResultsDir, "ccittg3.tif");    Files.copy(new File(tiffG3Path).toPath(), copiedTiffFile.toPath(), StandardCopyOption.REPLACE_EXISTING);    PDDocument document = new PDDocument();    CCITTFactory.createFromFile(document, copiedTiffFile);    assertTrue(copiedTiffFile.delete());}
public void pdfbox_f8222_0() throws IOException
{        String tiffG3Path = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg3.tif";    File copiedTiffFile = new File(testResultsDir, "ccittg3n.tif");    Files.copy(new File(tiffG3Path).toPath(), copiedTiffFile.toPath(), StandardCopyOption.REPLACE_EXISTING);    PDDocument document = new PDDocument();    CCITTFactory.createFromFile(document, copiedTiffFile, 0);    assertTrue(copiedTiffFile.delete());}
public void pdfbox_f8223_0() throws IOException
{    try (PDDocument document = new PDDocument()) {        String basePath = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg3-garbage-padded-fields";        for (String ext : Arrays.asList(".tif", "-bigendian.tif")) {            String tiffPath = basePath + ext;            PDImageXObject ximage3 = CCITTFactory.createFromFile(document, new File(tiffPath));            validate(ximage3, 1, 344, 287, "tiff", PDDeviceGray.INSTANCE.getName());        }    }}
protected void pdfbox_f8224_0() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
public void pdfbox_f8225_0() throws IOException
{    PDDocument document = new PDDocument();    InputStream stream = JPEGFactoryTest.class.getResourceAsStream("jpeg.jpg");    PDImageXObject ximage = JPEGFactory.createFromStream(document, stream);    validate(ximage, 8, 344, 287, "jpg", PDDeviceRGB.INSTANCE.getName());    doWritePDF(document, ximage, testResultsDir, "jpegrgbstream.pdf");    checkJpegStream(testResultsDir, "jpegrgbstream.pdf", JPEGFactoryTest.class.getResourceAsStream("jpeg.jpg"));}
public void pdfbox_f8226_0() throws IOException
{    PDDocument document = new PDDocument();    InputStream stream = JPEGFactoryTest.class.getResourceAsStream("jpegcmyk.jpg");    PDImageXObject ximage = JPEGFactory.createFromStream(document, stream);    validate(ximage, 8, 343, 287, "jpg", PDDeviceCMYK.INSTANCE.getName());    doWritePDF(document, ximage, testResultsDir, "jpegcmykstream.pdf");    checkJpegStream(testResultsDir, "jpegcmykstream.pdf", JPEGFactoryTest.class.getResourceAsStream("jpegcmyk.jpg"));}
public void pdfbox_f8227_0() throws IOException
{    PDDocument document = new PDDocument();    InputStream stream = JPEGFactoryTest.class.getResourceAsStream("jpeg256.jpg");    PDImageXObject ximage = JPEGFactory.createFromStream(document, stream);    validate(ximage, 8, 344, 287, "jpg", PDDeviceGray.INSTANCE.getName());    doWritePDF(document, ximage, testResultsDir, "jpeg256stream.pdf");    checkJpegStream(testResultsDir, "jpeg256stream.pdf", JPEGFactoryTest.class.getResourceAsStream("jpeg256.jpg"));}
public void pdfbox_f8228_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(JPEGFactoryTest.class.getResourceAsStream("jpeg.jpg"));    assertEquals(3, image.getColorModel().getNumComponents());    PDImageXObject ximage = JPEGFactory.createFromImage(document, image);    validate(ximage, 8, 344, 287, "jpg", PDDeviceRGB.INSTANCE.getName());    doWritePDF(document, ximage, testResultsDir, "jpegrgb.pdf");}
public void pdfbox_f8229_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(JPEGFactoryTest.class.getResourceAsStream("jpeg256.jpg"));    assertEquals(1, image.getColorModel().getNumComponents());    PDImageXObject ximage = JPEGFactory.createFromImage(document, image);    validate(ximage, 8, 344, 287, "jpg", PDDeviceGray.INSTANCE.getName());    doWritePDF(document, ximage, testResultsDir, "jpeg256.pdf");}
public void pdfbox_f8230_0() throws IOException
{        if (System.getProperty("java.runtime.name").equals("OpenJDK Runtime Environment") && (System.getProperty("java.specification.version").equals("1.6") || System.getProperty("java.specification.version").equals("1.7") || System.getProperty("java.specification.version").equals("1.8"))) {        return;    }    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(JPEGFactoryTest.class.getResourceAsStream("jpeg.jpg"));        int width = image.getWidth();    int height = image.getHeight();    BufferedImage argbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);    Graphics ag = argbImage.getGraphics();    ag.drawImage(image, 0, 0, null);    ag.dispose();    for (int x = 0; x < argbImage.getWidth(); ++x) {        for (int y = 0; y < argbImage.getHeight(); ++y) {            argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | ((y / 10 * 10) << 24));        }    }    PDImageXObject ximage = JPEGFactory.createFromImage(document, argbImage);    validate(ximage, 8, width, height, "jpg", PDDeviceRGB.INSTANCE.getName());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 8, width, height, "jpg", PDDeviceGray.INSTANCE.getName());    assertTrue(colorCount(ximage.getSoftMask().getImage()) > image.getHeight() / 10);    doWritePDF(document, ximage, testResultsDir, "jpeg-intargb.pdf");}
public void pdfbox_f8231_0() throws IOException
{        if (System.getProperty("java.runtime.name").equals("OpenJDK Runtime Environment") && (System.getProperty("java.specification.version").equals("1.6") || System.getProperty("java.specification.version").equals("1.7") || System.getProperty("java.specification.version").equals("1.8"))) {        return;    }    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(JPEGFactoryTest.class.getResourceAsStream("jpeg.jpg"));        int width = image.getWidth();    int height = image.getHeight();    BufferedImage argbImage = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);    Graphics ag = argbImage.getGraphics();    ag.drawImage(image, 0, 0, null);    ag.dispose();    for (int x = 0; x < argbImage.getWidth(); ++x) {        for (int y = 0; y < argbImage.getHeight(); ++y) {            argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | ((y / 10 * 10) << 24));        }    }    PDImageXObject ximage = JPEGFactory.createFromImage(document, argbImage);    validate(ximage, 8, width, height, "jpg", PDDeviceRGB.INSTANCE.getName());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 8, width, height, "jpg", PDDeviceGray.INSTANCE.getName());    assertTrue(colorCount(ximage.getSoftMask().getImage()) > image.getHeight() / 10);    doWritePDF(document, ximage, testResultsDir, "jpeg-4bargb.pdf");}
private void pdfbox_f8232_0(File testResultsDir, String filename, InputStream resourceStream) throws IOException
{    PDDocument doc = PDDocument.load(new File(testResultsDir, filename));    PDImageXObject img = (PDImageXObject) doc.getPage(0).getResources().getXObject(COSName.getPDFName("Im1"));    InputStream dctStream = img.createInputStream(Arrays.asList(COSName.DCT_DECODE.getName()));    ByteArrayOutputStream baos1 = new ByteArrayOutputStream();    ByteArrayOutputStream baos2 = new ByteArrayOutputStream();    IOUtils.copy(resourceStream, baos1);    IOUtils.copy(dctStream, baos2);    resourceStream.close();    dctStream.close();    assertArrayEquals(baos1.toByteArray(), baos2.toByteArray());    doc.close();}
protected void pdfbox_f8233_0() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
public void pdfbox_f8234_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));    PDImageXObject ximage1 = LosslessFactory.createFromImage(document, image);    validate(ximage1, 8, image.getWidth(), image.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage1.getImage());        BufferedImage grayImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_GRAY);    Graphics g = grayImage.getGraphics();    g.drawImage(image, 0, 0, null);    g.dispose();    PDImageXObject ximage2 = LosslessFactory.createFromImage(document, grayImage);    validate(ximage2, 8, grayImage.getWidth(), grayImage.getHeight(), "png", PDDeviceGray.INSTANCE.getName());    checkIdent(grayImage, ximage2.getImage());        BufferedImage bitonalImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_BINARY);        assertFalse(bitonalImage.getWidth() % 8 == 0);    g = bitonalImage.getGraphics();    g.drawImage(image, 0, 0, null);    g.dispose();    PDImageXObject ximage3 = LosslessFactory.createFromImage(document, bitonalImage);    validate(ximage3, 1, bitonalImage.getWidth(), bitonalImage.getHeight(), "png", PDDeviceGray.INSTANCE.getName());    checkIdent(bitonalImage, ximage3.getImage());                PDPage page = new PDPage();    document.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(ximage1, 200, 300, ximage1.getWidth() / 2, ximage1.getHeight() / 2);    contentStream.drawImage(ximage2, 200, 450, ximage2.getWidth() / 2, ximage2.getHeight() / 2);    contentStream.drawImage(ximage3, 200, 600, ximage3.getWidth() / 2, ximage3.getHeight() / 2);    contentStream.close();    File pdfFile = new File(testResultsDir, "misc.pdf");    document.save(pdfFile);    document.close();    document = PDDocument.load(pdfFile, (String) null);    new PDFRenderer(document).renderImage(0);    document.close();}
public void pdfbox_f8235_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));        int w = image.getWidth();    int h = image.getHeight();    BufferedImage argbImage = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);    Graphics ag = argbImage.getGraphics();    ag.drawImage(image, 0, 0, null);    ag.dispose();    for (int x = 0; x < argbImage.getWidth(); ++x) {        for (int y = 0; y < argbImage.getHeight(); ++y) {            argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | ((y / 10 * 10) << 24));        }    }    PDImageXObject ximage = LosslessFactory.createFromImage(document, argbImage);    validate(ximage, 8, argbImage.getWidth(), argbImage.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(argbImage, ximage.getImage());    checkIdentRGB(argbImage, ximage.getOpaqueImage());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 8, argbImage.getWidth(), argbImage.getHeight(), "png", PDDeviceGray.INSTANCE.getName());    assertTrue(colorCount(ximage.getSoftMask().getImage()) > image.getHeight() / 10);    doWritePDF(document, ximage, testResultsDir, "intargb.pdf");}
public void pdfbox_f8236_0() throws IOException
{    doBitmaskTransparencyTest(BufferedImage.TYPE_INT_ARGB, "bitmaskintargb.pdf");}
public void pdfbox_f8237_0() throws IOException
{    doBitmaskTransparencyTest(BufferedImage.TYPE_4BYTE_ABGR, "bitmask4babgr.pdf");}
public void pdfbox_f8238_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));        int w = image.getWidth();    int h = image.getHeight();    BufferedImage argbImage = new BufferedImage(w, h, BufferedImage.TYPE_4BYTE_ABGR);    Graphics ag = argbImage.getGraphics();    ag.drawImage(image, 0, 0, null);    ag.dispose();    for (int x = 0; x < argbImage.getWidth(); ++x) {        for (int y = 0; y < argbImage.getHeight(); ++y) {            argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | ((y / 10 * 10) << 24));        }    }                        argbImage = argbImage.getSubimage(1, 1, argbImage.getWidth() - 2, argbImage.getHeight() - 2);    w -= 2;    h -= 2;    PDImageXObject ximage = LosslessFactory.createFromImage(document, argbImage);    validate(ximage, 8, w, h, "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(argbImage, ximage.getImage());    checkIdentRGB(argbImage, ximage.getOpaqueImage());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 8, w, h, "png", PDDeviceGray.INSTANCE.getName());    assertTrue(colorCount(ximage.getSoftMask().getImage()) > image.getHeight() / 10);    doWritePDF(document, ximage, testResultsDir, "4babgr.pdf");}
public void pdfbox_f8239_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("gif.gif"));    assertEquals(Transparency.BITMASK, image.getColorModel().getTransparency());    PDImageXObject ximage = LosslessFactory.createFromImage(document, image);    int w = image.getWidth();    int h = image.getHeight();    validate(ximage, 8, w, h, "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());    checkIdentRGB(image, ximage.getOpaqueImage());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 1, w, h, "png", PDDeviceGray.INSTANCE.getName());    assertEquals(2, colorCount(ximage.getSoftMask().getImage()));    doWritePDF(document, ximage, testResultsDir, "gif.pdf");}
public void pdfbox_f8240_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(new File("target/imgs", "PDFBOX-4184-032163.jpg"));    PDImageXObject ximage = LosslessFactory.createFromImage(document, image);    validate(ximage, 8, image.getWidth(), image.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());    doWritePDF(document, ximage, testResultsDir, "PDFBOX-4184-032163.pdf");}
private void pdfbox_f8241_0(BufferedImage expectedImage, BufferedImage actualImage)
{    String errMsg = "";    int w = expectedImage.getWidth();    int h = expectedImage.getHeight();    assertEquals(w, actualImage.getWidth());    assertEquals(h, actualImage.getHeight());    for (int y = 0; y < h; ++y) {        for (int x = 0; x < w; ++x) {            if ((expectedImage.getRGB(x, y) & 0xFFFFFF) != (actualImage.getRGB(x, y) & 0xFFFFFF)) {                errMsg = String.format("(%d,%d) %06X != %06X", x, y, expectedImage.getRGB(x, y) & 0xFFFFFF, actualImage.getRGB(x, y) & 0xFFFFFF);            }            assertEquals(errMsg, expectedImage.getRGB(x, y) & 0xFFFFFF, actualImage.getRGB(x, y) & 0xFFFFFF);        }    }}
private void pdfbox_f8242_0(int imageType, String pdfFilename) throws IOException
{    PDDocument document = new PDDocument();    int width = 257;    int height = 256;        BufferedImage argbImage = new BufferedImage(width, height, imageType);        Graphics2D g = argbImage.createGraphics();    GraphicsConfiguration gc = g.getDeviceConfiguration();    argbImage = gc.createCompatibleImage(width, height, Transparency.BITMASK);    g.dispose();        g = argbImage.createGraphics();    g.setColor(Color.red);    g.fillRect(0, 0, width, height);    g.dispose();    Random random = new Random();    random.setSeed(12345);            int startX = width / 2 - width / 8;    int endX = width / 2 + width / 8;    int startY = height / 2 - height / 8;    int endY = height / 2 + height / 8;    for (int x = 0; x < width; ++x) {        for (int y = 0; y < height; ++y) {                                    int alpha;            if ((x >= startX && x <= endX) || y >= startY && y <= endY) {                alpha = 128 + (int) (random.nextFloat() * 127);                assertTrue(alpha >= 128);                argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | (alpha << 24));                assertEquals(255, argbImage.getRGB(x, y) >>> 24);            } else {                alpha = (int) (random.nextFloat() * 127);                assertTrue(alpha < 128);                argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | (alpha << 24));                assertEquals(0, argbImage.getRGB(x, y) >>> 24);            }        }    }    PDImageXObject ximage = LosslessFactory.createFromImage(document, argbImage);    validate(ximage, 8, width, height, "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(argbImage, ximage.getImage());    checkIdentRGB(argbImage, ximage.getOpaqueImage());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 1, width, height, "png", PDDeviceGray.INSTANCE.getName());    assertEquals(2, colorCount(ximage.getSoftMask().getImage()));        BufferedImage maskImage = ximage.getSoftMask().getImage();        assertFalse(maskImage.getWidth() % 8 == 0);    assertEquals(Transparency.OPAQUE, maskImage.getTransparency());    for (int x = 0; x < width; ++x) {        for (int y = 0; y < height; ++y) {            if ((x >= startX && x <= endX) || y >= startY && y <= endY) {                assertEquals(0xFFFFFF, maskImage.getRGB(x, y) & 0xFFFFFF);            } else {                assertEquals(0, maskImage.getRGB(x, y) & 0xFFFFFF);            }        }    }                    BufferedImage rectImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);    g = rectImage.createGraphics();    g.setColor(Color.blue);    g.fillRect(0, 0, width, height);    g.dispose();    PDImageXObject ximage2 = LosslessFactory.createFromImage(document, rectImage);    PDPage page = new PDPage();    document.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(ximage2, 150, 300, ximage2.getWidth(), ximage2.getHeight());    contentStream.drawImage(ximage, 150, 300, ximage.getWidth(), ximage.getHeight());    contentStream.close();    File pdfFile = new File(testResultsDir, pdfFilename);    document.save(pdfFile);    document.close();    document = PDDocument.load(pdfFile, (String) null);    new PDFRenderer(document).renderImage(0);    document.close();}
public void pdfbox_f8243_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));    final ColorSpace targetCS = new ICC_ColorSpace(ICC_Profile.getInstance(this.getClass().getResourceAsStream("/org/apache/pdfbox/resources/icc/ISOcoated_v2_300_bas.icc")));    ColorConvertOp op = new ColorConvertOp(image.getColorModel().getColorSpace(), targetCS, null);    BufferedImage imageCMYK = op.filter(image, null);    PDImageXObject ximage = LosslessFactory.createFromImage(document, imageCMYK);    validate(ximage, 8, imageCMYK.getWidth(), imageCMYK.getHeight(), "png", "ICCBased");    doWritePDF(document, ximage, testResultsDir, "cmyk.pdf");}
public void pdfbox_f8244_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));    ColorSpace targetCS = ColorSpace.getInstance(ColorSpace.CS_sRGB);    int dataBufferType = DataBuffer.TYPE_USHORT;    final ColorModel colorModel = new ComponentColorModel(targetCS, false, false, ColorModel.OPAQUE, dataBufferType);    WritableRaster targetRaster = Raster.createInterleavedRaster(dataBufferType, image.getWidth(), image.getHeight(), targetCS.getNumComponents(), new Point(0, 0));    BufferedImage img16Bit = new BufferedImage(colorModel, targetRaster, false, new Hashtable());    ColorConvertOp op = new ColorConvertOp(image.getColorModel().getColorSpace(), targetCS, null);    op.filter(image, img16Bit);    PDImageXObject ximage = LosslessFactory.createFromImage(document, img16Bit);    validate(ximage, 16, img16Bit.getWidth(), img16Bit.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());    doWritePDF(document, ximage, testResultsDir, "misc-16bit.pdf");}
public void pdfbox_f8245_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));    BufferedImage imgBgr = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_BGR);    Graphics2D graphics = imgBgr.createGraphics();    graphics.drawImage(image, 0, 0, null);    PDImageXObject ximage = LosslessFactory.createFromImage(document, imgBgr);    validate(ximage, 8, imgBgr.getWidth(), imgBgr.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());}
public void pdfbox_f8246_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));    BufferedImage imgRgb = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_RGB);    Graphics2D graphics = imgRgb.createGraphics();    graphics.drawImage(image, 0, 0, null);    PDImageXObject ximage = LosslessFactory.createFromImage(document, imgRgb);    validate(ximage, 8, imgRgb.getWidth(), imgRgb.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());}
public void pdfbox_f8247_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));    BufferedImage imgRgb = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_3BYTE_BGR);    Graphics2D graphics = imgRgb.createGraphics();    graphics.drawImage(image, 0, 0, null);    PDImageXObject ximage = LosslessFactory.createFromImage(document, imgRgb);    validate(ximage, 8, imgRgb.getWidth(), imgRgb.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());}
public void pdfbox_f8248_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(new File("target/imgs", "PDFBOX-4184-16bit.png"));    assertEquals(64, image.getColorModel().getPixelSize());    assertEquals(Transparency.TRANSLUCENT, image.getColorModel().getTransparency());    assertEquals(4, image.getRaster().getNumDataElements());    assertEquals(java.awt.image.DataBuffer.TYPE_USHORT, image.getRaster().getDataBuffer().getDataType());    PDImageXObject ximage = LosslessFactory.createFromImage(document, image);    int w = image.getWidth();    int h = image.getHeight();    validate(ximage, 16, w, h, "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());    checkIdentRGB(image, ximage.getOpaqueImage());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 16, w, h, "png", PDDeviceGray.INSTANCE.getName());    assertEquals(35, colorCount(ximage.getSoftMask().getImage()));    doWritePDF(document, ximage, testResultsDir, "png16bit.pdf");}
protected void pdfbox_f8249_0() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
public void pdfbox_f8250_0() throws IOException
{    COSDictionary dict = new COSDictionary();    dict.setBoolean(COSName.IM, true);    int width = 31;    int height = 27;    dict.setInt(COSName.W, width);    dict.setInt(COSName.H, height);    dict.setInt(COSName.BPC, 1);    int rowbytes = width / 8;    if (rowbytes * 8 < width) {                                ++rowbytes;    }        int datalen = rowbytes * height;    byte[] data = new byte[datalen];    for (int i = 0; i < datalen; ++i) {        data[i] = (i / 4 % 2 == 0) ? (byte) Integer.parseInt("10101010", 2) : 0;    }    PDInlineImage inlineImage1 = new PDInlineImage(dict, data, null);    assertTrue(inlineImage1.isStencil());    assertEquals(width, inlineImage1.getWidth());    assertEquals(height, inlineImage1.getHeight());    assertEquals(1, inlineImage1.getBitsPerComponent());    COSDictionary dict2 = new COSDictionary();    dict2.addAll(dict);        COSArray decodeArray = new COSArray();    decodeArray.add(COSInteger.ONE);    decodeArray.add(COSInteger.ZERO);    dict2.setItem(COSName.DECODE, decodeArray);    PDInlineImage inlineImage2 = new PDInlineImage(dict2, data, null);    Paint paint = new Color(0, 0, 0);    BufferedImage stencilImage = inlineImage1.getStencilImage(paint);    assertEquals(width, stencilImage.getWidth());    assertEquals(height, stencilImage.getHeight());    BufferedImage stencilImage2 = inlineImage2.getStencilImage(paint);    assertEquals(width, stencilImage2.getWidth());    assertEquals(height, stencilImage2.getHeight());    BufferedImage image1 = inlineImage1.getImage();    assertEquals(width, image1.getWidth());    assertEquals(height, image1.getHeight());    BufferedImage image2 = inlineImage2.getImage();    assertEquals(width, image2.getWidth());    assertEquals(height, image2.getHeight());        boolean writeOk = ImageIO.write(image1, "png", new FileOutputStream(new File(testResultsDir + "/inline-grid1.png")));    assertTrue(writeOk);    BufferedImage bim1 = ImageIO.read(new File(testResultsDir + "/inline-grid1.png"));    assertNotNull(bim1);    assertEquals(width, bim1.getWidth());    assertEquals(height, bim1.getHeight());    writeOk = ImageIO.write(image2, "png", new FileOutputStream(new File(testResultsDir + "/inline-grid2.png")));    assertTrue(writeOk);    BufferedImage bim2 = ImageIO.read(new File(testResultsDir + "/inline-grid2.png"));    assertNotNull(bim2);    assertEquals(width, bim2.getWidth());    assertEquals(height, bim2.getHeight());        for (int x = 0; x < width; ++x) {        for (int y = 0; y < height; ++y) {            if (x % 2 == 0 && y % 2 == 0) {                assertEquals(0xFFFFFF, bim1.getRGB(x, y) & 0xFFFFFF);            } else {                assertEquals(0, bim1.getRGB(x, y) & 0xFFFFFF);            }        }    }        for (int x = 0; x < width; ++x) {        for (int y = 0; y < height; ++y) {            if (x % 2 == 0 && y % 2 == 0) {                assertEquals(0, bim2.getRGB(x, y) & 0xFFFFFF);            } else {                assertEquals(0xFFFFFF, bim2.getRGB(x, y) & 0xFFFFFF);            }        }    }    PDDocument document = new PDDocument();    PDPage page = new PDPage();    document.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(inlineImage1, 150, 400);    contentStream.drawImage(inlineImage1, 150, 500, inlineImage1.getWidth() * 2, inlineImage1.getHeight() * 2);    contentStream.drawImage(inlineImage1, 150, 600, inlineImage1.getWidth() * 4, inlineImage1.getHeight() * 4);    contentStream.drawImage(inlineImage2, 350, 400);    contentStream.drawImage(inlineImage2, 350, 500, inlineImage2.getWidth() * 2, inlineImage2.getHeight() * 2);    contentStream.drawImage(inlineImage2, 350, 600, inlineImage2.getWidth() * 4, inlineImage2.getHeight() * 4);    contentStream.close();    File pdfFile = new File(testResultsDir, "inline.pdf");    document.save(pdfFile);    document.close();    document = PDDocument.load(pdfFile);    new PDFRenderer(document).renderImage(0);    document.close();}
public void pdfbox_f8251_0()
{        parentDir.mkdirs();}
public void pdfbox_f8252_0() throws IOException
{    checkImageConvert("png.png");}
public void pdfbox_f8253_0() throws IOException
{    checkImageConvert("png_rgb_gamma.png");}
public void pdfbox_f8254_0() throws IOException
{    checkImageConvert("png_rgb_romm_16bit.png");}
public void pdfbox_f8255_0() throws IOException
{    checkImageConvert("png_indexed.png");}
public void pdfbox_f8256_0() throws IOException
{    checkImageConvert("png_indexed_1bit_alpha.png");}
public void pdfbox_f8257_0() throws IOException
{    checkImageConvert("png_indexed_2bit_alpha.png");}
public void pdfbox_f8258_0() throws IOException
{    checkImageConvert("png_indexed_4bit_alpha.png");}
public void pdfbox_f8259_0() throws IOException
{    checkImageConvert("png_indexed_8bit_alpha.png");}
public void pdfbox_f8260_0() throws IOException
{        checkImageConvertFail("png_alpha_rgb.png");}
public void pdfbox_f8261_0() throws IOException
{        checkImageConvertFail("png_alpha_gray.png");}
public void pdfbox_f8262_0() throws IOException
{    checkImageConvertFail("png_gray.png");}
public void pdfbox_f8263_0() throws IOException
{    checkImageConvertFail("png_gray_with_gama.png");}
private void pdfbox_f8264_0(String name) throws IOException
{    PDDocument doc = new PDDocument();    byte[] imageBytes = IOUtils.toByteArray(PNGConverterTest.class.getResourceAsStream(name));    PDImageXObject pdImageXObject = PNGConverter.convertPNGImage(doc, imageBytes);    assertNull(pdImageXObject);    doc.close();}
private void pdfbox_f8265_0(String name) throws IOException
{    PDDocument doc = new PDDocument();    byte[] imageBytes = IOUtils.toByteArray(PNGConverterTest.class.getResourceAsStream(name));    PDImageXObject pdImageXObject = PNGConverter.convertPNGImage(doc, imageBytes);    assertNotNull(pdImageXObject);    PDPage page = new PDPage();    doc.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(doc, page);    contentStream.setNonStrokingColor(Color.PINK);    contentStream.addRect(0, 0, page.getCropBox().getWidth(), page.getCropBox().getHeight());    contentStream.fill();    contentStream.drawImage(pdImageXObject, 0, 0, pdImageXObject.getWidth(), pdImageXObject.getHeight());    contentStream.close();    doc.save(new File(parentDir, name + ".pdf"));    BufferedImage image = pdImageXObject.getImage();    checkIdent(ImageIO.read(new ByteArrayInputStream(imageBytes)), image);    doc.close();}
public void pdfbox_f8266_0()
{    assertFalse(PNGConverter.checkConverterState(null));    PNGConverter.PNGConverterState state = new PNGConverter.PNGConverterState();    assertFalse(PNGConverter.checkConverterState(state));    PNGConverter.Chunk invalidChunk = new PNGConverter.Chunk();    invalidChunk.bytes = new byte[0];    assertFalse(PNGConverter.checkChunkSane(invalidChunk));        PNGConverter.Chunk validChunk = new PNGConverter.Chunk();    validChunk.bytes = new byte[16];    validChunk.start = 4;    validChunk.length = 8;    validChunk.crc = 2077607535;    assertTrue(PNGConverter.checkChunkSane(validChunk));    state.IHDR = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.IDATs = Collections.singletonList(validChunk);    assertFalse(PNGConverter.checkConverterState(state));    state.IHDR = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.IDATs = new ArrayList<PNGConverter.Chunk>();    assertFalse(PNGConverter.checkConverterState(state));    state.IDATs = Collections.singletonList(validChunk);    assertTrue(PNGConverter.checkConverterState(state));    state.PLTE = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.PLTE = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.cHRM = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.cHRM = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.tRNS = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.tRNS = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.iCCP = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.iCCP = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.sRGB = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.sRGB = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.gAMA = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.gAMA = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.IDATs = Arrays.asList(validChunk, invalidChunk);    assertFalse(PNGConverter.checkConverterState(state));}
public void pdfbox_f8267_0()
{    PNGConverter.Chunk chunk = new PNGConverter.Chunk();    assertTrue(PNGConverter.checkChunkSane(null));    chunk.bytes = "IHDRsomedummyvaluesDummyValuesAtEnd".getBytes();    chunk.length = 19;    assertEquals(chunk.bytes.length, 35);    assertEquals("IHDRsomedummyvalues", new String(chunk.getData()));    assertFalse(PNGConverter.checkChunkSane(chunk));    chunk.start = 4;    assertEquals("somedummyvaluesDumm", new String(chunk.getData()));    assertFalse(PNGConverter.checkChunkSane(chunk));    chunk.crc = -1729802258;    assertTrue(PNGConverter.checkChunkSane(chunk));    chunk.start = 6;    assertFalse(PNGConverter.checkChunkSane(chunk));    chunk.length = 60;    assertFalse(PNGConverter.checkChunkSane(chunk));}
public void pdfbox_f8268_0()
{    byte[] b1 = "Hello World!".getBytes();    assertEquals(472456355, PNGConverter.crc(b1, 0, b1.length));    assertEquals(-632335482, PNGConverter.crc(b1, 2, b1.length - 4));}
public void pdfbox_f8269_0()
{    assertEquals(COSName.PERCEPTUAL, PNGConverter.mapPNGRenderIntent(0));    assertEquals(COSName.RELATIVE_COLORIMETRIC, PNGConverter.mapPNGRenderIntent(1));    assertEquals(COSName.SATURATION, PNGConverter.mapPNGRenderIntent(2));    assertEquals(COSName.ABSOLUTE_COLORIMETRIC, PNGConverter.mapPNGRenderIntent(3));    assertNull(PNGConverter.mapPNGRenderIntent(-1));    assertNull(PNGConverter.mapPNGRenderIntent(4));}
public static void pdfbox_f8270_0(PDImageXObject ximage, int bpc, int width, int height, String format, String colorSpaceName) throws IOException
{        assertNotNull(ximage);    COSStream cosStream = ximage.getCOSObject();    assertNotNull(cosStream);    assertEquals(COSName.XOBJECT, cosStream.getItem(COSName.TYPE));    assertEquals(COSName.IMAGE, cosStream.getItem(COSName.SUBTYPE));    assertTrue(ximage.getCOSObject().getLength() > 0);    assertEquals(bpc, ximage.getBitsPerComponent());    assertEquals(width, ximage.getWidth());    assertEquals(height, ximage.getHeight());    assertEquals(format, ximage.getSuffix());    assertEquals(colorSpaceName, ximage.getColorSpace().getName());        assertNotNull(ximage.getImage());    assertEquals(ximage.getWidth(), ximage.getImage().getWidth());    assertEquals(ximage.getHeight(), ximage.getImage().getHeight());    boolean canEncode = true;    boolean writeOk;        if ("jpg".equals(format) && ximage.getImage().getType() == BufferedImage.TYPE_INT_ARGB) {        ImageWriter writer = ImageIO.getImageWritersBySuffix(format).next();        ImageWriterSpi originatingProvider = writer.getOriginatingProvider();        canEncode = originatingProvider.canEncodeImage(ximage.getImage());    }    if (canEncode) {        writeOk = ImageIO.write(ximage.getImage(), format, new NullOutputStream());        assertTrue(writeOk);    }    writeOk = ImageIO.write(ximage.getOpaqueImage(), format, new NullOutputStream());    assertTrue(writeOk);}
 static int pdfbox_f8272_0(BufferedImage bim)
{    Set<Integer> colors = new HashSet<>();    int w = bim.getWidth();    int h = bim.getHeight();    for (int y = 0; y < h; y++) {        for (int x = 0; x < w; x++) {            colors.add(bim.getRGB(x, y));        }    }    return colors.size();}
 static void pdfbox_f8273_0(PDDocument document, PDImageXObject ximage, File testResultsDir, String filename) throws IOException
{    File pdfFile = new File(testResultsDir, filename);                PDPage page = new PDPage();    document.addPage(page);    try (PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false)) {        contentStream.drawImage(ximage, 150, 300);        contentStream.drawImage(ximage, 200, 350);    }        assertEquals(1, count(document.getPage(0).getResources().getXObjectNames()));    document.save(pdfFile);    document.close();    document = PDDocument.load(pdfFile);    assertEquals(1, count(document.getPage(0).getResources().getXObjectNames()));    new PDFRenderer(document).renderImage(0);    document.close();}
private static int pdfbox_f8274_0(Iterable<COSName> iterable)
{    int count = 0;    for (COSName name : iterable) {        count++;    }    return count;}
public static void pdfbox_f8275_0(BufferedImage expectedImage, BufferedImage actualImage)
{    String errMsg = "";    int w = expectedImage.getWidth();    int h = expectedImage.getHeight();    assertEquals(w, actualImage.getWidth());    assertEquals(h, actualImage.getHeight());    for (int y = 0; y < h; ++y) {        for (int x = 0; x < w; ++x) {            if (expectedImage.getRGB(x, y) != actualImage.getRGB(x, y)) {                errMsg = String.format("(%d,%d) expected: <%08X> but was: <%08X>; ", x, y, expectedImage.getRGB(x, y), actualImage.getRGB(x, y));            }            assertEquals(errMsg, expectedImage.getRGB(x, y), actualImage.getRGB(x, y));        }    }}
protected void pdfbox_f8276_0() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
public void pdfbox_f8277_0() throws Exception
{    PDDocument doc = new PDDocument();    try {                PDPage page = new PDPage();        doc.addPage(page);        PDResources resources = page.getResources();        if (resources == null) {            resources = new PDResources();            page.setResources(resources);        }                PDOptionalContentProperties ocprops = new PDOptionalContentProperties();        doc.getDocumentCatalog().setOCProperties(ocprops);                        PDOptionalContentGroup background = new PDOptionalContentGroup("background");        ocprops.addGroup(background);        assertTrue(ocprops.isGroupEnabled("background"));                PDOptionalContentGroup enabled = new PDOptionalContentGroup("enabled");        ocprops.addGroup(enabled);        assertFalse(ocprops.setGroupEnabled("enabled", true));        assertTrue(ocprops.isGroupEnabled("enabled"));                PDOptionalContentGroup disabled = new PDOptionalContentGroup("disabled");        ocprops.addGroup(disabled);        assertFalse(ocprops.setGroupEnabled("disabled", true));        assertTrue(ocprops.isGroupEnabled("disabled"));        assertTrue(ocprops.setGroupEnabled("disabled", false));        assertFalse(ocprops.isGroupEnabled("disabled"));                PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false);        PDFont font = PDType1Font.HELVETICA_BOLD;        contentStream.beginMarkedContent(COSName.OC, background);        contentStream.beginText();        contentStream.setFont(font, 14);        contentStream.newLineAtOffset(80, 700);        contentStream.showText("PDF 1.5: Optional Content Groups");        contentStream.endText();        font = PDType1Font.HELVETICA;        contentStream.beginText();        contentStream.setFont(font, 12);        contentStream.newLineAtOffset(80, 680);        contentStream.showText("You should see a green textline, but no red text line.");        contentStream.endText();        contentStream.endMarkedContent();                contentStream.beginMarkedContent(COSName.OC, enabled);        contentStream.setNonStrokingColor(Color.GREEN);        contentStream.beginText();        contentStream.setFont(font, 12);        contentStream.newLineAtOffset(80, 600);        contentStream.showText("This is from an enabled layer. If you see this, that's good.");        contentStream.endText();        contentStream.endMarkedContent();                contentStream.beginMarkedContent(COSName.OC, disabled);        contentStream.setNonStrokingColor(Color.RED);        contentStream.beginText();        contentStream.setFont(font, 12);        contentStream.newLineAtOffset(80, 500);        contentStream.showText("This is from a disabled layer. If you see this, that's NOT good!");        contentStream.endText();        contentStream.endMarkedContent();        contentStream.close();        File targetFile = new File(testResultsDir, "ocg-generation.pdf");        doc.save(targetFile.getAbsolutePath());    } finally {        doc.close();    }}
public void pdfbox_f8278_0() throws Exception
{    File pdfFile = new File(testResultsDir, "ocg-generation.pdf");    if (!pdfFile.exists()) {        testOCGGeneration();    }    PDDocument doc = PDDocument.load(pdfFile);    try {        assertEquals(1.5f, doc.getVersion());        PDDocumentCatalog catalog = doc.getDocumentCatalog();        PDPage page = doc.getPage(0);        PDResources resources = page.getResources();        COSName mc0 = COSName.getPDFName("oc1");        PDOptionalContentGroup ocg = (PDOptionalContentGroup) resources.getProperties(mc0);        assertNotNull(ocg);        assertEquals("background", ocg.getName());        assertNull(resources.getProperties(COSName.getPDFName("inexistent")));        PDOptionalContentProperties ocgs = catalog.getOCProperties();        assertEquals(BaseState.ON, ocgs.getBaseState());        Set<String> names = new java.util.HashSet<>(Arrays.asList(ocgs.getGroupNames()));        assertEquals(3, names.size());        assertTrue(names.contains("background"));        assertTrue(ocgs.isGroupEnabled("background"));        assertTrue(ocgs.isGroupEnabled("enabled"));        assertFalse(ocgs.isGroupEnabled("disabled"));        ocgs.setGroupEnabled("background", false);        assertFalse(ocgs.isGroupEnabled("background"));        PDOptionalContentGroup background = ocgs.getGroup("background");        assertEquals(ocg.getName(), background.getName());        assertNull(ocgs.getGroup("inexistent"));        Collection<PDOptionalContentGroup> coll = ocgs.getOptionalContentGroups();        assertEquals(3, coll.size());        Set<String> nameSet = new HashSet<>();        for (PDOptionalContentGroup ocg2 : coll) {            nameSet.add(ocg2.getName());        }        assertTrue(nameSet.contains("background"));        assertTrue(nameSet.contains("enabled"));        assertTrue(nameSet.contains("disabled"));    } finally {        doc.close();    }}
public void pdfbox_f8279_0() throws Exception
{    try (PDDocument doc = new PDDocument()) {                PDPage page = new PDPage();        doc.addPage(page);        PDResources resources = page.getResources();        if (resources == null) {            resources = new PDResources();            page.setResources(resources);        }                PDOptionalContentProperties ocprops = new PDOptionalContentProperties();        doc.getDocumentCatalog().setOCProperties(ocprops);                        PDOptionalContentGroup visible = new PDOptionalContentGroup("layer");        ocprops.addGroup(visible);        assertTrue(ocprops.isGroupEnabled(visible));                PDOptionalContentGroup invisible = new PDOptionalContentGroup("layer");        ocprops.addGroup(invisible);        assertFalse(ocprops.setGroupEnabled(invisible, false));        assertFalse(ocprops.isGroupEnabled(invisible));                assertTrue(ocprops.isGroupEnabled(visible));                try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false)) {            PDFont font = PDType1Font.HELVETICA_BOLD;            contentStream.beginMarkedContent(COSName.OC, visible);            contentStream.beginText();            contentStream.setFont(font, 14);            contentStream.newLineAtOffset(80, 700);            contentStream.showText("PDF 1.5: Optional Content Groups");            contentStream.endText();            font = PDType1Font.HELVETICA;            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 680);            contentStream.showText("You should see this text, but no red text line.");            contentStream.endText();            contentStream.endMarkedContent();                        contentStream.beginMarkedContent(COSName.OC, invisible);            contentStream.setNonStrokingColor(Color.RED);            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 500);            contentStream.showText("This is from a disabled layer. If you see this, that's NOT good!");            contentStream.endText();            contentStream.endMarkedContent();        }        File targetFile = new File(testResultsDir, "ocg-generation-same-name.pdf");        doc.save(targetFile.getAbsolutePath());    }}
public void pdfbox_f8280_0() throws IOException
{    BufferedImage expectedImage;    BufferedImage actualImage;    try (PDDocument doc = new PDDocument()) {                PDPage page = new PDPage();        doc.addPage(page);        PDResources resources = page.getResources();        if (resources == null) {            resources = new PDResources();            page.setResources(resources);        }                PDOptionalContentProperties ocprops = new PDOptionalContentProperties();        doc.getDocumentCatalog().setOCProperties(ocprops);                        PDOptionalContentGroup background = new PDOptionalContentGroup("background");        ocprops.addGroup(background);        assertTrue(ocprops.isGroupEnabled("background"));                PDOptionalContentGroup enabled = new PDOptionalContentGroup("science");        ocprops.addGroup(enabled);        assertFalse(ocprops.setGroupEnabled("science", true));        assertTrue(ocprops.isGroupEnabled("science"));                PDOptionalContentGroup disabled1 = new PDOptionalContentGroup("alternative");        ocprops.addGroup(disabled1);                PDOptionalContentGroup disabled2 = new PDOptionalContentGroup("alternative");        ocprops.addGroup(disabled2);        assertFalse(ocprops.setGroupEnabled("alternative", false));        assertFalse(ocprops.isGroupEnabled("alternative"));                try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false)) {            PDFont font = PDType1Font.HELVETICA_BOLD;            contentStream.beginMarkedContent(COSName.OC, background);            contentStream.beginText();            contentStream.setFont(font, 14);            contentStream.newLineAtOffset(80, 700);            contentStream.showText("PDF 1.5: Optional Content Groups");            contentStream.endText();            contentStream.endMarkedContent();            font = PDType1Font.HELVETICA;                        contentStream.beginMarkedContent(COSName.OC, enabled);            contentStream.setNonStrokingColor(Color.GREEN);            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 600);            contentStream.showText("The earth is a sphere");            contentStream.endText();            contentStream.endMarkedContent();                        contentStream.beginMarkedContent(COSName.OC, disabled1);            contentStream.setNonStrokingColor(Color.RED);            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 500);            contentStream.showText("Alternative 1: The earth is a flat circle");            contentStream.endText();            contentStream.endMarkedContent();                        contentStream.beginMarkedContent(COSName.OC, disabled2);            contentStream.setNonStrokingColor(Color.BLUE);            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 450);            contentStream.showText("Alternative 2: The earth is a flat parallelogram");            contentStream.endText();            contentStream.endMarkedContent();        }        doc.getDocumentCatalog().setPageMode(PageMode.USE_OPTIONAL_CONTENT);        File targetFile = new File(testResultsDir, "ocg-generation-same-name-off.pdf");        doc.save(targetFile.getAbsolutePath());    }        try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDResources resources = page.getResources();        if (resources == null) {            resources = new PDResources();            page.setResources(resources);        }        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false)) {            PDFont font = PDType1Font.HELVETICA;            contentStream.setNonStrokingColor(Color.RED);            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 500);            contentStream.showText("Alternative 1: The earth is a flat circle");            contentStream.endText();            contentStream.setNonStrokingColor(Color.BLUE);            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 450);            contentStream.showText("Alternative 2: The earth is a flat parallelogram");            contentStream.endText();        }        expectedImage = new PDFRenderer(doc).renderImage(0, 2);        ImageIO.write(expectedImage, "png", new File(testResultsDir, "ocg-generation-same-name-off-expected.png"));    }        try (PDDocument doc = PDDocument.load(new File(testResultsDir, "ocg-generation-same-name-off.pdf"))) {        doc.getDocumentCatalog().getOCProperties().setGroupEnabled("background", false);        doc.getDocumentCatalog().getOCProperties().setGroupEnabled("science", false);        doc.getDocumentCatalog().getOCProperties().setGroupEnabled("alternative", true);        actualImage = new PDFRenderer(doc).renderImage(0, 2);        ImageIO.write(actualImage, "png", new File(testResultsDir, "ocg-generation-same-name-off-actual.png"));    }        DataBufferInt expectedData = (DataBufferInt) expectedImage.getRaster().getDataBuffer();    DataBufferInt actualData = (DataBufferInt) actualImage.getRaster().getDataBuffer();    Assert.assertArrayEquals(expectedData.getData(), actualData.getData());}
public void pdfbox_f8281_0()
{    COSArray ar = new COSArray();    ar.add(COSInteger.ONE);    ar.add(COSInteger.TWO);    PDLineDashPattern dash = new PDLineDashPattern(ar, 3);    COSArray dashBase = (COSArray) dash.getCOSObject();    COSArray dashArray = (COSArray) dashBase.getObject(0);    assertEquals(2, dashBase.size());    assertEquals(2, dashArray.size());    assertEquals(new COSFloat(1), dashArray.get(0));    assertEquals(new COSFloat(2), dashArray.get(1));    assertEquals(COSInteger.THREE, dashBase.get(1));    System.out.println(dash);}
public void pdfbox_f8282_0()
{        final String value = "AbsoluteColorimetric";        final RenderingIntent retval = RenderingIntent.fromString(value);        Assert.assertEquals(RenderingIntent.ABSOLUTE_COLORIMETRIC, retval);}
public void pdfbox_f8283_0()
{        final String value = "RelativeColorimetric";        final RenderingIntent retval = RenderingIntent.fromString(value);        Assert.assertEquals(RenderingIntent.RELATIVE_COLORIMETRIC, retval);}
public void pdfbox_f8284_0()
{        final String value = "Perceptual";        final RenderingIntent retval = RenderingIntent.fromString(value);        Assert.assertEquals(RenderingIntent.PERCEPTUAL, retval);}
public void pdfbox_f8285_0()
{        final String value = "Saturation";        final RenderingIntent retval = RenderingIntent.fromString(value);        Assert.assertEquals(RenderingIntent.SATURATION, retval);}
public void pdfbox_f8286_0()
{        final String value = "";        final RenderingIntent retval = RenderingIntent.fromString(value);        Assert.assertEquals(RenderingIntent.RELATIVE_COLORIMETRIC, retval);}
public void pdfbox_f8287_0()
{        final RenderingIntent objectUnderTest = RenderingIntent.ABSOLUTE_COLORIMETRIC;        final String retval = objectUnderTest.stringValue();        Assert.assertEquals("AbsoluteColorimetric", retval);}
public void pdfbox_f8288_0()
{    PDActionURI actionURI = new PDActionURI();    assertNull(actionURI.getURI());    actionURI.setURI("http://çµ„åŒ¶æ›¿ç¶Ž.com/");    assertEquals("http://経営承継.com/", actionURI.getURI());}
public void pdfbox_f8289_0() throws IOException
{    PDActionURI actionURI = new PDActionURI();        COSString utf16URI = COSString.parseHex("FEFF0068007400740070003A002F002F00770077" + "0077002E006E00610070002E006500640075002F0063006100740061006C006F006700" + "2F00310031003100340030002E00680074006D006C");    actionURI.getCOSObject().setItem(COSName.URI, utf16URI);    assertEquals("http://www.nap.edu/catalog/11140.html", actionURI.getURI());}
public void pdfbox_f8290_0() throws IOException
{    PDActionURI actionURI = new PDActionURI();    COSString utf16URI = COSString.parseHex("FFFE68007400740070003A00");    actionURI.getCOSObject().setItem(COSName.URI, utf16URI);    assertEquals("http:", actionURI.getURI());}
public void pdfbox_f8291_0()
{    PDActionURI actionURI = new PDActionURI();    actionURI.setURI("http://pdfbox.apache.org/");    assertEquals("http://pdfbox.apache.org/", actionURI.getURI());}
public void pdfbox_f8292_0() throws IOException
{    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    OUT_DIR.mkdirs();}
public void pdfbox_f8293_0() throws IOException
{    PDPage page = document.getPage(0);    PDAnnotation annotation = page.getAnnotations().get(0);        PDAppearanceStream appearanceContentStream = annotation.getNormalAppearanceStream();    PDFStreamParser streamParser = new PDFStreamParser(appearanceContentStream.getContents());    streamParser.parse();    List<Object> tokensForOriginal = streamParser.getTokens();        annotation.getCOSObject().removeItem(COSName.AP);    annotation.constructAppearances();    appearanceContentStream = annotation.getNormalAppearanceStream();    streamParser = new PDFStreamParser(appearanceContentStream.getContents());    streamParser.parse();    List<Object> tokensForPdfbox = streamParser.getTokens();    assertEquals("The number of tokens in the content stream should be the same", tokensForOriginal.size(), tokensForPdfbox.size());    int actualToken = 0;    for (Object tokenForOriginal : tokensForOriginal) {        Object tokenForPdfbox = tokensForPdfbox.get(actualToken);        assertEquals("The tokens should have the same type", tokenForOriginal.getClass().getName(), tokenForPdfbox.getClass().getName());        if (tokenForOriginal instanceof Operator) {            assertEquals("The operator generated by PDFBox should be the same Operator", ((Operator) tokenForOriginal).getName(), ((Operator) tokenForPdfbox).getName());        } else if (tokenForOriginal instanceof COSFloat) {            assertTrue("The difference between the numbers should be smaller than " + DELTA, (Math.abs(((COSFloat) tokenForOriginal).floatValue() - ((COSFloat) tokenForPdfbox).floatValue()) < DELTA));        }        actualToken++;    }        File file = new File(OUT_DIR, NAME_OF_PDF + "-newAP.pdf");    document.save(file);}
public void pdfbox_f8294_0() throws IOException
{    File file = new File(OUT_DIR, NAME_OF_PDF);    document.save(file);        TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(file, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.out.println("Rendering of " + file + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }}
public void pdfbox_f8295_0() throws IOException
{    document.close();}
public void pdfbox_f8296_0()
{    PDAnnotation annotation = new PDAnnotationWidget();    assertEquals(COSName.ANNOT, annotation.getCOSObject().getItem(COSName.TYPE));    assertEquals(PDAnnotationWidget.SUB_TYPE, annotation.getCOSObject().getNameAsString(COSName.SUBTYPE));}
public void pdfbox_f8297_0()
{    PDDocument document = new PDDocument();    PDAcroForm acroForm = new PDAcroForm(document);    PDTextField textField = new PDTextField(acroForm);    PDAnnotation annotation = textField.getWidgets().get(0);    assertEquals(COSName.ANNOT, annotation.getCOSObject().getItem(COSName.TYPE));    assertEquals(PDAnnotationWidget.SUB_TYPE, annotation.getCOSObject().getNameAsString(COSName.SUBTYPE));}
public void pdfbox_f8298_0()
{    PDAnnotation annotation = new PDAnnotationCircle();    assertEquals(COSName.ANNOT, annotation.getCOSObject().getItem(COSName.TYPE));    assertEquals(PDAnnotationCircle.SUB_TYPE, annotation.getCOSObject().getNameAsString(COSName.SUBTYPE));}
public void pdfbox_f8299_0() throws IOException
{    rectangle = new PDRectangle();    rectangle.setLowerLeftX(91.5958f);    rectangle.setLowerLeftY(741.91f);    rectangle.setUpperRightX(113.849f);    rectangle.setUpperRightY(757.078f);}
public void pdfbox_f8300_0()
{    PDAnnotation annotation = new PDAnnotationSquare();    assertEquals(COSName.ANNOT, annotation.getCOSObject().getItem(COSName.TYPE));    assertEquals(PDAnnotationSquare.SUB_TYPE, annotation.getCOSObject().getNameAsString(COSName.SUBTYPE));}
public void pdfbox_f8301_0() throws IOException
{        final int borderWidth = 1;    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage();        document.addPage(page);        List<PDAnnotation> annotations = page.getAnnotations();        PDAnnotationSquareCircle annotation = new PDAnnotationSquare();        PDBorderStyleDictionary borderThin = new PDBorderStyleDictionary();        borderThin.setWidth(borderWidth);        PDColor red = new PDColor(new float[] { 1, 0, 0 }, PDDeviceRGB.INSTANCE);        annotation.setContents("Square Annotation");        annotation.setColor(red);        annotation.setBorderStyle(borderThin);        annotation.setRectangle(rectangle);        annotation.constructAppearances();        annotations.add(annotation);    }}
public void pdfbox_f8302_0() throws IOException
{        final int borderWidth = 1;    File file = new File(IN_DIR, NAME_OF_PDF);    try (PDDocument document = PDDocument.load(file)) {        PDPage page = document.getPage(0);        List<PDAnnotation> annotations = page.getAnnotations();        PDAnnotationSquareCircle annotation = (PDAnnotationSquareCircle) annotations.get(0);                assertNotNull("Appearance dictionary shall not be null", annotation.getAppearance());        assertNotNull("Normal appearance shall not be null", annotation.getAppearance().getNormalAppearance());        PDAppearanceStream appearanceStream = annotation.getAppearance().getNormalAppearance().getAppearanceStream();        assertNotNull("Appearance stream shall not be null", appearanceStream);        assertEquals(rectangle.getLowerLeftX(), appearanceStream.getBBox().getLowerLeftX(), DELTA);        assertEquals(rectangle.getLowerLeftY(), appearanceStream.getBBox().getLowerLeftY(), DELTA);        assertEquals(rectangle.getWidth(), appearanceStream.getBBox().getWidth(), DELTA);        assertEquals(rectangle.getHeight(), appearanceStream.getBBox().getHeight(), DELTA);        Matrix matrix = appearanceStream.getMatrix();        assertNotNull("Matrix shall not be null", matrix);                assertEquals(-rectangle.getLowerLeftX(), matrix.getTranslateX(), DELTA);        assertEquals(-rectangle.getLowerLeftY(), matrix.getTranslateY(), DELTA);                PDStream contentStream = appearanceStream.getContentStream();        assertNotNull("Content stream shall not be null", contentStream);        PDFStreamParser parser = new PDFStreamParser(appearanceStream.getContents());        parser.parse();        List<Object> tokens = parser.getTokens();                assertEquals(10, tokens.size());                assertEquals(1, ((COSInteger) tokens.get(0)).intValue());        assertEquals(0, ((COSInteger) tokens.get(1)).intValue());        assertEquals(0, ((COSInteger) tokens.get(2)).intValue());        assertEquals("RG", ((Operator) tokens.get(3)).getName());                        assertEquals(rectangle.getLowerLeftX() + borderWidth, ((COSFloat) tokens.get(4)).floatValue(), DELTA);        assertEquals(rectangle.getLowerLeftY() + borderWidth, ((COSFloat) tokens.get(5)).floatValue(), DELTA);        assertEquals(rectangle.getWidth() - 2 * borderWidth, ((COSFloat) tokens.get(6)).floatValue(), DELTA);        assertEquals(rectangle.getHeight() - 2 * borderWidth, ((COSFloat) tokens.get(7)).floatValue(), DELTA);        assertEquals("re", ((Operator) tokens.get(8)).getName());        assertEquals("S", ((Operator) tokens.get(9)).getName());    }}
public void pdfbox_f8303_0()
{    PDDocumentOutline outline = new PDDocumentOutline();    PDOutlineItem firstLevelChild = new PDOutlineItem();    outline.addLast(firstLevelChild);    PDOutlineItem secondLevelChild = new PDOutlineItem();    firstLevelChild.addLast(secondLevelChild);    assertEquals(0, secondLevelChild.getOpenCount());    assertEquals(-1, firstLevelChild.getOpenCount());    assertFalse("Outlines count cannot be " + outline.getOpenCount(), outline.getOpenCount() < 0);}
public void pdfbox_f8304_0()
{    PDDocumentOutline outline = new PDDocumentOutline();    PDOutlineItem root = new PDOutlineItem();    outline.addLast(root);    assertEquals(1, outline.getOpenCount());    root.addLast(new PDOutlineItem());    assertEquals(-1, root.getOpenCount());    assertEquals(1, outline.getOpenCount());    root.addLast(new PDOutlineItem());    assertEquals(-2, root.getOpenCount());    assertEquals(1, outline.getOpenCount());    root.openNode();    assertEquals(2, root.getOpenCount());    assertEquals(3, outline.getOpenCount());}
public void pdfbox_f8305_0()
{    PDOutlineItem first = new PDOutlineItem();    PDOutlineItemIterator iterator = new PDOutlineItemIterator(first);    assertTrue(iterator.hasNext());    assertEquals(first, iterator.next());    assertFalse(iterator.hasNext());}
public void pdfbox_f8306_0()
{    PDOutlineItem first = new PDOutlineItem();    PDOutlineItem second = new PDOutlineItem();    first.setNextSibling(second);    PDOutlineItemIterator iterator = new PDOutlineItemIterator(first);    assertTrue(iterator.hasNext());    assertEquals(first, iterator.next());    assertTrue(iterator.hasNext());    assertEquals(second, iterator.next());    assertFalse(iterator.hasNext());}
public void pdfbox_f8307_0()
{    new PDOutlineItemIterator(new PDOutlineItem()).remove();}
public void pdfbox_f8308_0()
{    PDOutlineItemIterator iterator = new PDOutlineItemIterator(null);    assertFalse(iterator.hasNext());}
public void pdfbox_f8309_0()
{    root = new PDOutlineItem();    first = new PDOutlineItem();    second = new PDOutlineItem();    root.addLast(first);    root.addLast(second);    newSibling = new PDOutlineItem();    newSibling.addLast(new PDOutlineItem());    newSibling.addLast(new PDOutlineItem());}
public void pdfbox_f8310_0()
{    newSibling.openNode();    root.openNode();    assertEquals(2, root.getOpenCount());    first.insertSiblingAfter(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(5, root.getOpenCount());}
public void pdfbox_f8311_0()
{    newSibling.openNode();    root.openNode();    assertEquals(2, root.getOpenCount());    second.insertSiblingBefore(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(5, root.getOpenCount());}
public void pdfbox_f8312_0()
{    newSibling.openNode();    assertEquals(-2, root.getOpenCount());    first.insertSiblingAfter(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(-5, root.getOpenCount());}
public void pdfbox_f8313_0()
{    newSibling.openNode();    assertEquals(-2, root.getOpenCount());    second.insertSiblingBefore(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(-5, root.getOpenCount());}
public void pdfbox_f8314_0()
{    root.openNode();    assertEquals(2, root.getOpenCount());    first.insertSiblingAfter(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(3, root.getOpenCount());}
public void pdfbox_f8315_0()
{    root.openNode();    assertEquals(2, root.getOpenCount());    second.insertSiblingBefore(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(3, root.getOpenCount());}
public void pdfbox_f8316_0()
{    assertEquals(-2, root.getOpenCount());    first.insertSiblingAfter(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(-3, root.getOpenCount());}
public void pdfbox_f8317_0()
{    assertEquals(-2, root.getOpenCount());    second.insertSiblingBefore(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(-3, root.getOpenCount());}
public void pdfbox_f8318_0()
{    assertEquals(root.getFirstChild(), first);    PDOutlineItem newSibling = new PDOutlineItem();    first.insertSiblingBefore(newSibling);    assertEquals(first.getPreviousSibling(), newSibling);    assertEquals(root.getFirstChild(), newSibling);}
public void pdfbox_f8319_0()
{    assertEquals(root.getFirstChild(), first);    PDOutlineItem newSibling = new PDOutlineItem();    root.insertSiblingBefore(newSibling);    assertEquals(root.getPreviousSibling(), newSibling);}
public void pdfbox_f8320_0()
{    assertEquals(root.getLastChild(), second);    PDOutlineItem newSibling = new PDOutlineItem();    second.insertSiblingAfter(newSibling);    assertEquals(second.getNextSibling(), newSibling);    assertEquals(root.getLastChild(), newSibling);}
public void pdfbox_f8321_0()
{    assertEquals(root.getLastChild(), second);    PDOutlineItem newSibling = new PDOutlineItem();    root.insertSiblingAfter(newSibling);    assertEquals(root.getNextSibling(), newSibling);}
public void pdfbox_f8322_0()
{    PDOutlineItem child = new PDOutlineItem();    child.insertSiblingAfter(new PDOutlineItem());    child.insertSiblingAfter(new PDOutlineItem());    root.insertSiblingBefore(child);}
public void pdfbox_f8323_0()
{    PDOutlineItem child = new PDOutlineItem();    child.insertSiblingAfter(new PDOutlineItem());    child.insertSiblingAfter(new PDOutlineItem());    root.insertSiblingAfter(child);}
public void pdfbox_f8324_0()
{    root = new PDOutlineItem();}
public void pdfbox_f8325_0()
{    PDOutlineItem child = new PDOutlineItem();    root.addLast(child);    PDDocumentOutline outline = new PDDocumentOutline();    outline.addLast(root);    assertNull(outline.getParent());    assertEquals(outline, root.getParent());    assertEquals(root, child.getParent());}
public void pdfbox_f8326_0()
{    assertNull(root.getLastChild());}
public void pdfbox_f8327_0()
{    assertNull(root.getFirstChild());}
public void pdfbox_f8328_0()
{    PDOutlineItem child = new PDOutlineItem();    assertEquals(0, root.getOpenCount());    root.addLast(child);    root.openNode();    assertTrue(root.isNodeOpen());    assertEquals(1, root.getOpenCount());    root.openNode();    assertTrue(root.isNodeOpen());    assertEquals(1, root.getOpenCount());}
public void pdfbox_f8329_0()
{    PDOutlineItem child = new PDOutlineItem();    assertEquals(0, root.getOpenCount());    root.addLast(child);    root.openNode();    root.closeNode();    assertFalse(root.isNodeOpen());    assertEquals(-1, root.getOpenCount());    root.closeNode();    assertFalse(root.isNodeOpen());    assertEquals(-1, root.getOpenCount());}
public void pdfbox_f8330_0()
{    PDOutlineItem child = new PDOutlineItem();    root.addLast(child);    child.openNode();    assertFalse(child.isNodeOpen());}
public void pdfbox_f8331_0()
{    PDOutlineItem child = new PDOutlineItem();    root.addLast(child);    assertFalse(root.isNodeOpen());    assertEquals(-1, root.getOpenCount());}
public void pdfbox_f8332_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    child.openNode();    root.addLast(child);    root.openNode();    assertEquals(3, root.getOpenCount());    assertEquals(2, child.getOpenCount());    child.closeNode();    assertEquals(1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());}
public void pdfbox_f8333_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    child.openNode();    root.addLast(child);    assertEquals(-3, root.getOpenCount());    assertEquals(2, child.getOpenCount());    child.closeNode();    assertEquals(-1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());}
public void pdfbox_f8334_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    root.addLast(child);    root.openNode();    assertEquals(1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());    child.openNode();    assertEquals(3, root.getOpenCount());    assertEquals(2, child.getOpenCount());}
public void pdfbox_f8335_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    root.addLast(child);    assertEquals(-1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());    child.openNode();    assertEquals(-3, root.getOpenCount());    assertEquals(2, child.getOpenCount());}
public void pdfbox_f8336_0()
{    PDOutlineItem child = new PDOutlineItem();    root.addLast(child);    assertEquals(child, root.getFirstChild());    assertEquals(child, root.getLastChild());}
public void pdfbox_f8337_0()
{    PDOutlineItem child = new PDOutlineItem();    root.addFirst(child);    assertEquals(child, root.getFirstChild());    assertEquals(child, root.getLastChild());}
public void pdfbox_f8338_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    child.openNode();    root.addLast(new PDOutlineItem());    root.openNode();    assertEquals(1, root.getOpenCount());    assertEquals(2, child.getOpenCount());    root.addLast(child);    assertNotEquals(child, root.getFirstChild());    assertEquals(child, root.getLastChild());    assertEquals(4, root.getOpenCount());}
public void pdfbox_f8339_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addFirst(new PDOutlineItem());    child.addFirst(new PDOutlineItem());    child.openNode();    root.addFirst(new PDOutlineItem());    root.openNode();    assertEquals(1, root.getOpenCount());    assertEquals(2, child.getOpenCount());    root.addFirst(child);    assertNotEquals(child, root.getLastChild());    assertEquals(child, root.getFirstChild());    assertEquals(4, root.getOpenCount());}
public void pdfbox_f8340_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    child.openNode();    root.addLast(new PDOutlineItem());    assertEquals(-1, root.getOpenCount());    assertEquals(2, child.getOpenCount());    root.addLast(child);    assertNotEquals(child, root.getFirstChild());    assertEquals(child, root.getLastChild());    assertEquals(-4, root.getOpenCount());}
public void pdfbox_f8341_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addFirst(new PDOutlineItem());    child.addFirst(new PDOutlineItem());    child.openNode();    root.addFirst(new PDOutlineItem());    assertEquals(-1, root.getOpenCount());    assertEquals(2, child.getOpenCount());    root.addFirst(child);    assertNotEquals(child, root.getLastChild());    assertEquals(child, root.getFirstChild());    assertEquals(-4, root.getOpenCount());}
public void pdfbox_f8342_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    root.addLast(new PDOutlineItem());    root.openNode();    assertEquals(1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());    root.addLast(child);    assertNotEquals(child, root.getFirstChild());    assertEquals(child, root.getLastChild());    assertEquals(2, root.getOpenCount());}
public void pdfbox_f8343_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addFirst(new PDOutlineItem());    child.addFirst(new PDOutlineItem());    root.addFirst(new PDOutlineItem());    root.openNode();    assertEquals(1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());    root.addFirst(child);    assertNotEquals(child, root.getLastChild());    assertEquals(child, root.getFirstChild());    assertEquals(2, root.getOpenCount());}
public void pdfbox_f8344_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    root.addLast(new PDOutlineItem());    assertEquals(-1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());    root.addLast(child);    assertNotEquals(child, root.getFirstChild());    assertEquals(child, root.getLastChild());    assertEquals(-2, root.getOpenCount());}
public void pdfbox_f8345_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addFirst(new PDOutlineItem());    child.addFirst(new PDOutlineItem());    root.addFirst(new PDOutlineItem());    assertEquals(-1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());    root.addFirst(child);    assertNotEquals(child, root.getLastChild());    assertEquals(child, root.getFirstChild());    assertEquals(-2, root.getOpenCount());}
public void pdfbox_f8346_0()
{    PDOutlineItem child = new PDOutlineItem();    child.insertSiblingAfter(new PDOutlineItem());    child.insertSiblingAfter(new PDOutlineItem());    root.addLast(child);}
public void pdfbox_f8347_0()
{    PDOutlineItem child = new PDOutlineItem();    child.insertSiblingAfter(new PDOutlineItem());    child.insertSiblingAfter(new PDOutlineItem());    root.addFirst(child);}
public void pdfbox_f8348_0()
{    root.addFirst(new PDOutlineItem());    assertEquals(root.getFirstChild(), root.getLastChild());}
public void pdfbox_f8349_0()
{    PDOutlineItem first = new PDOutlineItem();    root.addFirst(first);    root.addLast(new PDOutlineItem());    PDOutlineItem second = new PDOutlineItem();    first.insertSiblingAfter(second);    int counter = 0;    for (PDOutlineItem current : root.children()) {        counter++;    }    assertEquals(3, counter);}
public void pdfbox_f8350_0()
{    int counter = 0;    for (PDOutlineItem current : new PDOutlineItem().children()) {        counter++;    }    assertEquals(0, counter);}
public void pdfbox_f8352_0() throws IOException
{    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    acroForm = document.getDocumentCatalog().getAcroForm();    OUT_DIR.mkdirs();}
public void pdfbox_f8353_0() throws IOException
{            PDField field = acroForm.getField("pdfbox.portrait.single.rotation0");    field.setValue(field.getFullyQualifiedName());    field = acroForm.getField("pdfbox.portrait.single.rotation90");    field.setValue(field.getFullyQualifiedName());    field = acroForm.getField("pdfbox.portrait.single.rotation180");    field.setValue(field.getFullyQualifiedName());    field = acroForm.getField("pdfbox.portrait.single.rotation270");    field.setValue(field.getFullyQualifiedName());        field = acroForm.getField("pdfbox.portrait.multi.rotation0");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);    field = acroForm.getField("pdfbox.portrait.multi.rotation90");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);    field = acroForm.getField("pdfbox.portrait.multi.rotation180");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);    field = acroForm.getField("pdfbox.portrait.multi.rotation270");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);            field = acroForm.getField("pdfbox.page90.single.rotation0");    field.setValue("pdfbox.page90.single.rotation0");    field = acroForm.getField("pdfbox.page90.single.rotation90");    field.setValue("pdfbox.page90.single.rotation90");    field = acroForm.getField("pdfbox.page90.single.rotation180");    field.setValue("pdfbox.page90.single.rotation180");    field = acroForm.getField("pdfbox.page90.single.rotation270");    field.setValue("pdfbox.page90.single.rotation270");        field = acroForm.getField("pdfbox.page90.multi.rotation0");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);    field = acroForm.getField("pdfbox.page90.multi.rotation90");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);    field = acroForm.getField("pdfbox.page90.multi.rotation180");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);    field = acroForm.getField("pdfbox.page90.multi.rotation270");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);        File file = new File(OUT_DIR, NAME_OF_PDF);    document.save(file);    TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(file, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                        System.err.println("Rendering of " + file + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }}
public void pdfbox_f8354_0() throws IOException
{    document.close();}
public void pdfbox_f8355_0() throws IOException
{    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    acroForm = document.getDocumentCatalog().getAcroForm();    OUT_DIR.mkdirs();}
public void pdfbox_f8356_0() throws IOException
{    PDTextField field = (PDTextField) acroForm.getField("AlignLeft");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Small");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Medium");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Wide");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Wide_Clipped");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Small_Outside");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Small");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Medium");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Wide");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Wide_Clipped");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Medium_Outside");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Small");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Medium");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Wide");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Wide_Clipped");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Wide_Outside");    field.setValue(TEST_VALUE);        File file = new File(OUT_DIR, NAME_OF_PDF);    document.save(file);    TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(file, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.err.println("Rendering of " + file + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }}
public void pdfbox_f8357_0() throws IOException
{    document.close();}
public void pdfbox_f8358_0() throws IOException
{    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    acroForm = document.getDocumentCatalog().getAcroForm();}
public void pdfbox_f8359_0() throws IOException
{    acroForm.getField("pdfbox-nul").setValue("NUL\0NUL");}
public void pdfbox_f8360_0() throws IOException
{    acroForm.getField("pdfbox-tab").setValue("TAB\tTAB");}
public void pdfbox_f8361_0() throws IOException
{    PDField field = acroForm.getField("pdfbox-space");    field.setValue("SPACE SPACE");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-space"));    assertEquals(pdfboxValues, acrobatValues);}
public void pdfbox_f8362_0() throws IOException
{    PDField field = acroForm.getField("pdfbox-cr");    field.setValue("CR\rCR");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-cr"));    assertEquals(pdfboxValues, acrobatValues);}
public void pdfbox_f8363_0() throws IOException
{    PDField field = acroForm.getField("pdfbox-lf");    field.setValue("LF\nLF");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-lf"));    assertEquals(pdfboxValues, acrobatValues);}
public void pdfbox_f8364_0() throws IOException
{    PDField field = acroForm.getField("pdfbox-crlf");    field.setValue("CRLF\r\nCRLF");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-crlf"));    assertEquals(pdfboxValues, acrobatValues);}
public void pdfbox_f8365_0() throws IOException
{    PDField field = acroForm.getField("pdfbox-lfcr");    field.setValue("LFCR\n\rLFCR");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-lfcr"));    assertEquals(pdfboxValues, acrobatValues);}
public void pdfbox_f8366_0() throws IOException
{    PDField field = acroForm.getField("pdfbox-linebreak");    field.setValue("linebreak\u2028linebreak");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-linebreak"));    assertEquals(pdfboxValues, acrobatValues);}
public void pdfbox_f8367_0() throws IOException
{    PDField field = acroForm.getField("pdfbox-paragraphbreak");    field.setValue("paragraphbreak\u2029paragraphbreak");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-paragraphbreak"));    assertEquals(pdfboxValues, acrobatValues);}
public void pdfbox_f8368_0() throws IOException
{    document.close();}
private List<String> pdfbox_f8369_0(PDField field) throws IOException
{    PDAnnotationWidget widget = field.getWidgets().get(0);    PDFStreamParser parser = new PDFStreamParser(widget.getNormalAppearanceStream().getContents());    Object token = parser.parseNextToken();    List<String> stringValues = new ArrayList<>();    while (token != null) {        if (token instanceof COSString) {                                                stringValues.add(((COSString) token).getString().trim());        }        token = parser.parseNextToken();    }    return stringValues;}
public void pdfbox_f8370_0() throws IOException
{    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    acroForm = document.getDocumentCatalog().getAcroForm();    OUT_DIR.mkdirs();        PDTextField field = (PDTextField) acroForm.getField("SingleAnnotation");    field.setValue("single annotation");    field = (PDTextField) acroForm.getField("MultipeAnnotations-SameLayout");    field.setValue("same layout");    field = (PDTextField) acroForm.getField("MultipleAnnotations-DifferentLayout");    field.setValue("different layout");    File file = new File(OUT_DIR, NAME_OF_PDF);    document.save(file);}
public void pdfbox_f8371_0() throws IOException
{    PDTextField field = (PDTextField) acroForm.getField("SingleAnnotation");    String fieldFontSetting = getFontSettingFromDA(field);    List<PDAnnotationWidget> widgets = field.getWidgets();    for (PDAnnotationWidget widget : widgets) {        String contentAsString = new String(widget.getNormalAppearanceStream().getContentStream().toByteArray());        assertTrue(contentAsString.indexOf(fieldFontSetting) > 0);    }}
public void pdfbox_f8372_0() throws IOException
{    PDTextField field = (PDTextField) acroForm.getField("MultipeAnnotations-SameLayout");    String fieldFontSetting = getFontSettingFromDA(field);    List<PDAnnotationWidget> widgets = field.getWidgets();    for (PDAnnotationWidget widget : widgets) {        String contentAsString = new String(widget.getNormalAppearanceStream().getContentStream().toByteArray());        assertTrue("font setting in content stream shall be " + fieldFontSetting, contentAsString.indexOf(fieldFontSetting) > 0);    }}
public void pdfbox_f8373_0() throws IOException
{    PDTextField field = (PDTextField) acroForm.getField("MultipleAnnotations-DifferentLayout");    String fieldFontSetting = getFontSettingFromDA(field);    List<PDAnnotationWidget> widgets = field.getWidgets();    for (PDAnnotationWidget widget : widgets) {        String widgetFontSetting = getFontSettingFromDA(widget);        String fontSetting = widgetFontSetting == null ? fieldFontSetting : widgetFontSetting;        String contentAsString = new String(widget.getNormalAppearanceStream().getContentStream().toByteArray());        assertTrue("font setting in content stream shall be " + fontSetting, contentAsString.indexOf(fontSetting) > 0);    }}
public void pdfbox_f8374_0() throws IOException
{    document.close();}
private String pdfbox_f8375_0(PDTextField field)
{    String defaultAppearance = field.getDefaultAppearance();        return defaultAppearance.substring(0, defaultAppearance.lastIndexOf("Tf") + 2);}
private String pdfbox_f8376_0(PDAnnotationWidget widget)
{    String defaultAppearance = widget.getCOSObject().getString(COSName.DA);    if (defaultAppearance != null) {        return defaultAppearance.substring(0, defaultAppearance.lastIndexOf("Tf") + 2);    }    return defaultAppearance;}
public void pdfbox_f8377_0() throws IOException
{    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    acroForm = document.getDocumentCatalog().getAcroForm();    OUT_DIR.mkdirs();}
public void pdfbox_f8378_0() throws IOException
{    PDTextField field = (PDTextField) acroForm.getField("AlignLeft");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Small");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Small");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Small");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Medium");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Medium");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Medium");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Wide");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Wide");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Wide");    field.setValue(TEST_VALUE);        File file = new File(OUT_DIR, NAME_OF_PDF);    document.save(file);    TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(file, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.err.println("Rendering of " + file + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }}
public void pdfbox_f8379_0() throws IOException
{    document.close();}
public void pdfbox_f8380_0()
{    IN_DIR.mkdirs();    OUT_DIR.mkdirs();}
public void pdfbox_f8381_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12742551/Testformular1.pdf";    String targetFileName = "Testformular1.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8382_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12425859/TestFax_56972.pdf";    String targetFileName = "TestFax_56972.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8383_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12682897/FormI-9-English.pdf";    String targetFileName = "FormI-9-English.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8384_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12678455/testPDF_acroForm.pdf";    String targetFileName = "testPDF_acroForm.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8385_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12689788/test.pdf";    String targetFileName = "test-2586.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8386_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12770263/mypdf.pdf";    String targetFileName = "mypdf.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8387_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12792007/hidden_fields.pdf";    String targetFileName = "hidden_fields.pdf";    assertTrue(flattenAndCompare(sourceUrl, targetFileName));}
public void pdfbox_f8388_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12816014/Signed-Document-1.pdf";    String targetFileName = "Signed-Document-1.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8389_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12816016/Signed-Document-2.pdf";    String targetFileName = "Signed-Document-2.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8390_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12821307/Signed-Document-3.pdf";    String targetFileName = "Signed-Document-3.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8391_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12821308/Signed-Document-4.pdf";    String targetFileName = "Signed-Document-4.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8392_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12839977/OpenOfficeForm.pdf";    String targetFileName = "OpenOfficeForm.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8393_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12840280/OpenOfficeForm_filled.pdf";    String targetFileName = "OpenOfficeForm_filled.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8394_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12976553/PDFBOX-4157-filled.pdf";    String targetFileName = "PDFBOX-4157-filled.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8395_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12976552/PDFBOX-4172-filled.pdf";    String targetFileName = "PDFBOX-4172-filled.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8396_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12976452/resetboundingbox-filled.pdf";    String targetFileName = "PDFBOX-4615-filled.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
private static boolean pdfbox_f8397_0(String sourceUrl, String targetFileName) throws IOException
{    generateSamples(sourceUrl, targetFileName);    File inputFile = new File(IN_DIR, targetFileName);    File outputFile = new File(OUT_DIR, targetFileName);    try (PDDocument testPdf = PDDocument.load(inputFile)) {        testPdf.getDocumentCatalog().getAcroForm().flatten();        testPdf.setAllSecurityToBeRemoved(true);        assertTrue(testPdf.getDocumentCatalog().getAcroForm().getFields().isEmpty());        testPdf.save(outputFile);    }        TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(outputFile, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.out.println("Rendering of " + outputFile + " failed or is not identical to expected rendering in " + IN_DIR + " directory");        removeMatchingRenditions(inputFile);        return false;    } else {                removeAllRenditions(inputFile);        inputFile.delete();        outputFile.delete();    }    return true;}
private static void pdfbox_f8398_0(String sourceUrl, String targetFile) throws IOException
{    getFromUrl(sourceUrl, targetFile);    File file = new File(IN_DIR, targetFile);    try (PDDocument document = PDDocument.load(file, (String) null)) {        String outputPrefix = IN_DIR.getAbsolutePath() + '/' + file.getName() + "-";        int numPages = document.getNumberOfPages();        PDFRenderer renderer = new PDFRenderer(document);        for (int i = 0; i < numPages; i++) {            String fileName = outputPrefix + (i + 1) + ".png";                        BufferedImage image = renderer.renderImageWithDPI(i, 96);            ImageIO.write(image, "PNG", new File(fileName));        }    }}
private static void pdfbox_f8399_0(String sourceUrl, String targetFile) throws IOException
{    URL url = new URL(sourceUrl);    try (InputStream is = url.openStream();        OutputStream os = new FileOutputStream(new File(IN_DIR, targetFile))) {        byte[] b = new byte[2048];        int length;        while ((length = is.read(b)) != -1) {            os.write(b, 0, length);        }    }}
private static void pdfbox_f8400_0(final File inputFile)
{    File[] testFiles = inputFile.getParentFile().listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return (name.startsWith(inputFile.getName()) && name.toLowerCase().endsWith(".png"));        }    });    for (File testFile : testFiles) {        if (!new File(OUT_DIR, testFile.getName()).exists()) {            testFile.delete();        }    }}
public boolean pdfbox_f8401_0(File dir, String name)
{    return (name.startsWith(inputFile.getName()) && name.toLowerCase().endsWith(".png"));}
private static void pdfbox_f8402_0(final File inputFile)
{    File[] testFiles = inputFile.getParentFile().listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return (name.startsWith(inputFile.getName()) && name.toLowerCase().endsWith(".png"));        }    });    for (File testFile : testFiles) {        testFile.delete();    }}
public boolean pdfbox_f8403_0(File dir, String name)
{    return (name.startsWith(inputFile.getName()) && name.toLowerCase().endsWith(".png"));}
public void pdfbox_f8404_0()
{    document = new PDDocument();    acroForm = new PDAcroForm(document);    document.getDocumentCatalog().setAcroForm(acroForm);}
public void pdfbox_f8405_0()
{            assertNotNull(acroForm.getFields());    assertEquals(acroForm.getFields().size(), 0);        assertNull(acroForm.getField("foo"));            acroForm.getCOSObject().removeItem(COSName.FIELDS);        assertNotNull(acroForm.getFields());    assertEquals(acroForm.getFields().size(), 0);        assertNull(acroForm.getField("foo"));}
public void pdfbox_f8406_0()
{    assertTrue(acroForm.getDefaultAppearance().isEmpty());    acroForm.setDefaultAppearance("/Helv 0 Tf 0 g");    assertEquals(acroForm.getDefaultAppearance(), "/Helv 0 Tf 0 g");}
public void pdfbox_f8407_0() throws IOException
{    File file = new File(OUT_DIR, "AlignmentTests-flattened.pdf");    try (PDDocument testPdf = PDDocument.load(new File(IN_DIR, "AlignmentTests.pdf"))) {        testPdf.getDocumentCatalog().getAcroForm().flatten();        assertTrue(testPdf.getDocumentCatalog().getAcroForm().getFields().isEmpty());        testPdf.save(file);    }        TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(file, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.out.println("Rendering of " + file + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }}
public void pdfbox_f8408_0() throws IOException
{    File file = new File(OUT_DIR, "AlignmentTests-flattened-noRef.pdf");    try (PDDocument testPdf = PDDocument.load(new File(IN_DIR, "AlignmentTests.pdf"))) {        PDAcroForm acroFormToTest = testPdf.getDocumentCatalog().getAcroForm();        for (PDField field : acroFormToTest.getFieldTree()) {            for (PDAnnotationWidget widget : field.getWidgets()) {                widget.getCOSObject().removeItem(COSName.P);            }        }        acroFormToTest.flatten();                assertEquals(36, testPdf.getPage(0).getAnnotations().size());        assertTrue(acroFormToTest.getFields().isEmpty());        testPdf.save(file);    }        TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(file, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.out.println("Rendering of " + file + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }}
public void pdfbox_f8409_0() throws IOException
{    File file = new File(OUT_DIR, "AlignmentTests-flattened-specificFields.pdf");    List<PDField> fieldsToFlatten = new ArrayList<>();    try (PDDocument testPdf = PDDocument.load(new File(IN_DIR, "AlignmentTests.pdf"))) {        PDAcroForm acroFormToFlatten = testPdf.getDocumentCatalog().getAcroForm();        int numFieldsBeforeFlatten = acroFormToFlatten.getFields().size();        int numWidgetsBeforeFlatten = countWidgets(testPdf);        fieldsToFlatten.add(acroFormToFlatten.getField("AlignLeft-Border_Small-Filled"));        fieldsToFlatten.add(acroFormToFlatten.getField("AlignLeft-Border_Medium-Filled"));        fieldsToFlatten.add(acroFormToFlatten.getField("AlignLeft-Border_Wide-Filled"));        fieldsToFlatten.add(acroFormToFlatten.getField("AlignLeft-Border_Wide_Clipped-Filled"));        acroFormToFlatten.flatten(fieldsToFlatten, true);        int numFieldsAfterFlatten = acroFormToFlatten.getFields().size();        int numWidgetsAfterFlatten = countWidgets(testPdf);        assertEquals(numFieldsBeforeFlatten, numFieldsAfterFlatten + fieldsToFlatten.size());        assertEquals(numWidgetsBeforeFlatten, numWidgetsAfterFlatten + fieldsToFlatten.size());        testPdf.save(file);    }}
public void pdfbox_f8410_0()
{    try {        byte[] pdfBytes = createAcroFormWithMissingResourceInformation();        try (PDDocument pdfDocument = PDDocument.load(pdfBytes)) {                        PDDocumentCatalog documentCatalog = pdfDocument.getDocumentCatalog();            COSDictionary catalogDictionary = documentCatalog.getCOSObject();            COSDictionary acroFormDictionary = (COSDictionary) catalogDictionary.getDictionaryObject(COSName.ACRO_FORM);                        assertNull(acroFormDictionary.getDictionaryObject(COSName.DA));            assertNull(acroFormDictionary.getDictionaryObject(COSName.RESOURCES));            pdfDocument.close();        }    } catch (IOException e) {        System.err.println("Couldn't create test document, test skipped");        return;    }}
public void pdfbox_f8411_0()
{    try {        byte[] pdfBytes = createAcroFormWithMissingResourceInformation();        try (PDDocument pdfDocument = PDDocument.load(pdfBytes)) {            PDDocumentCatalog documentCatalog = pdfDocument.getDocumentCatalog();                        PDAcroForm theAcroForm = documentCatalog.getAcroForm();                                    assertEquals("/Helv 0 Tf 0 g ", theAcroForm.getDefaultAppearance());            assertNotNull(theAcroForm.getDefaultResources());                        PDResources acroFormResources = theAcroForm.getDefaultResources();            assertNotNull(acroFormResources.getFont(COSName.getPDFName("Helv")));            assertEquals("Helvetica", acroFormResources.getFont(COSName.getPDFName("Helv")).getName());            assertNotNull(acroFormResources.getFont(COSName.getPDFName("ZaDb")));            assertEquals("ZapfDingbats", acroFormResources.getFont(COSName.getPDFName("ZaDb")).getName());        }    } catch (IOException e) {        System.err.println("Couldn't create test document, test skipped");        return;    }}
public void pdfbox_f8412_0() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDAcroForm acroForm = new PDAcroForm(document);        doc.getDocumentCatalog().setAcroForm(acroForm);        acroForm.setDefaultResources(new PDResources());        PDTextField textBox = new PDTextField(acroForm);        textBox.setPartialName("SampleField");                        textBox.setDefaultAppearance("/Helv 0 tf 0 g");        acroForm.getFields().add(textBox);        PDAnnotationWidget widget = textBox.getWidgets().get(0);        PDRectangle rect = new PDRectangle(50, 750, 200, 20);        widget.setRectangle(rect);        widget.setPage(page);        page.getAnnotations().add(widget);        try {            textBox.setValue("huhu");        } catch (IllegalArgumentException ex) {            return;        }        fail("IllegalArgumentException should have been thrown");    }}
public void pdfbox_f8413_0() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        doc.addPage(page);        PDAcroForm acroForm2 = new PDAcroForm(doc);        doc.getDocumentCatalog().setAcroForm(acroForm2);        PDResources defaultResources = acroForm2.getDefaultResources();        assertNull(defaultResources);        defaultResources = new PDResources();        acroForm2.setDefaultResources(defaultResources);        assertNull(defaultResources.getFont(COSName.HELV));        assertNull(defaultResources.getFont(COSName.ZA_DB));                acroForm2 = doc.getDocumentCatalog().getAcroForm();        defaultResources = acroForm2.getDefaultResources();        assertNotNull(defaultResources.getFont(COSName.HELV));        assertNotNull(defaultResources.getFont(COSName.ZA_DB));                doc.getDocumentCatalog().setAcroForm(new PDAcroForm(doc));        acroForm2 = doc.getDocumentCatalog().getAcroForm();        defaultResources = acroForm2.getDefaultResources();        PDFont helv = defaultResources.getFont(COSName.HELV);        PDFont zadb = defaultResources.getFont(COSName.ZA_DB);        assertNotNull(helv);        assertNotNull(zadb);        doc.save(baos);    }    try (PDDocument doc = PDDocument.load(baos.toByteArray())) {        PDAcroForm acroForm2 = doc.getDocumentCatalog().getAcroForm();        PDResources defaultResources = acroForm2.getDefaultResources();        PDFont helv = defaultResources.getFont(COSName.HELV);        PDFont zadb = defaultResources.getFont(COSName.ZA_DB);        assertNotNull(helv);        assertNotNull(zadb);                assertNotEquals(PDType1Font.HELVETICA, helv);        assertNotEquals(PDType1Font.ZAPF_DINGBATS, zadb);    }}
public void pdfbox_f8414_0() throws IOException
{    document.close();}
private byte[] pdfbox_f8415_0() throws IOException
{    try (PDDocument tmpDocument = new PDDocument();        ByteArrayOutputStream baos = new ByteArrayOutputStream()) {        PDPage page = new PDPage();        tmpDocument.addPage(page);        PDAcroForm newAcroForm = new PDAcroForm(document);        tmpDocument.getDocumentCatalog().setAcroForm(newAcroForm);        PDTextField textBox = new PDTextField(newAcroForm);        textBox.setPartialName("SampleField");        newAcroForm.getFields().add(textBox);        PDAnnotationWidget widget = textBox.getWidgets().get(0);        PDRectangle rect = new PDRectangle(50, 750, 200, 20);        widget.setRectangle(rect);        widget.setPage(page);        page.getAnnotations().add(widget);                                tmpDocument.save(baos);        tmpDocument.close();        return baos.toByteArray();    }}
private int pdfbox_f8416_0(PDDocument documentToTest)
{    int count = 0;    for (PDPage page : documentToTest.getPages()) {        try {            for (PDAnnotation annotation : page.getAnnotations()) {                if (annotation instanceof PDAnnotationWidget) {                    count++;                }            }        } catch (IOException e) {                }    }    return count;}
public void pdfbox_f8417_0() throws IOException
{    document = new PDDocument();    acroForm = new PDAcroForm(document);    acrobatDocument = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    acrobatAcroForm = acrobatDocument.getDocumentCatalog().getAcroForm();}
public void pdfbox_f8418_0()
{    PDButton buttonField = new PDCheckBox(acroForm);    assertEquals(buttonField.getFieldType(), buttonField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(buttonField.getFieldType(), "Btn");    assertFalse(buttonField.isPushButton());    assertFalse(buttonField.isRadioButton());}
public void pdfbox_f8419_0()
{    PDButton buttonField = new PDPushButton(acroForm);    assertEquals(buttonField.getFieldType(), buttonField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(buttonField.getFieldType(), "Btn");    assertTrue(buttonField.isPushButton());    assertFalse(buttonField.isRadioButton());}
public void pdfbox_f8420_0()
{    PDButton buttonField = new PDRadioButton(acroForm);    assertEquals(buttonField.getFieldType(), buttonField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(buttonField.getFieldType(), "Btn");    assertTrue(buttonField.isRadioButton());    assertFalse(buttonField.isPushButton());}
public void pdfbox_f8421_0() throws MalformedURLException
{    File file = new File(TARGET_PDF_DIR, "PDFBOX-3656.pdf");    try (InputStream is = new FileInputStream(file);        PDDocument pdfDocument = PDDocument.load(is)) {        PDRadioButton radioButton = (PDRadioButton) pdfDocument.getDocumentCatalog().getAcroForm().getField("Checking/Savings");        radioButton.setValue("Off");        for (PDAnnotationWidget widget : radioButton.getWidgets()) {            assertEquals("The widget should be set to Off", COSName.Off, widget.getCOSObject().getItem(COSName.AS));        }    } catch (IOException e) {        fail("Unexpected IOException " + e.getMessage());    }}
public void pdfbox_f8422_0() throws MalformedURLException
{    File file = new File(TARGET_PDF_DIR, "PDFBOX-3682.pdf");    try (InputStream is = new FileInputStream(file);        PDDocument pdfDocument = PDDocument.load(is)) {        pdfDocument.getDocumentCatalog().getAcroForm().getField("RadioButton").setValue("c");        PDRadioButton radioButton = (PDRadioButton) pdfDocument.getDocumentCatalog().getAcroForm().getField("RadioButton");        radioButton.setValue("c");                assertFalse("This shall no longer be 2", "2".equals(radioButton.getValueAsString()));        assertFalse("This shall no longer be 2", "2".equals(radioButton.getWidgets().get(2).getCOSObject().getNameAsString(COSName.AS)));                assertTrue("This shall be c", "c".equals(radioButton.getValueAsString()));        assertTrue("This shall be c", "c".equals(radioButton.getWidgets().get(2).getCOSObject().getNameAsString(COSName.AS)));    } catch (IOException e) {        fail("Unexpected IOException " + e.getMessage());    }}
public void pdfbox_f8423_0()
{    PDCheckBox checkbox = (PDCheckBox) acrobatAcroForm.getField("Checkbox");    assertNotNull(checkbox);    assertEquals(checkbox.getOnValue(), "Yes");    assertEquals(checkbox.getOnValues().size(), 1);    assertTrue(checkbox.getOnValues().contains("Yes"));}
public void pdfbox_f8424_0() throws IOException
{    PDCheckBox checkbox = (PDCheckBox) acrobatAcroForm.getField("Checkbox");    assertEquals(checkbox.getValue(), "Off");    assertEquals(checkbox.isChecked(), false);    checkbox.check();    assertEquals(checkbox.getValue(), checkbox.getOnValue());    assertEquals(checkbox.isChecked(), true);    checkbox.setValue("Yes");    assertEquals(checkbox.getValue(), checkbox.getOnValue());    assertEquals(checkbox.isChecked(), true);    assertEquals(checkbox.getCOSObject().getDictionaryObject(COSName.AS), COSName.YES);    checkbox.setValue("Off");    assertEquals(checkbox.getValue(), COSName.Off.getName());    assertEquals(checkbox.isChecked(), false);    assertEquals(checkbox.getCOSObject().getDictionaryObject(COSName.AS), COSName.Off);    checkbox = (PDCheckBox) acrobatAcroForm.getField("Checkbox-DefaultValue");    assertEquals(checkbox.getDefaultValue(), checkbox.getOnValue());    checkbox.setDefaultValue("Off");    assertEquals(checkbox.getDefaultValue(), COSName.Off.getName());}
public void pdfbox_f8425_0() throws IOException
{    PDField checkbox = acrobatAcroForm.getField("Checkbox");    checkbox.setValue("Yes");    assertEquals(checkbox.getValueAsString(), ((PDCheckBox) checkbox).getOnValue());    assertEquals(((PDCheckBox) checkbox).isChecked(), true);    assertEquals(checkbox.getCOSObject().getDictionaryObject(COSName.AS), COSName.YES);    checkbox.setValue("Off");    assertEquals(checkbox.getValueAsString(), COSName.Off.getName());    assertEquals(((PDCheckBox) checkbox).isChecked(), false);    assertEquals(checkbox.getCOSObject().getDictionaryObject(COSName.AS), COSName.Off);}
public void pdfbox_f8426_0() throws IOException
{    PDCheckBox checkbox = (PDCheckBox) acrobatAcroForm.getField("CheckboxGroup");    assertEquals(checkbox.getValue(), "Off");    assertEquals(checkbox.isChecked(), false);    checkbox.check();    assertEquals(checkbox.getValue(), checkbox.getOnValue());    assertEquals(checkbox.isChecked(), true);    assertEquals(checkbox.getOnValues().size(), 3);    assertTrue(checkbox.getOnValues().contains("Option1"));    assertTrue(checkbox.getOnValues().contains("Option2"));    assertTrue(checkbox.getOnValues().contains("Option3"));        checkbox.setValue("Option1");    assertEquals("Option1", checkbox.getValue());    assertEquals("Option1", checkbox.getValueAsString());            assertEquals("Option1", checkbox.getWidgets().get(0).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(1).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(2).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(3).getAppearanceState().getName());            checkbox.setValue("Option3");    assertEquals("Option3", checkbox.getValue());    assertEquals("Option3", checkbox.getValueAsString());            assertEquals("Off", checkbox.getWidgets().get(0).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(1).getAppearanceState().getName());    assertEquals("Option3", checkbox.getWidgets().get(2).getAppearanceState().getName());    assertEquals("Option3", checkbox.getWidgets().get(3).getAppearanceState().getName());}
public void pdfbox_f8427_0() throws IOException
{    PDField checkbox = acrobatAcroForm.getField("CheckboxGroup");        checkbox.setValue("Option1");    assertEquals("Option1", checkbox.getValueAsString());            assertEquals("Option1", checkbox.getWidgets().get(0).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(1).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(2).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(3).getAppearanceState().getName());            checkbox.setValue("Option3");    assertEquals("Option3", checkbox.getValueAsString());            assertEquals("Off", checkbox.getWidgets().get(0).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(1).getAppearanceState().getName());    assertEquals("Option3", checkbox.getWidgets().get(2).getAppearanceState().getName());    assertEquals("Option3", checkbox.getWidgets().get(3).getAppearanceState().getName());}
public void pdfbox_f8428_0() throws IOException
{    PDCheckBox checkbox = (PDCheckBox) acrobatAcroForm.getField("Checkbox");        checkbox.setValue("InvalidValue");}
public void pdfbox_f8429_0() throws IOException
{    PDCheckBox checkbox = (PDCheckBox) acrobatAcroForm.getField("CheckboxGroup");        checkbox.setValue("InvalidValue");}
public void pdfbox_f8430_0() throws IOException
{    PDField checkbox = acrobatAcroForm.getField("Checkbox");        checkbox.setValue("InvalidValue");}
public void pdfbox_f8431_0() throws IOException
{    PDField checkbox = acrobatAcroForm.getField("CheckboxGroup");        checkbox.setValue("InvalidValue");}
public void pdfbox_f8432_0()
{    PDRadioButton radioButton = (PDRadioButton) acrobatAcroForm.getField("RadioButtonGroup");    assertNotNull(radioButton);    assertEquals(radioButton.getOnValues().size(), 2);    assertTrue(radioButton.getOnValues().contains("RadioButton01"));    assertTrue(radioButton.getOnValues().contains("RadioButton02"));}
public void pdfbox_f8433_0() throws IOException
{    PDRadioButton radioButton = (PDRadioButton) acrobatAcroForm.getField("RadioButtonGroup");        radioButton.setValue("RadioButton01");    assertEquals(radioButton.getValue(), "RadioButton01");        assertEquals(radioButton.getWidgets().get(0).getCOSObject().getDictionaryObject(COSName.AS), COSName.getPDFName("RadioButton01"));    assertEquals(radioButton.getWidgets().get(1).getCOSObject().getDictionaryObject(COSName.AS), COSName.Off);        radioButton.setValue("RadioButton02");    assertEquals(radioButton.getValue(), "RadioButton02");        assertEquals(radioButton.getWidgets().get(0).getCOSObject().getDictionaryObject(COSName.AS), COSName.Off);    assertEquals(radioButton.getWidgets().get(1).getCOSObject().getDictionaryObject(COSName.AS), COSName.getPDFName("RadioButton02"));}
public void pdfbox_f8434_0() throws IOException
{    PDField radioButton = acrobatAcroForm.getField("RadioButtonGroup");        radioButton.setValue("RadioButton01");    assertEquals(radioButton.getValueAsString(), "RadioButton01");        assertEquals(radioButton.getWidgets().get(0).getCOSObject().getDictionaryObject(COSName.AS), COSName.getPDFName("RadioButton01"));    assertEquals(radioButton.getWidgets().get(1).getCOSObject().getDictionaryObject(COSName.AS), COSName.Off);        radioButton.setValue("RadioButton02");    assertEquals(radioButton.getValueAsString(), "RadioButton02");        assertEquals(radioButton.getWidgets().get(0).getCOSObject().getDictionaryObject(COSName.AS), COSName.Off);    assertEquals(radioButton.getWidgets().get(1).getCOSObject().getDictionaryObject(COSName.AS), COSName.getPDFName("RadioButton02"));}
public void pdfbox_f8435_0() throws IOException
{    PDRadioButton radioButton = (PDRadioButton) acrobatAcroForm.getField("RadioButtonGroup");        radioButton.setValue("InvalidValue");}
public void pdfbox_f8436_0() throws IOException
{    PDField radioButton = acrobatAcroForm.getField("RadioButtonGroup");        radioButton.setValue("InvalidValue");}
public void pdfbox_f8437_0() throws IOException
{    document.close();    acrobatDocument.close();}
public void pdfbox_f8438_0()
{    document = new PDDocument();    acroForm = new PDAcroForm(document);    options = new ArrayList<>();    options.add(" ");    options.add("A");    options.add("B");}
public void pdfbox_f8439_0()
{    PDChoice choiceField = new PDListBox(acroForm);    assertEquals(choiceField.getFieldType(), choiceField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(choiceField.getFieldType(), "Ch");    assertFalse(choiceField.isCombo());}
public void pdfbox_f8440_0()
{    PDChoice choiceField = new PDComboBox(acroForm);    assertEquals(choiceField.getFieldType(), choiceField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(choiceField.getFieldType(), "Ch");    assertTrue(choiceField.isCombo());}
public void pdfbox_f8441_0()
{    PDChoice choiceField = new PDComboBox(acroForm);    COSArray choiceFieldOptions = new COSArray();    choiceFieldOptions.add(new COSString(" "));    choiceFieldOptions.add(new COSString("A"));    choiceFieldOptions.add(new COSString("B"));            choiceField.getCOSObject().setItem(COSName.OPT, choiceFieldOptions);    assertEquals(options, choiceField.getOptions());}
public void pdfbox_f8442_0()
{    PDChoice choiceField = new PDComboBox(acroForm);    COSArray choiceFieldOptions = new COSArray();        COSArray entry = new COSArray();    entry.add(new COSString(" "));    choiceFieldOptions.add(entry);        entry = new COSArray();    entry.add(new COSString("A"));    choiceFieldOptions.add(entry);        entry = new COSArray();    entry.add(new COSString("B"));    choiceFieldOptions.add(entry);            choiceField.getCOSObject().setItem(COSName.OPT, choiceFieldOptions);    assertEquals(options, choiceField.getOptions());}
public void pdfbox_f8443_0()
{    PDChoice choiceField = new PDComboBox(acroForm);    COSArray choiceFieldOptions = new COSArray();        choiceFieldOptions.add(new COSString(" "));        COSArray entry = new COSArray();    entry.add(new COSString("A"));    choiceFieldOptions.add(entry);        entry = new COSArray();    entry.add(new COSString("B"));    choiceFieldOptions.add(entry);            choiceField.getCOSObject().setItem(COSName.OPT, choiceFieldOptions);    assertEquals(options, choiceField.getOptions());}
public void pdfbox_f8444_0()
{    resources = new PDResources();            fontResourceName = resources.add(PDType1Font.HELVETICA);}
public void pdfbox_f8445_0() throws IOException
{    COSString sampleString = new COSString("/" + fontResourceName.getName() + " 12 Tf 0.019 0.305 0.627 rg");    PDDefaultAppearanceString defaultAppearanceString = new PDDefaultAppearanceString(sampleString, resources);    assertEquals(12, defaultAppearanceString.getFontSize(), 0.001);    assertEquals(PDType1Font.HELVETICA, defaultAppearanceString.getFont());    assertEquals(PDDeviceRGB.INSTANCE, defaultAppearanceString.getFontColor().getColorSpace());    assertEquals(0.019, defaultAppearanceString.getFontColor().getComponents()[0], 0.0001);    assertEquals(0.305, defaultAppearanceString.getFontColor().getComponents()[1], 0.0001);    assertEquals(0.627, defaultAppearanceString.getFontColor().getComponents()[2], 0.0001);}
public void pdfbox_f8446_0() throws IOException
{    COSString sampleString = new COSString("/Helvetica 12 Tf 0.019 0.305 0.627 rg");    new PDDefaultAppearanceString(sampleString, resources);}
public void pdfbox_f8447_0() throws IOException
{    COSString sampleString = new COSString("/Helvetica 12 Tf 0.305 0.627 rg");    new PDDefaultAppearanceString(sampleString, resources);}
public void pdfbox_f8448_0()
{    document = new PDDocument();    acroForm = new PDAcroForm(document);}
public void pdfbox_f8449_0()
{    PDSignatureField sigField = new PDSignatureField(acroForm);    sigField.setPartialName("SignatureField");    assertEquals(sigField.getFieldType(), sigField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(sigField.getFieldType(), "Sig");    assertEquals(COSName.ANNOT, sigField.getCOSObject().getItem(COSName.TYPE));    assertEquals(PDAnnotationWidget.SUB_TYPE, sigField.getCOSObject().getNameAsString(COSName.SUBTYPE));        List<PDField> fields = new ArrayList<>();    fields.add(sigField);    this.acroForm.setFields(fields);    assertNotNull(acroForm.getField("SignatureField"));}
public void pdfbox_f8450_0()
{    PDSignatureField sigField = new PDSignatureField(acroForm);    sigField.setPartialName("SignatureField");    sigField.setValue("Can't set value using String");}
public void pdfbox_f8451_0()
{    document = new PDDocument();    acroForm = new PDAcroForm(document);}
public void pdfbox_f8452_0()
{    PDField textField = new PDTextField(acroForm);    assertEquals(textField.getFieldType(), textField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(textField.getFieldType(), "Tx");}
public void pdfbox_f8453_0()
{    PDTextField textField = new PDTextField(acroForm);    assertNull(textField.getCOSObject().getItem(COSName.TYPE));    assertNull(textField.getCOSObject().getNameAsString(COSName.SUBTYPE));    PDAnnotationWidget widget = textField.getWidgets().get(0);    assertEquals(COSName.ANNOT, textField.getCOSObject().getItem(COSName.TYPE));    assertEquals(PDAnnotationWidget.SUB_TYPE, textField.getCOSObject().getNameAsString(COSName.SUBTYPE));    assertEquals(widget.getCOSObject(), textField.getCOSObject());}
public void pdfbox_f8454_0()
{    PlainText text = new PlainText("CR\rCR");    assertEquals(2, text.getParagraphs().size());}
public void pdfbox_f8455_0()
{    PlainText text = new PlainText("LF\nLF");    assertEquals(2, text.getParagraphs().size());}
public void pdfbox_f8456_0()
{    PlainText text = new PlainText("CRLF\r\nCRLF");    assertEquals(2, text.getParagraphs().size());}
public void pdfbox_f8457_0()
{    PlainText text = new PlainText("LFCR\n\rLFCR");    assertEquals(3, text.getParagraphs().size());}
public void pdfbox_f8458_0()
{    PlainText text = new PlainText("linebreak\u2028linebreak");    assertEquals(2, text.getParagraphs().size());}
public void pdfbox_f8459_0()
{    PlainText text = new PlainText("paragraphbreak\u2029paragraphbreak");    assertEquals(2, text.getParagraphs().size());}
public static Test pdfbox_f8460_0()
{    return new TestSuite(TestCheckBox.class);}
public static void pdfbox_f8461_0(String[] args)
{    String[] arg = { TestCheckBox.class.getName() };    junit.textui.TestRunner.main(arg);}
public void pdfbox_f8462_0() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDAcroForm form = new PDAcroForm(doc);        PDCheckBox checkBox = new PDCheckBox(form);                        assertNotNull(checkBox.getExportValues());        assertNotNull(checkBox.getValue());                List<String> options = new ArrayList<>();        options.add("Value01");        options.add("Value02");        checkBox.setExportValues(options);        COSArray optItem = (COSArray) checkBox.getCOSObject().getItem(COSName.OPT);                assertNotNull(checkBox.getCOSObject().getItem(COSName.OPT));        assertEquals(optItem.size(), 2);        assertEquals(options.get(0), optItem.getString(0));                List<String> retrievedOptions = checkBox.getExportValues();        assertEquals(retrievedOptions.size(), 2);        assertEquals(retrievedOptions, options);                checkBox.setExportValues(null);        assertNull(checkBox.getCOSObject().getItem(COSName.OPT));                assertTrue(checkBox.getExportValues().isEmpty());    }}
public void pdfbox_f8463_0() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDAcroForm acroForm = new PDAcroForm(doc);                acroForm.setNeedAppearances(true);        doc.getDocumentCatalog().setAcroForm(acroForm);        List<PDField> fields = new ArrayList<>();        PDCheckBox checkBox = new PDCheckBox(acroForm);        checkBox.setPartialName("checkbox");        PDAnnotationWidget widget = checkBox.getWidgets().get(0);        widget.setRectangle(new PDRectangle(50, 600, 100, 100));        PDBorderStyleDictionary bs = new PDBorderStyleDictionary();        bs.setStyle(PDBorderStyleDictionary.STYLE_SOLID);        bs.setWidth(1);        COSDictionary acd = new COSDictionary();        PDAppearanceCharacteristicsDictionary ac = new PDAppearanceCharacteristicsDictionary(acd);        ac.setBackground(new PDColor(new float[] { 1, 1, 0 }, PDDeviceRGB.INSTANCE));        ac.setBorderColour(new PDColor(new float[] { 1, 0, 0 }, PDDeviceRGB.INSTANCE));                ac.setNormalCaption("4");        widget.setAppearanceCharacteristics(ac);        widget.setBorderStyle(bs);        checkBox.setValue("Off");        fields.add(checkBox);        page.getAnnotations().add(widget);        acroForm.setFields(fields);        assertEquals("Off", checkBox.getValue());    }}
public static Test pdfbox_f8464_0()
{    return new TestSuite(TestFields.class);}
public static void pdfbox_f8465_0(String[] args)
{    String[] arg = { TestFields.class.getName() };    junit.textui.TestRunner.main(arg);}
public void pdfbox_f8466_0() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDAcroForm form = new PDAcroForm(doc);        PDTextField textBox = new PDTextField(form);                assertFalse(textBox.isComb());                textBox.setComb(true);        assertTrue(textBox.isComb());        textBox.setComb(false);        assertFalse(textBox.isComb());                textBox.setComb(true);        textBox.setDoNotScroll(true);        assertTrue(textBox.isComb());        assertTrue(textBox.doNotScroll());        textBox.setComb(false);        textBox.setDoNotScroll(false);        assertFalse(textBox.isComb());        assertFalse(textBox.doNotScroll());                textBox.setComb(false);        assertFalse(textBox.isComb());        textBox.setComb(false);        assertFalse(textBox.isComb());                textBox.setComb(true);        assertTrue(textBox.isComb());        textBox.setComb(true);        assertTrue(textBox.isComb());    }}
public void pdfbox_f8467_0() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(PATH_OF_PDF))) {                PDAcroForm form = doc.getDocumentCatalog().getAcroForm();        assertNotNull(form);                        PDTextField textField = (PDTextField) form.getField("TextField");        assertNull(textField.getCOSObject().getItem(COSName.V));        textField.setValue("field value");        assertNotNull(textField.getCOSObject().getItem(COSName.V));        assertEquals(textField.getValue(), "field value");                assertNotNull(textField.getCOSObject().getItem(COSName.V));        textField.setValue(null);        assertNull(textField.getCOSObject().getItem(COSName.V));                textField = (PDTextField) form.getField("TextField-DefaultValue");        assertNotNull(textField);        assertEquals(textField.getDefaultValue(), "DefaultValue");        assertEquals(textField.getDefaultValue(), ((COSString) textField.getCOSObject().getDictionaryObject(COSName.DV)).getString());        assertEquals(textField.getDefaultAppearance(), "/Helv 12 Tf 0 g");                textField = (PDTextField) form.getField("RichTextField-DefaultValue");        assertNotNull(textField);        assertEquals(textField.getDefaultValue(), "DefaultValue");        assertEquals(textField.getDefaultValue(), ((COSString) textField.getCOSObject().getDictionaryObject(COSName.DV)).getString());        assertEquals(textField.getValue(), "DefaultValue");        assertEquals(textField.getDefaultAppearance(), "/Helv 12 Tf 0 g");        assertEquals(textField.getDefaultStyleString(), "font: Helvetica,sans-serif 12.0pt; text-align:left; color:#000000 ");                assertEquals(textField.getRichTextValue().length(), 338);                textField = (PDTextField) form.getField("LongRichTextField");        assertNotNull(textField);        assertEquals(textField.getCOSObject().getDictionaryObject(COSName.V).getClass().getName(), "org.apache.pdfbox.cos.COSStream");        assertEquals(textField.getValue().length(), 145396);    }}
public void pdfbox_f8468_0() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(PATH_OF_PDF))) {        PDAcroForm form = doc.getDocumentCatalog().getAcroForm();        PDTextField textField = (PDTextField) form.getField("TextField-DefaultValue");        PDAnnotationWidget widget = textField.getWidgets().get(0);                assertNotNull(widget.getCOSObject().getDictionaryObject(COSName.AP));        widget.getCOSObject().removeItem(COSName.RECT);        textField.setValue("field value");                        assertNull(widget.getCOSObject().getDictionaryObject(COSName.AP));    }}
public static Test pdfbox_f8469_0()
{    return new TestSuite(TestListBox.class);}
public static void pdfbox_f8470_0(String[] args)
{    String[] arg = { TestListBox.class.getName() };    junit.textui.TestRunner.main(arg);}
public void pdfbox_f8471_0() throws IOException
{    /*         * Set up two data lists which will be used for the tests         */        List<String> exportValues = new ArrayList<>();    exportValues.add("export01");    exportValues.add("export02");    exportValues.add("export03");            List<String> displayValues = new ArrayList<>();    displayValues.add("display02");    displayValues.add("display01");    displayValues.add("display03");    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        doc.addPage(page);        PDAcroForm form = new PDAcroForm(doc);                        PDFont font = PDType1Font.HELVETICA;        PDResources resources = new PDResources();        resources.put(COSName.getPDFName("Helv"), font);                form.setDefaultResources(resources);                        String defaultAppearanceString = "/Helv 0 Tf 0 g";        form.setDefaultAppearance(defaultAppearanceString);        PDListBox choice = new PDListBox(form);        choice.setDefaultAppearance("/Helv 12 Tf 0g");                PDAnnotationWidget widget = choice.getWidgets().get(0);        PDRectangle rect = new PDRectangle(50, 750, 200, 50);        widget.setRectangle(rect);        widget.setPage(page);                page.getAnnotations().add(widget);                        assertNotNull(choice.getOptions());        assertNotNull(choice.getValue());        /*             * Tests for setting the export values             */                choice.setOptions(exportValues);        assertEquals(exportValues, choice.getOptionsDisplayValues());        assertEquals(exportValues, choice.getOptionsExportValues());                choice.setTopIndex(1);        choice.setValue(exportValues.get(2));        assertEquals(exportValues.get(2), choice.getValue().get(0));                choice.setTopIndex(null);                COSArray optItem = (COSArray) choice.getCOSObject().getItem(COSName.OPT);        assertNotNull(choice.getCOSObject().getItem(COSName.OPT));        assertEquals(optItem.size(), exportValues.size());        assertEquals(exportValues.get(0), optItem.getString(0));                List<String> retrievedOptions = choice.getOptions();        assertEquals(retrievedOptions.size(), exportValues.size());        assertEquals(retrievedOptions, exportValues);        /*             * Tests for setting the field values             */                choice.setValue("export01");        assertEquals(choice.getValue().get(0), "export01");                choice.setMultiSelect(false);                try {            choice.setValue(exportValues);            fail("Missing IllegalArgumentException");        } catch (IllegalArgumentException e) {            assertEquals("The list box does not allow multiple selections.", e.getMessage());        }                choice.setMultiSelect(true);                choice.setValue(exportValues);                COSArray valueItems = (COSArray) choice.getCOSObject().getItem(COSName.V);        assertNotNull(valueItems);        assertEquals(valueItems.size(), exportValues.size());        assertEquals(exportValues.get(0), valueItems.getString(0));                COSArray indexItems = (COSArray) choice.getCOSObject().getItem(COSName.I);        assertNotNull(indexItems);        assertEquals(indexItems.size(), exportValues.size());                choice.setValue("export01");        indexItems = (COSArray) choice.getCOSObject().getItem(COSName.I);        assertNull(indexItems);                choice.setOptions(null);        assertNull(choice.getCOSObject().getItem(COSName.OPT));                assertEquals(choice.getOptions(), Collections.<String>emptyList());        /*             * Test for setting export and display values             */                choice.setOptions(exportValues, displayValues);        assertEquals(displayValues, choice.getOptionsDisplayValues());        assertEquals(exportValues, choice.getOptionsExportValues());        /*             * Testing the sort option             */        assertEquals(choice.getOptionsDisplayValues().get(0), "display02");        choice.setSort(true);        choice.setOptions(exportValues, displayValues);        assertEquals(choice.getOptionsDisplayValues().get(0), "display01");        /*             * Setting options with an empty list             */                choice.setOptions(null, displayValues);        assertNull(choice.getCOSObject().getItem(COSName.OPT));                assertEquals(choice.getOptions(), Collections.<String>emptyList());        assertEquals(choice.getOptionsDisplayValues(), Collections.<String>emptyList());        assertEquals(choice.getOptionsExportValues(), Collections.<String>emptyList());                        exportValues.remove(1);        try {            choice.setOptions(exportValues, displayValues);            fail("Missing exception");        } catch (IllegalArgumentException e) {            assertEquals("The number of entries for exportValue and displayValue shall be the same.", e.getMessage());        }    }}
public static Test pdfbox_f8472_0()
{    return new TestSuite(TestRadioButtons.class);}
public static void pdfbox_f8473_0(String[] args)
{    String[] arg = { TestRadioButtons.class.getName() };    junit.textui.TestRunner.main(arg);}
public void pdfbox_f8474_0() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDAcroForm form = new PDAcroForm(doc);        PDRadioButton radioButton = new PDRadioButton(form);                        assertNotNull(radioButton.getDefaultValue());        assertNotNull(radioButton.getSelectedExportValues());        assertNotNull(radioButton.getExportValues());        assertNotNull(radioButton.getValue());                List<String> options = new ArrayList<>();        options.add("Value01");        options.add("Value02");        radioButton.setExportValues(options);        COSArray optItem = (COSArray) radioButton.getCOSObject().getItem(COSName.OPT);                assertNotNull(radioButton.getCOSObject().getItem(COSName.OPT));        assertEquals(optItem.size(), 2);        assertEquals(options.get(0), optItem.getString(0));                List<String> retrievedOptions = radioButton.getExportValues();        assertEquals(retrievedOptions.size(), 2);        assertEquals(retrievedOptions, options);                radioButton.setExportValues(null);        assertNull(radioButton.getCOSObject().getItem(COSName.OPT));                assertEquals(radioButton.getExportValues(), new ArrayList<String>());    }}
public void pdfbox_f8475_0()
{    assertEquals(COSName.NONE, PDTransitionDirection.NONE.getCOSBase());    assertEquals(0, ((COSInteger) PDTransitionDirection.LEFT_TO_RIGHT.getCOSBase()).intValue());    assertEquals(90, ((COSInteger) PDTransitionDirection.BOTTOM_TO_TOP.getCOSBase()).intValue());    assertEquals(180, ((COSInteger) PDTransitionDirection.RIGHT_TO_LEFT.getCOSBase()).intValue());    assertEquals(270, ((COSInteger) PDTransitionDirection.TOP_TO_BOTTOM.getCOSBase()).intValue());    assertEquals(315, ((COSInteger) PDTransitionDirection.TOP_LEFT_TO_BOTTOM_RIGHT.getCOSBase()).intValue());}
public void pdfbox_f8476_0()
{    PDTransition transition = new PDTransition();    assertEquals(COSName.TRANS, transition.getCOSObject().getCOSName(COSName.TYPE));    assertEquals(PDTransitionStyle.R.name(), transition.getStyle());}
public void pdfbox_f8477_0()
{    PDTransition transition = new PDTransition(PDTransitionStyle.Fade);    assertEquals(COSName.TRANS, transition.getCOSObject().getCOSName(COSName.TYPE));    assertEquals(PDTransitionStyle.Fade.name(), transition.getStyle());}
public void pdfbox_f8478_0()
{    PDTransition transition = new PDTransition(new COSDictionary());    assertEquals(PDTransitionStyle.R.name(), transition.getStyle());    assertEquals(PDTransitionDimension.H.name(), transition.getDimension());    assertEquals(PDTransitionMotion.I.name(), transition.getMotion());    assertEquals(COSInteger.ZERO, transition.getDirection());    assertEquals(1, transition.getDuration(), 0);    assertEquals(1, transition.getFlyScale(), 0);    assertFalse(transition.isFlyAreaOpaque());}
public void pdfbox_f8479_0()
{    PDTransition transition = new PDTransition();    transition.setDimension(PDTransitionDimension.H);    assertEquals(PDTransitionDimension.H.name(), transition.getDimension());}
public void pdfbox_f8480_0()
{    PDTransition transition = new PDTransition();    transition.setDirection(PDTransitionDirection.NONE);    assertEquals(COSName.class.getName(), transition.getDirection().getClass().getName());    assertEquals(COSName.NONE, transition.getDirection());}
public void pdfbox_f8481_0()
{    PDTransition transition = new PDTransition();    transition.setDirection(PDTransitionDirection.LEFT_TO_RIGHT);    assertEquals(COSInteger.class.getName(), transition.getDirection().getClass().getName());    assertEquals(COSInteger.ZERO, transition.getDirection());}
public void pdfbox_f8482_0()
{    PDTransition transition = new PDTransition();    transition.setMotion(PDTransitionMotion.O);    assertEquals(PDTransitionMotion.O.name(), transition.getMotion());}
public void pdfbox_f8483_0()
{    PDTransition transition = new PDTransition();    transition.setDuration(4);    assertEquals(4, transition.getDuration(), 0);}
public void pdfbox_f8484_0()
{    PDTransition transition = new PDTransition();    transition.setFlyScale(4);    assertEquals(4, transition.getFlyScale(), 0);}
public void pdfbox_f8485_0()
{    PDTransition transition = new PDTransition();    transition.setFlyAreaOpaque(true);    assertTrue(transition.isFlyAreaOpaque());}
public void pdfbox_f8486_0()
{    Set<PageLayout> pageLayoutSet = EnumSet.noneOf(PageLayout.class);    Set<String> stringSet = new HashSet<>();    for (PageLayout pl : PageLayout.values()) {        String s = pl.stringValue();        stringSet.add(s);        pageLayoutSet.add(PageLayout.fromString(s));    }    assertEquals(PageLayout.values().length, pageLayoutSet.size());    assertEquals(PageLayout.values().length, stringSet.size());}
public void pdfbox_f8487_0()
{        final String value = "SinglePag";        thrown.expect(IllegalArgumentException.class);    PageLayout.fromString(value);}
public void pdfbox_f8488_0()
{        final String value = "FullScreen";        final PageMode retval = PageMode.fromString(value);        Assert.assertEquals(PageMode.FULL_SCREEN, retval);}
public void pdfbox_f8489_0()
{        final String value = "UseThumbs";        final PageMode retval = PageMode.fromString(value);        Assert.assertEquals(PageMode.USE_THUMBS, retval);}
public void pdfbox_f8490_0()
{        final String value = "UseOC";        final PageMode retval = PageMode.fromString(value);        Assert.assertEquals(PageMode.USE_OPTIONAL_CONTENT, retval);}
public void pdfbox_f8491_0()
{        final String value = "UseNone";        final PageMode retval = PageMode.fromString(value);        Assert.assertEquals(PageMode.USE_NONE, retval);}
public void pdfbox_f8492_0()
{        final String value = "UseAttachments";        final PageMode retval = PageMode.fromString(value);        Assert.assertEquals(PageMode.USE_ATTACHMENTS, retval);}
public void pdfbox_f8493_0()
{        final String value = "UseOutlines";        final PageMode retval = PageMode.fromString(value);        Assert.assertEquals(PageMode.USE_OUTLINES, retval);}
public void pdfbox_f8494_0()
{        final String value = "";        thrown.expect(IllegalArgumentException.class);    PageMode.fromString(value);}
public void pdfbox_f8495_0()
{        final String value = "Dulacb`ecj";        thrown.expect(IllegalArgumentException.class);    PageMode.fromString(value);}
public void pdfbox_f8496_0()
{        final PageMode objectUnderTest = PageMode.USE_OPTIONAL_CONTENT;        final String retval = objectUnderTest.stringValue();        Assert.assertEquals("UseOC", retval);}
public void pdfbox_f8497_0() throws URISyntaxException, IOException
{    checkFields("/org/apache/pdfbox/pdfparser/withcatalog.fdf");    checkFields("/org/apache/pdfbox/pdfparser/nocatalog.fdf");}
private void pdfbox_f8498_0(String name) throws IOException, URISyntaxException
{    try (FDFDocument fdf = FDFDocument.load(new File(TestFDF.class.getResource(name).toURI()))) {        fdf.saveXFDF(new PrintWriter(new ByteArrayOutputStream()));        List<FDFField> fields = fdf.getCatalog().getFDF().getFields();        assertEquals(2, fields.size());        assertEquals("Field1", fields.get(0).getPartialFieldName());        assertEquals("Field2", fields.get(1).getPartialFieldName());        assertEquals("Test1", fields.get(0).getValue());        assertEquals("Test2", fields.get(1).getValue());        try (PDDocument pdf = PDDocument.load(new File(TestFDF.class.getResource("/org/apache/pdfbox/pdfparser/SimpleForm2Fields.pdf").toURI()))) {            PDAcroForm acroForm = pdf.getDocumentCatalog().getAcroForm();            acroForm.importFDF(fdf);            assertEquals("Test1", acroForm.getField("Field1").getValueAsString());            assertEquals("Test2", acroForm.getField("Field2").getValueAsString());        }    }}
protected void pdfbox_f8499_0() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
public void pdfbox_f8500_0() throws IOException
{        PDDocument document = new PDDocument();    document.addPage(new PDPage());        ByteArrayOutputStream baos = new ByteArrayOutputStream();    document.save(baos);    document.close();        byte[] pdf = baos.toByteArray();    assertTrue(pdf.length > 200);    assertEquals("%PDF-1.4", new String(Arrays.copyOfRange(pdf, 0, 8), "UTF-8"));    assertEquals("%%EOF\n", new String(Arrays.copyOfRange(pdf, pdf.length - 6, pdf.length), "UTF-8"));        PDDocument loadDoc = PDDocument.load(new ByteArrayInputStream(pdf));    assertEquals(1, loadDoc.getNumberOfPages());    loadDoc.close();}
public void pdfbox_f8501_0() throws IOException
{        PDDocument document = new PDDocument();    document.addPage(new PDPage());        File targetFile = new File(testResultsDir, "pddocument-saveloadfile.pdf");    document.save(targetFile);    document.close();        assertTrue(targetFile.length() > 200);    InputStream in = new FileInputStream(targetFile);    byte[] pdf = IOUtils.toByteArray(in);    in.close();    assertTrue(pdf.length > 200);    assertEquals("%PDF-1.4", new String(Arrays.copyOfRange(pdf, 0, 8), "UTF-8"));    assertEquals("%%EOF\n", new String(Arrays.copyOfRange(pdf, pdf.length - 6, pdf.length), "UTF-8"));        PDDocument loadDoc = PDDocument.load(targetFile);    assertEquals(1, loadDoc.getNumberOfPages());    loadDoc.close();}
public void pdfbox_f8502_0() throws IOException
{    PDDocument document = new PDDocument();        assertEquals(1.4f, document.getVersion());    assertEquals(1.4f, document.getDocument().getVersion());    assertEquals("1.4", document.getDocumentCatalog().getVersion());        document.getDocument().setVersion(1.3f);    document.getDocumentCatalog().setVersion(null);        assertEquals(1.3f, document.getVersion());    assertEquals(1.3f, document.getDocument().getVersion());    assertNull(document.getDocumentCatalog().getVersion());    document.close();        document = new PDDocument();    document.setVersion(1.3f);        assertEquals(1.4f, document.getVersion());    assertEquals(1.4f, document.getDocument().getVersion());    assertEquals("1.4", document.getDocumentCatalog().getVersion());        document.setVersion(1.5f);        assertEquals(1.5f, document.getVersion());        assertEquals(1.4f, document.getDocument().getVersion());        assertEquals("1.5", document.getDocumentCatalog().getVersion());    document.close();}
public void pdfbox_f8503_0() throws FileNotFoundException
{    File f = new File("test.pdf");    PrintWriter pw = new PrintWriter(new FileOutputStream(f));    pw.write("<script language='JavaScript'>");    pw.close();    PDDocument doc = null;    try {        doc = PDDocument.load(f);        fail("parsing should fail");    } catch (IOException ex) {        } finally {        assertNull(doc);    }    boolean deleted = f.delete();    assertTrue("delete bad file failed after failed load()", deleted);}
public void pdfbox_f8504_0() throws IOException
{    File f = new File("test.pdf");    PDDocument doc = new PDDocument();    doc.addPage(new PDPage());    doc.save(f);    doc.close();    PDDocument.load(f).close();    boolean deleted = f.delete();    assertTrue("delete good file failed after successful load() and close()", deleted);}
public void pdfbox_f8505_0() throws IOException
{    Locale defaultLocale = Locale.getDefault();    Locale arabicLocale = new Locale.Builder().setLanguageTag("ar-EG-u-nu-arab").build();    Locale.setDefault(arabicLocale);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    PDDocument doc = new PDDocument();    doc.addPage(new PDPage());    doc.save(baos);    doc.close();    PDDocument.load(new ByteArrayInputStream(baos.toByteArray())).close();    Locale.setDefault(defaultLocale);}
public void pdfbox_f8506_0() throws IOException
{    PDDocument doc = null;    try {        doc = PDDocument.load(TestPDDocumentCatalog.class.getResourceAsStream("test_pagelabels.pdf"));        PDDocumentCatalog cat = doc.getDocumentCatalog();        String[] labels = cat.getPageLabels().getLabelsByPageIndices();        assertEquals(12, labels.length);        assertEquals("A1", labels[0]);        assertEquals("A2", labels[1]);        assertEquals("A3", labels[2]);        assertEquals("i", labels[3]);        assertEquals("ii", labels[4]);        assertEquals("iii", labels[5]);        assertEquals("iv", labels[6]);        assertEquals("v", labels[7]);        assertEquals("vi", labels[8]);        assertEquals("vii", labels[9]);        assertEquals("Appendix I", labels[10]);        assertEquals("Appendix II", labels[11]);    } finally {        if (doc != null) {            doc.close();        }    }}
public void pdfbox_f8507_0() throws IOException
{    PDDocument doc = null;    try {        doc = PDDocument.load(TestPDDocumentCatalog.class.getResourceAsStream("badpagelabels.pdf"));        PDDocumentCatalog cat = doc.getDocumentCatalog();                cat.getPageLabels().getLabelsByPageIndices();    } finally {        if (doc != null) {            doc.close();        }    }}
public void pdfbox_f8508_0() throws IOException
{    PDDocument doc = null;    try {        doc = PDDocument.load(TestPDDocumentCatalog.class.getResourceAsStream("test.unc.pdf"));        assertEquals(4, doc.getNumberOfPages());    } finally {        if (doc != null) {            doc.close();        }    }}
public void pdfbox_f8509_0() throws IOException
{    PDDocument doc = null;    InputStream colorProfile = null;    try {        doc = PDDocument.load(TestPDDocumentCatalog.class.getResourceAsStream("test.unc.pdf"));        PDDocumentCatalog catalog = doc.getDocumentCatalog();                List<PDOutputIntent> outputIntents = catalog.getOutputIntents();        assertTrue(outputIntents.isEmpty());                colorProfile = TestPDDocumentCatalog.class.getResourceAsStream("sRGB.icc");                PDOutputIntent oi = new PDOutputIntent(doc, colorProfile);        oi.setInfo("sRGB IEC61966-2.1");        oi.setOutputCondition("sRGB IEC61966-2.1");        oi.setOutputConditionIdentifier("sRGB IEC61966-2.1");        oi.setRegistryName("http://www.color.org");        doc.getDocumentCatalog().addOutputIntent(oi);                outputIntents = catalog.getOutputIntents();        assertEquals(1, outputIntents.size());                catalog.setOutputIntents(outputIntents);        outputIntents = catalog.getOutputIntents();        assertEquals(1, outputIntents.size());    } finally {        if (doc != null) {            doc.close();        }        if (colorProfile != null) {            colorProfile.close();        }    }}
public void pdfbox_f8510_0() throws IOException
{        PDDocument doc = new PDDocument();    doc.getDocumentCatalog().getCOSObject().setBoolean(COSName.OPEN_ACTION, false);    assertNull(doc.getDocumentCatalog().getOpenAction());}
public void pdfbox_f8511_0() throws Exception
{        try (PDDocument doc = PDDocument.load(new File("src/test/resources/input/hello3.pdf"))) {        PDDocumentInformation info = doc.getDocumentInformation();        assertEquals("Wrong author", "Brian Carrier", info.getAuthor());        assertNotNull("Wrong creationDate", info.getCreationDate());        assertEquals("Wrong creator", "Acrobat PDFMaker 8.1 for Word", info.getCreator());        assertNull("Wrong keywords", info.getKeywords());        assertNotNull("Wrong modificationDate", info.getModificationDate());        assertEquals("Wrong producer", "Acrobat Distiller 8.1.0 (Windows)", info.getProducer());        assertNull("Wrong subject", info.getSubject());        assertNull("Wrong trapped", info.getTrapped());        List<String> expectedMetadataKeys = Arrays.asList("CreationDate", "Author", "Creator", "Producer", "ModDate", "Company", "SourceModified", "Title");        assertEquals("Wrong metadata key count", expectedMetadataKeys.size(), info.getMetadataKeys().size());        for (String key : expectedMetadataKeys) {            assertTrue("Missing metadata key:" + key, info.getMetadataKeys().contains(key));        }                assertEquals("Wrong company", "Basis Technology Corp.", info.getCustomMetadataValue("Company"));        assertEquals("Wrong sourceModified", "D:20080819181502", info.getCustomMetadataValue("SourceModified"));    }}
public void pdfbox_f8512_0() throws Exception
{    try (PDDocument doc = PDDocument.load(TestPDDocumentInformation.class.getResourceAsStream("PDFBOX-3068.pdf"))) {        PDDocumentInformation documentInformation = doc.getDocumentInformation();        assertEquals("Title", documentInformation.getTitle());    }}
public void pdfbox_f8513_0()
{    COSDictionary mockedPageWithAnnotations = new COSDictionary();    COSArray annotsDictionnary = new COSArray();    annotsDictionnary.add(new PDAnnotationRubberStamp().getCOSObject());    annotsDictionnary.add(new PDAnnotationSquare().getCOSObject());    annotsDictionnary.add(new PDAnnotationLink().getCOSObject());    mockedPageWithAnnotations.setItem(COSName.ANNOTS, annotsDictionnary);    page = new PDPage(mockedPageWithAnnotations);}
public void pdfbox_f8514_0() throws IOException
{    List<PDAnnotation> annotations = page.getAnnotations();    Assert.assertEquals(3, annotations.size());    Assert.assertTrue(annotations.get(0) instanceof PDAnnotationRubberStamp);    Assert.assertTrue(annotations.get(1) instanceof PDAnnotationSquare);    Assert.assertTrue(annotations.get(2) instanceof PDAnnotationLink);}
public void pdfbox_f8515_0() throws IOException
{    List<PDAnnotation> annotations = page.getAnnotations(annotation -> false);    Assert.assertEquals(0, annotations.size());}
public void pdfbox_f8516_0() throws IOException
{    List<PDAnnotation> annotations = page.getAnnotations(annotation -> (annotation instanceof PDAnnotationLink || annotation instanceof PDAnnotationSquare));    Assert.assertEquals(2, annotations.size());    Assert.assertTrue(annotations.get(0) instanceof PDAnnotationSquare);    Assert.assertTrue(annotations.get(1) instanceof PDAnnotationLink);}
public void pdfbox_f8517_0() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, true)) {                        contentStream.setNonStrokingColor(0.1f, 0.2f, 0.3f, 0.4f);        }                PDFStreamParser parser = new PDFStreamParser(page.getContents());        parser.parse();        java.util.List<Object> pageTokens = parser.getTokens();                                                        assertEquals(0.1f, ((COSFloat) pageTokens.get(0)).floatValue());        assertEquals(0.2f, ((COSFloat) pageTokens.get(1)).floatValue());        assertEquals(0.3f, ((COSFloat) pageTokens.get(2)).floatValue());        assertEquals(0.4f, ((COSFloat) pageTokens.get(3)).floatValue());        assertEquals("k", ((Operator) pageTokens.get(4)).getName());                page = new PDPage();        doc.addPage(page);        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false)) {                        contentStream.setStrokingColor(0.5f, 0.6f, 0.7f, 0.8f);        }                parser = new PDFStreamParser(page.getContents());        parser.parse();        pageTokens = parser.getTokens();                                                        assertEquals(0.5f, ((COSFloat) pageTokens.get(0)).floatValue());        assertEquals(0.6f, ((COSFloat) pageTokens.get(1)).floatValue());        assertEquals(0.7f, ((COSFloat) pageTokens.get(2)).floatValue());        assertEquals(0.8f, ((COSFloat) pageTokens.get(3)).floatValue());        assertEquals("K", ((Operator) pageTokens.get(4)).getName());    }}
public void pdfbox_f8518_0() throws IOException
{    PDPage page = new PDPage();    PDFStreamParser parser = new PDFStreamParser(page.getContents());    parser.parse();    List<Object> tokens = parser.getTokens();    assertEquals(0, tokens.size());}
public void pdfbox_f8519_0() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, true);        contentStream.close();        contentStream.close();    }}
public void pdfbox_f8520_0() throws IOException, URISyntaxException
{    try (PDDocument doc = PDDocument.load(new File(this.getClass().getResource("/org/apache/pdfbox/pdmodel/interactive/pagenavigation/transitions_test.pdf").toURI()))) {        PDTransition firstTransition = doc.getPages().get(0).getTransition();        assertEquals(PDTransitionStyle.Glitter.name(), firstTransition.getStyle());        assertEquals(2, firstTransition.getDuration(), 0);        assertEquals(PDTransitionDirection.TOP_LEFT_TO_BOTTOM_RIGHT.getCOSBase(), firstTransition.getDirection());    }}
public void pdfbox_f8521_0() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();        try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage();        document.addPage(page);        PDTransition transition = new PDTransition(PDTransitionStyle.Fly);        transition.setDirection(PDTransitionDirection.NONE);        transition.setFlyScale(0.5f);        page.setTransition(transition, 2);        document.save(baos);    }        try (PDDocument doc = PDDocument.load(baos.toByteArray())) {        PDPage page = doc.getPages().get(0);        PDTransition loadedTransition = page.getTransition();        assertEquals(PDTransitionStyle.Fly.name(), loadedTransition.getStyle());        assertEquals(2, page.getCOSObject().getFloat(COSName.DUR), 0);        assertEquals(PDTransitionDirection.NONE.getCOSBase(), loadedTransition.getDirection());    }}
public void pdfbox_f8522_0() throws IOException
{    if (doc != null) {        doc.close();    }}
public void pdfbox_f8523_0() throws IOException
{    doc = PDDocument.load(TestPDPageTree.class.getResourceAsStream("with_outline.pdf"));    PDDocumentOutline outline = doc.getDocumentCatalog().getDocumentOutline();    for (PDOutlineItem current : outline.children()) {        if (current.getTitle().contains("Second")) {            assertEquals(2, doc.getPages().indexOf(current.findDestinationPage(doc)));        }    }}
public void pdfbox_f8524_0() throws IOException
{    doc = PDDocument.load(TestPDPageTree.class.getResourceAsStream("with_outline.pdf"));    for (int i = 0; i < doc.getNumberOfPages(); i++) {        assertEquals(i, doc.getPages().indexOf(doc.getPage(i)));    }}
public void pdfbox_f8525_0() throws IOException
{    doc = PDDocument.load(TestPDPageTree.class.getResourceAsStream("page_tree_multiple_levels.pdf"));    for (int i = 0; i < doc.getNumberOfPages(); i++) {        assertEquals(i, doc.getPages().indexOf(doc.getPage(i)));    }}
public void pdfbox_f8526_0() throws IOException
{    doc = PDDocument.load(TestPDPageTree.class.getResourceAsStream("with_outline.pdf"));    assertEquals(-1, doc.getPages().indexOf(new PDPage()));}
public static Collection<Object[]> pdfbox_f8527_0()
{    File[] testFiles = new File(inDir).listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return (name.toLowerCase().endsWith(".pdf") || name.toLowerCase().endsWith(".ai"));        }    });    List<Object[]> params = new ArrayList<>();    for (File file : testFiles) {        params.add(new Object[] { file.getName() });    }    return params;}
public boolean pdfbox_f8528_0(File dir, String name)
{    return (name.toLowerCase().endsWith(".pdf") || name.toLowerCase().endsWith(".ai"));}
public void pdfbox_f8529_0() throws IOException
{    new File(outDir).mkdirs();    if (!doTestFile(new File(inDir, filename), inDir, outDir)) {        fail("failure, see test log for details");    }}
private BufferedImage pdfbox_f8530_0(int minWidth, int minHeight, int maxWidth, int maxHeight)
{    BufferedImage bim3 = new BufferedImage(maxWidth, maxHeight, BufferedImage.TYPE_INT_RGB);    Graphics graphics = bim3.getGraphics();    if (minWidth != maxWidth || minHeight != maxHeight) {        graphics.setColor(Color.BLACK);        graphics.fillRect(0, 0, maxWidth, maxHeight);    }    graphics.setColor(Color.WHITE);    graphics.fillRect(0, 0, minWidth, minHeight);    graphics.dispose();    return bim3;}
private BufferedImage pdfbox_f8531_0(BufferedImage bim1, BufferedImage bim2) throws IOException
{    int minWidth = Math.min(bim1.getWidth(), bim2.getWidth());    int minHeight = Math.min(bim1.getHeight(), bim2.getHeight());    int maxWidth = Math.max(bim1.getWidth(), bim2.getWidth());    int maxHeight = Math.max(bim1.getHeight(), bim2.getHeight());    BufferedImage bim3 = null;    if (minWidth != maxWidth || minHeight != maxHeight) {        bim3 = createEmptyDiffImage(minWidth, minHeight, maxWidth, maxHeight);    }    for (int x = 0; x < minWidth; ++x) {        for (int y = 0; y < minHeight; ++y) {            int rgb1 = bim1.getRGB(x, y);            int rgb2 = bim2.getRGB(x, y);            if (rgb1 != rgb2 &&             (Math.abs((rgb1 & 0xFF) - (rgb2 & 0xFF)) > 3 || Math.abs(((rgb1 >> 8) & 0xFF) - ((rgb2 >> 8) & 0xFF)) > 3 || Math.abs(((rgb1 >> 16) & 0xFF) - ((rgb2 >> 16) & 0xFF)) > 3)) {                if (bim3 == null) {                    bim3 = createEmptyDiffImage(minWidth, minHeight, maxWidth, maxHeight);                }                int r = Math.abs((rgb1 & 0xFF) - (rgb2 & 0xFF));                int g = Math.abs((rgb1 & 0xFF00) - (rgb2 & 0xFF00));                int b = Math.abs((rgb1 & 0xFF0000) - (rgb2 & 0xFF0000));                bim3.setRGB(x, y, 0xFFFFFF - (r | g | b));            } else {                if (bim3 != null) {                    bim3.setRGB(x, y, Color.WHITE.getRGB());                }            }        }    }    return bim3;}
public boolean pdfbox_f8532_1(final File file, String inDir, String outDir) throws IOException
{    PDDocument document = null;    boolean failed = false;        try {        new FileOutputStream(new File(outDir, file.getName() + ".parseerror")).close();        document = PDDocument.load(file, (String) null);        String outputPrefix = outDir + '/' + file.getName() + "-";        int numPages = document.getNumberOfPages();        if (numPages < 1) {            failed = true;                    } else {            new File(outDir, file.getName() + ".parseerror").delete();        }                PDFRenderer renderer = new PDFRenderer(document);        for (int i = 0; i < numPages; i++) {            String fileName = outputPrefix + (i + 1) + ".png";            new FileOutputStream(new File(fileName + ".rendererror")).close();                        BufferedImage image = renderer.renderImageWithDPI(i, 96);            new File(fileName + ".rendererror").delete();                        new FileOutputStream(new File(fileName + ".writeerror")).close();            ImageIO.write(image, "PNG", new File(fileName));            new File(fileName + ".writeerror").delete();        }                new FileOutputStream(new File(outDir, file.getName() + ".saveerror")).close();        File tmpFile = File.createTempFile("pdfbox", ".pdf");        document.setAllSecurityToBeRemoved(true);        document.save(tmpFile);        new File(outDir, file.getName() + ".saveerror").delete();        new FileOutputStream(new File(outDir, file.getName() + ".reloaderror")).close();        PDDocument.load(tmpFile, (String) null).close();        new File(outDir, file.getName() + ".reloaderror").delete();        tmpFile.delete();    } catch (IOException e) {        failed = true;                throw e;    } finally {        if (document != null) {            document.close();        }    }            try {        new File(outDir + file.getName() + ".cmperror").delete();        File[] outFiles = new File(outDir).listFiles(new FilenameFilter() {            @Override            public boolean accept(File dir, String name) {                return (name.endsWith(".png") && name.startsWith(file.getName(), 0)) && !name.endsWith(".png-diff.png");            }        });        if (outFiles.length == 0) {            failed = true;                    }        for (File outFile : outFiles) {                        new File(outFile.getAbsolutePath() + "-diff.png").delete();            File inFile = new File(inDir + '/' + outFile.getName());            if (!inFile.exists()) {                failed = true;                            } else if (!filesAreIdentical(outFile, inFile)) {                                                BufferedImage bim3 = diffImages(ImageIO.read(inFile), ImageIO.read(outFile));                if (bim3 != null) {                    failed = true;                                        ImageIO.write(bim3, "png", new File(outFile.getAbsolutePath() + "-diff.png"));                    System.err.println("Files differ: " + inFile.getAbsolutePath() + "\n" + "              " + outFile.getAbsolutePath());                } else {                                                            outFile.delete();                }            } else {                                                outFile.delete();            }        }    } catch (Exception e) {        new FileOutputStream(new File(outDir, file.getName() + ".cmperror")).close();        failed = true;            }    return !failed;}
public boolean pdfbox_f8533_0(File dir, String name)
{    return (name.endsWith(".png") && name.startsWith(file.getName(), 0)) && !name.endsWith(".png-diff.png");}
private boolean pdfbox_f8534_0(File left, File right) throws IOException
{    /* -- I reworked ASSERT's into IF statement -- dwilson         assert left != null;         assert right != null;         assert left.exists();         assert right.exists();         */    if (left != null && right != null && left.exists() && right.exists()) {        if (left.length() != right.length()) {            return false;        }        FileInputStream lin = new FileInputStream(left);        FileInputStream rin = new FileInputStream(right);        try {            byte[] lbuffer = new byte[4096];            byte[] rbuffer = new byte[lbuffer.length];            int lcount;            while ((lcount = lin.read(lbuffer)) > 0) {                int bytesRead = 0;                int rcount;                while ((rcount = rin.read(rbuffer, bytesRead, lcount - bytesRead)) > 0) {                    bytesRead += rcount;                }                for (int byteIndex = 0; byteIndex < lcount; byteIndex++) {                    if (lbuffer[byteIndex] != rbuffer[byteIndex]) {                        return false;                    }                }            }        } finally {            lin.close();            rin.close();        }        return true;    } else {        return false;    }}
public static Collection<Object[]> pdfbox_f8535_0()
{    File[] testFiles = new File(INPUT_DIR).listFiles((dir, name) -> (name.endsWith(".pdf") || name.endsWith(".ai")));    return Stream.of(testFiles).map(file -> new Object[] { file.getName() }).collect(Collectors.toList());}
public void pdfbox_f8536_0() throws IOException
{    File file = new File(INPUT_DIR, fileName);    PDDocument document = PDDocument.load(file);    PDFRenderer renderer = new PDFRenderer(document);    renderer.renderImage(0);                    document.close();}
public void pdfbox_f8537_0() throws IOException
{    if (!outDir.exists()) {        if (!outDir.mkdirs()) {            throw (new IOException("Error creating " + outDir.getAbsolutePath() + " directory"));        }    }    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    stripper = new PDFTextStripper();    stripper.setLineSeparator("\n");}
public void pdfbox_f8538_0() throws IOException
{    File testFile = new File(IN_DIR, NAME_OF_PDF);    doTestFile(testFile, outDir, false, true);}
public void pdfbox_f8539_0() throws IOException
{    File testFile = new File(IN_DIR, NAME_OF_PDF);    doTestFile(testFile, outDir, false, false);}
public void pdfbox_f8540_0() throws IOException
{    document.close();}
public void pdfbox_f8541_1(File inFile, File outDir, boolean bLogResult, boolean bSort) throws IOException
{    if (bSort) {            } else {            }    if (!outDir.exists()) {        if (!outDir.mkdirs()) {            throw (new IOException("Error creating " + outDir.getAbsolutePath() + " directory"));        }    }    PDDocument document = PDDocument.load(inFile);    try {        File outFile;        File expectedFile;        if (bSort) {            outFile = new File(outDir, inFile.getName() + "-sorted.txt");            expectedFile = new File(inFile.getParentFile(), inFile.getName() + "-sorted.txt");        } else {            outFile = new File(outDir, inFile.getName() + ".txt");            expectedFile = new File(inFile.getParentFile(), inFile.getName() + ".txt");        }        OutputStream os = new FileOutputStream(outFile);        try {            Writer writer = new OutputStreamWriter(os, ENCODING);            try {                                stripper.setSortByPosition(bSort);                stripper.writeText(document, writer);            } finally {                                writer.close();            }        } finally {            os.close();        }        if (bLogResult) {                                }        if (!expectedFile.exists()) {            this.bFail = true;            fail("FAILURE: Input verification file: " + expectedFile.getAbsolutePath() + " did not exist");            return;        }        LineNumberReader expectedReader = new LineNumberReader(new InputStreamReader(new FileInputStream(expectedFile), ENCODING));        LineNumberReader actualReader = new LineNumberReader(new InputStreamReader(new FileInputStream(outFile), ENCODING));        while (true) {            String expectedLine = expectedReader.readLine();            while (expectedLine != null && expectedLine.trim().length() == 0) {                expectedLine = expectedReader.readLine();            }            String actualLine = actualReader.readLine();            while (actualLine != null && actualLine.trim().length() == 0) {                actualLine = actualReader.readLine();            }            if (!stringsEqual(expectedLine, actualLine)) {                this.bFail = true;                fail("FAILURE: Line mismatch for file " + inFile.getName() + " (sort = " + bSort + ")" + " at expected line: " + expectedReader.getLineNumber() + " at actual line: " + actualReader.getLineNumber() + "\nexpected line was: \"" + expectedLine + "\"" + "\nactual line was:   \"" + actualLine + "\"" + "\n");                                    }            if (expectedLine == null || actualLine == null) {                break;            }        }        expectedReader.close();        actualReader.close();    } finally {        document.close();    }}
private boolean pdfbox_f8542_1(String expected, String actual)
{    boolean equals = true;    if ((expected == null) && (actual == null)) {        return true;    } else if (expected != null && actual != null) {        expected = expected.trim();        actual = actual.trim();        char[] expectedArray = expected.toCharArray();        char[] actualArray = actual.toCharArray();        int expectedIndex = 0;        int actualIndex = 0;        while (expectedIndex < expectedArray.length && actualIndex < actualArray.length) {            if (expectedArray[expectedIndex] != actualArray[actualIndex]) {                equals = false;                                break;            }            expectedIndex = skipWhitespace(expectedArray, expectedIndex);            actualIndex = skipWhitespace(actualArray, actualIndex);            expectedIndex++;            actualIndex++;        }        if (equals) {            if (expectedIndex != expectedArray.length) {                equals = false;                            }            if (actualIndex != actualArray.length) {                equals = false;                            }        }    } else {        equals = (expected == null && actual != null && actual.trim().isEmpty()) || (actual == null && expected != null && expected.trim().isEmpty());    }    return equals;}
private int pdfbox_f8543_0(char[] array, int index)
{        if (array[index] == ' ' || array[index] > 256) {        while (index < array.length && (array[index] == ' ' || array[index] > 256)) {            index++;        }        index--;    }    return index;}
private boolean pdfbox_f8545_1(String expected, String actual)
{    boolean equals = true;    if ((expected == null) && (actual == null)) {        return true;    } else if (expected != null && actual != null) {        expected = expected.trim();        actual = actual.trim();        char[] expectedArray = expected.toCharArray();        char[] actualArray = actual.toCharArray();        int expectedIndex = 0;        int actualIndex = 0;        while (expectedIndex < expectedArray.length && actualIndex < actualArray.length) {            if (expectedArray[expectedIndex] != actualArray[actualIndex]) {                equals = false;                                break;            }            expectedIndex = skipWhitespace(expectedArray, expectedIndex);            actualIndex = skipWhitespace(actualArray, actualIndex);            expectedIndex++;            actualIndex++;        }        if (equals) {            if (expectedIndex != expectedArray.length) {                equals = false;                            }            if (actualIndex != actualArray.length) {                equals = false;                            }        }    } else {        equals = (expected == null && actual != null && actual.trim().isEmpty()) || (actual == null && expected != null && expected.trim().isEmpty());    }    return equals;}
private int pdfbox_f8546_0(char[] array, int index)
{        if (array[index] == ' ' || array[index] > 256) {        while (index < array.length && (array[index] == ' ' || array[index] > 256)) {            index++;        }        index--;    }    return index;}
public void pdfbox_f8547_1(File inFile, File outDir, boolean bLogResult, boolean bSort) throws Exception
{    if (bSort) {            } else {            }    if (!outDir.exists()) {        if (!outDir.mkdirs()) {            throw (new Exception("Error creating " + outDir.getAbsolutePath() + " directory"));        }    }        try (PDDocument document = PDDocument.load(inFile)) {        File outFile;        File diffFile;        File expectedFile;        if (bSort) {            outFile = new File(outDir, inFile.getName() + "-sorted.txt");            diffFile = new File(outDir, inFile.getName() + "-sorted-diff.txt");            expectedFile = new File(inFile.getParentFile(), inFile.getName() + "-sorted.txt");        } else {            outFile = new File(outDir, inFile.getName() + ".txt");            diffFile = new File(outDir, inFile.getName() + "-diff.txt");            expectedFile = new File(inFile.getParentFile(), inFile.getName() + ".txt");        }                diffFile.delete();        try (OutputStream os = new FileOutputStream(outFile)) {            os.write(0xEF);            os.write(0xBB);            os.write(0xBF);            try (Writer writer = new BufferedWriter(new OutputStreamWriter(os, ENCODING))) {                                stripper.setSortByPosition(bSort);                stripper.writeText(document, writer);                        }        }        if (bLogResult) {                                }        if (!expectedFile.exists()) {            this.bFail = true;                        return;        }        boolean localFail = false;        try (LineNumberReader expectedReader = new LineNumberReader(new InputStreamReader(new FileInputStream(expectedFile), ENCODING));            LineNumberReader actualReader = new LineNumberReader(new InputStreamReader(new FileInputStream(outFile), ENCODING))) {            while (true) {                String expectedLine = expectedReader.readLine();                while (expectedLine != null && expectedLine.trim().length() == 0) {                    expectedLine = expectedReader.readLine();                }                String actualLine = actualReader.readLine();                while (actualLine != null && actualLine.trim().length() == 0) {                    actualLine = actualReader.readLine();                }                if (!stringsEqual(expectedLine, actualLine)) {                    this.bFail = true;                    localFail = true;                                                                    }                if (expectedLine == null || actualLine == null) {                    break;                }            }        }        if (!localFail) {            outFile.delete();        } else {                        List<String> original = fileToLines(expectedFile);            List<String> revised = fileToLines(outFile);                        Patch patch = DiffUtils.diff(original, revised);            try (PrintStream diffPS = new PrintStream(diffFile, ENCODING)) {                for (Object delta : patch.getDeltas()) {                    if (delta instanceof ChangeDelta) {                        ChangeDelta cdelta = (ChangeDelta) delta;                        diffPS.println("Org: " + cdelta.getOriginal());                        diffPS.println("New: " + cdelta.getRevised());                        diffPS.println();                    } else if (delta instanceof DeleteDelta) {                        DeleteDelta ddelta = (DeleteDelta) delta;                        diffPS.println("Org: " + ddelta.getOriginal());                        diffPS.println("New: " + ddelta.getRevised());                        diffPS.println();                    } else if (delta instanceof InsertDelta) {                        InsertDelta idelta = (InsertDelta) delta;                        diffPS.println("Org: " + idelta.getOriginal());                        diffPS.println("New: " + idelta.getRevised());                        diffPS.println();                    } else {                        diffPS.println(delta);                    }                }            }        }    }}
private static List<String> pdfbox_f8548_0(File file)
{    List<String> lines = new LinkedList<>();    String line;    try {        try (BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(file), ENCODING))) {            while ((line = in.readLine()) != null) {                lines.add(line);            }        }    } catch (IOException e) {        e.printStackTrace();    }    return lines;}
private int pdfbox_f8549_0(PDDocument doc, PDOutlineItem oi) throws IOException
{    PDPageDestination pageDest = (PDPageDestination) oi.getDestination();        int indexOfPage = doc.getPages().indexOf(oi.findDestinationPage(doc));    int pageNum = pageDest.retrievePageNumber();    assertEquals(indexOfPage, pageNum);    return pageNum;}
public void pdfbox_f8550_0() throws IOException, URISyntaxException
{    PDDocument doc = PDDocument.load(new File(TestPDPageTree.class.getResource("with_outline.pdf").toURI()));    PDDocumentOutline outline = doc.getDocumentCatalog().getDocumentOutline();    Iterable<PDOutlineItem> children = outline.children();    Iterator<PDOutlineItem> it = children.iterator();    PDOutlineItem oi0 = it.next();    PDOutlineItem oi2 = it.next();    PDOutlineItem oi3 = it.next();    PDOutlineItem oi4 = it.next();    assertEquals(0, findOutlineItemDestPageNum(doc, oi0));    assertEquals(2, findOutlineItemDestPageNum(doc, oi2));    assertEquals(3, findOutlineItemDestPageNum(doc, oi3));    assertEquals(4, findOutlineItemDestPageNum(doc, oi4));    String textFull = stripper.getText(doc);    assertFalse(textFull.isEmpty());    String expectedTextFull = "First level 1\n" + "First level 2\n" + "Fist level 3\n" + "Some content\n" + "Some other content\n" + "Second at level 1\n" + "Second level 2\n" + "Content\n" + "Third level 1\n" + "Third level 2\n" + "Third level 3\n" + "Content\n" + "Fourth level 1\n" + "Content\n" + "Content\n";    assertEquals(expectedTextFull, textFull.replaceAll("\r", ""));            stripper.setStartBookmark(oi2);    stripper.setEndBookmark(oi3);    String textoi23 = stripper.getText(doc);    assertFalse(textoi23.isEmpty());    assertFalse(textoi23.equals(textFull));    String expectedTextoi23 = "Second at level 1\n" + "Second level 2\n" + "Content\n" + "Third level 1\n" + "Third level 2\n" + "Third level 3\n" + "Content\n";    assertEquals(expectedTextoi23, textoi23.replaceAll("\r", ""));            stripper.setStartBookmark(null);    stripper.setEndBookmark(null);    stripper.setStartPage(3);    stripper.setEndPage(4);    String textp34 = stripper.getText(doc);    assertFalse(textp34.isEmpty());    assertFalse(textoi23.equals(textFull));    assertTrue(textoi23.equals(textp34));            stripper.setStartBookmark(oi2);    stripper.setEndBookmark(oi2);    String textoi2 = stripper.getText(doc);    assertFalse(textoi2.isEmpty());    assertFalse(textoi2.equals(textoi23));    assertFalse(textoi23.equals(textFull));    String expectedTextoi2 = "Second at level 1\n" + "Second level 2\n" + "Content\n";    assertEquals(expectedTextoi2, textoi2.replaceAll("\r", ""));            stripper.setStartBookmark(null);    stripper.setEndBookmark(null);    stripper.setStartPage(3);    stripper.setEndPage(3);    String textp3 = stripper.getText(doc);    assertFalse(textp3.isEmpty());    assertFalse(textp3.equals(textp34));    assertFalse(textoi23.equals(textFull));    assertTrue(textoi2.equals(textp3));        PDOutlineItem oiOrphan = new PDOutlineItem();    stripper.setStartBookmark(oiOrphan);    stripper.setEndBookmark(oiOrphan);    String textOiOrphan = stripper.getText(doc);    assertTrue(textOiOrphan.isEmpty());}
private void pdfbox_f8551_0(File inDir, File outDir) throws Exception
{    File[] testFiles = inDir.listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return (name.endsWith(".pdf"));        }    });    for (File testFile : testFiles) {                doTestFile(testFile, outDir, false, false);                doTestFile(testFile, outDir, false, true);    }}
public boolean pdfbox_f8552_0(File dir, String name)
{    return (name.endsWith(".pdf"));}
public void pdfbox_f8553_0() throws Exception
{    String filename = System.getProperty("org.apache.pdfbox.util.TextStripper.file");    File inDir = new File("src/test/resources/input");    File outDir = new File("target/test-output");    File inDirExt = new File("target/test-input-ext");    File outDirExt = new File("target/test-output-ext");    if ((filename == null) || (filename.length() == 0)) {        doTestDir(inDir, outDir);        if (inDirExt.exists()) {            doTestDir(inDirExt, outDirExt);        }    } else {                doTestFile(new File(inDir, filename), outDir, true, false);                doTestFile(new File(inDir, filename), outDir, true, true);    }    if (this.bFail) {        fail("One or more failures, see test log for details");    }}
public static Test pdfbox_f8554_0()
{    return new TestSuite(TestTextStripper.class);}
public static void pdfbox_f8555_0(String[] args)
{    String[] arg = { TestTextStripper.class.getName() };    junit.textui.TestRunner.main(arg);}
public void pdfbox_f8556_0()
{    Matrix m = new Matrix(2, 4, 5, 8, 2, 0);    COSArray toCOSArray = m.toCOSArray();    assertEquals(new COSFloat(2), toCOSArray.get(0));    assertEquals(new COSFloat(4), toCOSArray.get(1));    assertEquals(new COSFloat(5), toCOSArray.get(2));    assertEquals(new COSFloat(8), toCOSArray.get(3));    assertEquals(new COSFloat(2), toCOSArray.get(4));    assertEquals(new COSFloat(0), toCOSArray.get(5));}
public void pdfbox_f8557_0() throws Exception
{    TimeZone timezone = TimeZone.getDefault();    TimeZone.setDefault(TimeZone.getTimeZone("UTC"));    assertCalendarEquals(new GregorianCalendar(2005, 4, 12), DateConverter.toCalendar("D:05/12/2005"));    assertCalendarEquals(new GregorianCalendar(2005, 4, 12, 15, 57, 16), DateConverter.toCalendar("5/12/2005 15:57:16"));    TimeZone.setDefault(timezone);        assertNull(DateConverter.toCalendar((String) null));}
public void pdfbox_f8558_0(Calendar expect, Calendar was)
{    assertEquals(expect.getTimeInMillis(), was.getTimeInMillis());    assertEquals(expect.getTimeZone().getRawOffset(), was.getTimeZone().getRawOffset());}
public void pdfbox_f8559_0() throws IOException
{    Calendar c = DateConverter.toCalendar("D:20050526205258+01'00'");    assertEquals(2005, c.get(Calendar.YEAR));    assertEquals(05 - 1, c.get(Calendar.MONTH));    assertEquals(26, c.get(Calendar.DAY_OF_MONTH));    assertEquals(20, c.get(Calendar.HOUR_OF_DAY));    assertEquals(52, c.get(Calendar.MINUTE));    assertEquals(58, c.get(Calendar.SECOND));    assertEquals(0, c.get(Calendar.MILLISECOND));}
private static void pdfbox_f8560_0(int yr, int mon, int day, int hr, int min, int sec, int offsetHours, int offsetMinutes, String orig) throws Exception
{    String pdfDate = String.format(Locale.US, "D:%04d%02d%02d%02d%02d%02d%+03d'%02d'", yr, mon, day, hr, min, sec, offsetHours, offsetMinutes);    String iso8601Date = String.format(Locale.US, "%04d-%02d-%02d" + "T%02d:%02d:%02d%+03d:%02d", yr, mon, day, hr, min, sec, offsetHours, offsetMinutes);    Calendar cal = DateConverter.toCalendar(orig);    if (cal != null) {        assertEquals(iso8601Date, DateConverter.toISO8601(cal));        assertEquals(pdfDate, DateConverter.toString(cal));    }        cal = DateConverter.toCalendar(orig);    if (yr == BAD) {        assertEquals(null, cal);    } else {        assertEquals(pdfDate, DateConverter.toString(cal));    }}
public void pdfbox_f8561_0() throws Exception
{    int year = Calendar.getInstance().get(Calendar.YEAR);    checkParse(2010, 4, 23, 0, 0, 0, 0, 0, "D:20100423");    checkParse(2011, 4, 23, 0, 0, 0, 0, 0, "20110423");    checkParse(2012, 1, 1, 0, 0, 0, 0, 0, "D:2012");    checkParse(2013, 1, 1, 0, 0, 0, 0, 0, "2013");        checkParse(2001, 1, 31, 10, 33, 0, +1, 0, "2001-01-31T10:33+01:00  ");        checkParse(2002, 5, 12, 9, 47, 0, 0, 0, "9:47 5/12/2002");        checkParse(2003, 12, 17, 2, 2, 3, 0, 0, "200312172:2:3");        checkParse(2009, 3, 19, 20, 1, 22, 0, 0, "  20090319 200122");    checkParse(2014, 4, 1, 0, 0, 0, +2, 0, "20140401+0200");        checkParse(2115, 1, 11, 0, 0, 0, 0, 0, "Friday, January 11, 2115");        checkParse(1915, 1, 11, 0, 0, 0, 0, 0, "Monday, Jan 11, 1915");        checkParse(2215, 1, 11, 0, 0, 0, 0, 0, "Wed, January 11, 2215");        checkParse(2015, 1, 11, 0, 0, 0, 0, 0, " Sun, January 11, 2015 ");    checkParse(2016, 4, 1, 0, 0, 0, +4, 0, "20160401+04'00'");    checkParse(2017, 4, 1, 0, 0, 0, +9, 0, "20170401+09'00'");    checkParse(2017, 4, 1, 0, 0, 0, +9, 30, "20170401+09'30'");    checkParse(2018, 4, 1, 0, 0, 0, -2, 0, "20180401-02'00'");    checkParse(2019, 4, 1, 6, 1, 1, -11, 0, "20190401 6:1:1 -1100");    checkParse(2020, 5, 26, 11, 25, 10, 0, 0, "26 May 2020 11:25:10");    checkParse(2021, 5, 26, 11, 23, 0, 0, 0, "26 May 2021 11:23");        checkParse(2016, 4, 1, 0, 0, 0, +4, 30, "20160401+04'30'");    checkParse(2017, 4, 1, 0, 0, 0, +9, 30, "20170401+09'30'");    checkParse(2018, 4, 1, 0, 0, 0, -2, 30, "20180401-02'30'");    checkParse(2019, 4, 1, 6, 1, 1, -11, 30, "20190401 6:1:1 -1130");    checkParse(2000, 2, 29, 0, 0, 0, +11, 30, " 2000 Feb 29 GMT + 11:30");        checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "Tuesday, May 32 2000 11:27 UCT");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "32 May 2000 11:25");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "Tuesday, May 32 2000 11:25");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "19921301 11:25");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "19921232 11:25");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "19921001 11:60");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "19920401 24:25");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0,     "20070430193647+713'00' illegal tz hr");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "nodigits");        checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "Unknown");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "333three digit year");        checkParse(2000, 2, 29, 0, 0, 0, 0, 0, "2000 Feb 29");        checkParse(2000, 2, 29, 0, 0, 0, +11, 0, " 2000 Feb 29 GMT + 11:00");        checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "2100 Feb 29 GMT+11");        checkParse(2012, 2, 29, 0, 0, 0, +11, 0, "2012 Feb 29 GMT+11");        checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "2012 Feb 30 GMT+11");        checkParse(1970, 12, 23, 0, 8, 0, 0, 0, "1970 12 23:08");                        checkParse(1971, 7, 6, 17, 22, 1, 0, 0, "Tuesday, 6 Jul 1971 5:22:1 PM");        checkParse(1972, 7, 6, 17, 22, 1, 0, 0, "Thu, July 6, 1972 5:22:1 pm");        checkParse(1973, 7, 6, 17, 22, 1, 0, 0, "7/6/1973 17:22:1");        checkParse(1974, 7, 6, 0, 0, 0, 0, 0, "7/6/1974");        checkParse(1975, 7, 6, 17, 22, 1, -10, 0, "1975-7-6T17:22:1-1000");        checkParse(1976, 7, 6, 17, 22, 1, -4, 0, "1976-7-6T17:22:1GMT-4");            checkParse(BAD, 7, 6, 17, 22, 1, -4, 0, "2076-7-6T17:22:1EDT");            checkParse(1960, 7, 6, 17, 22, 1, -5, 0, "1960-7-6T17:22:1EST");        checkParse(1977, 7, 6, 0, 0, 0, 0, 0, "Wednesday, Jul 6, 1977");        checkParse(1978, 7, 6, 17, 22, 1, 0, 0, "Thu Jul 6, 1978 17:22:1");        checkParse(1979, 7, 6, 17, 22, 1, +8, 0, "Friday July 6 17:22:1 GMT+08:00 1979");        checkParse(1980, 7, 6, 16, 23, 0, 0, 0, "Sun, Jul 6, 1980 at 4:23pm");        checkParse(1981, 7, 6, 0, 0, 0, 0, 0, "Monday, July 6, 1981");        checkParse(1982, 7, 6, 17, 22, 1, 0, 0, "6 Jul 1982 17:22:1");        checkParse(1983, 7, 6, 17, 22, 1, 0, 0, "7/6/1983 17:22:1");        checkParse(1984, 7, 6, 17, 22, 1, 0, 0, "7/6/1984 17:22:01");        checkParse(1985, 7, 6, 0, 0, 0, 0, 0, "7/6/1985");        checkParse(1986, 7, 6, 0, 0, 0, 0, 0, "07/06/1986");        checkParse(1987, 7, 6, 17, 22, 1, 0, 0, "7/6/1987 17:22:1");        checkParse(1988, 7, 6, 0, 0, 0, 0, 0, "7/6/1988");        checkParse(year - 79, 1, 1, 0, 0, 0, 0, 0, "1/1/" + ((year - 79) % 100) +     " 00:00:00");        checkParse(year + 19, 1, 1, 0, 0, 0, 0, 0, "1/1/" + ((year + 19) % 100));        checkParse(1991, 7, 6, 17, 7, 1, +6, 0, "19910706 17:7:1 Z+0600");        checkParse(1992, 7, 6, 17, 7, 1, 0, 0, "19920706 17:07:01");        checkParse(1993, 7, 6, 0, 0, 0, 0, 0, "19930706+00'00'");        checkParse(1994, 7, 6, 0, 0, 0, 1, 0, "19940706+01'00'");        checkParse(1995, 7, 6, 0, 0, 0, 2, 0, "19950706+02'00'");        checkParse(1996, 7, 6, 0, 0, 0, 3, 0, "19960706+03'00'");            checkParse(1997, 7, 6, 0, 0, 0, -10, 0, "19970706-10'00'");        checkParse(1998, 7, 6, 0, 0, 0, -11, 0, "19980706-11'00'");        checkParse(1999, 7, 6, 0, 0, 0, 0, 0, "19990706");        checkParse(2073, 12, 25, 0, 8, 0, 0, 0, "2073 12 25:08");        checkParse(2016, 4, 11, 16, 01, 15, 12, 0, "D:20160411160115+12'00'");}
private static void pdfbox_f8562_0(int yr, int mon, int day, int hr, int min, int sec, TimeZone tz, int offsetHours, int offsetMinutes) throws Exception
{        GregorianCalendar cal = new GregorianCalendar(tz, Locale.ENGLISH);    cal.set(yr, mon - 1, day, hr, min, sec);        String pdfDate = String.format(Locale.US, "D:%04d%02d%02d%02d%02d%02d%+03d'%02d'", yr, mon, day, hr, min, sec, offsetHours, offsetMinutes);    String iso8601Date = String.format(Locale.US, "%04d-%02d-%02d" + "T%02d:%02d:%02d%+03d:%02d", yr, mon, day, hr, min, sec, offsetHours, offsetMinutes);        assertEquals(pdfDate, DateConverter.toString(cal));    assertEquals(iso8601Date, DateConverter.toISO8601(cal));}
public void pdfbox_f8563_0() throws Exception
{            TimeZone tzPgh = TimeZone.getTimeZone("America/New_York");        TimeZone tzBerlin = TimeZone.getTimeZone("Europe/Berlin");        TimeZone tzMaputo = TimeZone.getTimeZone("Africa/Maputo");        TimeZone tzAruba = TimeZone.getTimeZone("America/Aruba");        TimeZone tzJamaica = TimeZone.getTimeZone("America/Jamaica");        TimeZone tzMcMurdo = TimeZone.getTimeZone("Antartica/McMurdo");        TimeZone tzAdelaide = TimeZone.getTimeZone("Australia/Adelaide");    assertNull(DateConverter.toCalendar((COSString) null));    assertNull(DateConverter.toCalendar((String) null));    checkToString(2013, 8, 28, 3, 14, 15, tzPgh, -4, 0);    checkToString(2014, 2, 28, 3, 14, 15, tzPgh, -5, 0);    checkToString(2015, 8, 28, 3, 14, 15, tzBerlin, +2, 0);    checkToString(2016, 2, 28, 3, 14, 15, tzBerlin, +1, 0);    checkToString(2017, 8, 28, 3, 14, 15, tzAruba, -4, 0);    checkToString(2018, 1, 1, 1, 14, 15, tzJamaica, -5, 0);    checkToString(2019, 12, 31, 12, 59, 59, tzJamaica, -5, 0);    checkToString(2020, 2, 29, 0, 0, 0, tzMaputo, +2, 0);    checkToString(2015, 8, 28, 3, 14, 15, tzAdelaide, +9, 30);    checkToString(2016, 2, 28, 3, 14, 15, tzAdelaide, +10, 30);        checkToString(1981, 1, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1982, 2, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1983, 3, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1984, 4, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1985, 5, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1986, 6, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1987, 7, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1988, 8, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1989, 9, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1990, 10, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1991, 11, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1992, 12, 1, 1, 14, 15, tzMcMurdo, +0, 0);}
private static void pdfbox_f8564_0(int expect, String src)
{    GregorianCalendar dest = DateConverter.newGreg();    DateConverter.parseTZoffset(src, dest, new ParsePosition(0));    assertEquals(expect, dest.get(Calendar.ZONE_OFFSET));}
public void pdfbox_f8565_0()
{        checkParseTZ(0 * HRS + 0 * MINS, "+00:00");    checkParseTZ(0 * HRS + 0 * MINS, "-0000");    checkParseTZ(1 * HRS + 0 * MINS, "+1:00");    checkParseTZ(-(1 * HRS + 0 * MINS), "-1:00");    checkParseTZ(-(1 * HRS + 30 * MINS), "-0130");    checkParseTZ(11 * HRS + 59 * MINS, "1159");    checkParseTZ(12 * HRS + 30 * MINS, "1230");    checkParseTZ(-(12 * HRS + 30 * MINS), "-12:30");    checkParseTZ(0 * HRS + 0 * MINS, "Z");    checkParseTZ(-(8 * HRS + 0 * MINS), "PST");        checkParseTZ(0 * HRS + 0 * MINS, "EDT");    checkParseTZ(-(3 * HRS + 0 * MINS), "GMT-0300");    checkParseTZ(+(11 * HRS + 0 * MINS), "GMT+11:00");    checkParseTZ(-(6 * HRS + 0 * MINS), "America/Chicago");    checkParseTZ(+(3 * HRS + 0 * MINS), "Europe/Moscow");    checkParseTZ(+(9 * HRS + 30 * MINS), "Australia/Adelaide");    checkParseTZ((5 * HRS + 0 * MINS), "0500");    checkParseTZ((5 * HRS + 0 * MINS), "+0500");    checkParseTZ((11 * HRS + 0 * MINS), "+11'00'");    checkParseTZ(0, "Z");        checkParseTZ(12 * HRS + 0 * MINS, "+12:00");    checkParseTZ(-(12 * HRS + 0 * MINS), "-12:00");    checkParseTZ(14 * HRS + 0 * MINS, "1400");    checkParseTZ(-(14 * HRS + 0 * MINS), "-1400");}
private static void pdfbox_f8566_0(double off, String expect)
{    TimeZone tz = new SimpleTimeZone((int) (off * 60 * 60 * 1000), "junkID");    String got = DateConverter.formatTZoffset(tz.getRawOffset(), ":");    assertEquals(expect, got);}
public void pdfbox_f8567_0()
{        checkFormatOffset(-12.1, "-12:06");    checkFormatOffset(12.1, "+12:06");    checkFormatOffset(0, "+00:00");    checkFormatOffset(-1, "-01:00");    checkFormatOffset(.5, "+00:30");    checkFormatOffset(-0.5, "-00:30");    checkFormatOffset(.1, "+00:06");    checkFormatOffset(-0.1, "-00:06");    checkFormatOffset(-12, "-12:00");    checkFormatOffset(12, "+12:00");    checkFormatOffset(-11.5, "-11:30");    checkFormatOffset(11.5, "+11:30");    checkFormatOffset(11.9, "+11:54");    checkFormatOffset(11.1, "+11:06");    checkFormatOffset(-11.9, "-11:54");    checkFormatOffset(-11.1, "-11:06");        checkFormatOffset(14, "+14:00");    checkFormatOffset(-14, "-14:00");}
public static Test pdfbox_f8568_0()
{    return new TestSuite(TestDateUtil.class);}
public static void pdfbox_f8569_0(String[] args)
{    String[] arg = { TestDateUtil.class.getName() };    junit.textui.TestRunner.main(arg);}
public void pdfbox_f8570_0()
{    assertArrayEquals(new char[] { '0', '0', '0', '0' }, Hex.getChars((short) 0x0000));    assertArrayEquals(new char[] { '0', '0', '0', 'F' }, Hex.getChars((short) 0x000F));    assertArrayEquals(new char[] { 'A', 'B', 'C', 'D' }, Hex.getChars((short) 0xABCD));    assertArrayEquals(new char[] { 'B', 'A', 'B', 'E' }, Hex.getChars((short) 0xCAFEBABE));}
public void pdfbox_f8571_0()
{    assertArrayEquals(new char[] { '0', '0', '6', '1', '0', '0', '6', '2' }, Hex.getCharsUTF16BE("ab"));    assertArrayEquals(new char[] { '5', 'E', '2', 'E', '5', '2', 'A', '9' }, Hex.getCharsUTF16BE("帮助"));}
private void pdfbox_f8572_0(char[] expected, char[] actual)
{    assertEquals("Length of char array not equal", expected.length, actual.length);    for (int idx = 0; idx < expected.length; idx++) {        if (expected[idx] != actual[idx]) {            fail(String.format("Character at index %d not equal. Expected '%c' but got '%c'", idx, expected[idx], actual[idx]));        }    }}
public static Test pdfbox_f8573_0()
{    return new TestSuite(TestHexUtil.class);}
public static void pdfbox_f8574_0(String[] args)
{    String[] arg = { TestHexUtil.class.getName() };    junit.textui.TestRunner.main(arg);}
public void pdfbox_f8575_0() throws Exception
{    Matrix m1 = new Matrix();    assertMatrixIsPristine(m1);    Matrix m2 = m1.clone();    assertNotSame(m1, m2);    assertMatrixIsPristine(m2);}
public void pdfbox_f8576_0() throws Exception
{        final Matrix testMatrix = new Matrix();        for (int x = 0; x < 3; x++) {        for (int y = 0; y < 3; y++) {            testMatrix.setValue(x, y, x + y);        }    }    Matrix m1 = testMatrix.clone();    Matrix m2 = testMatrix.clone();        Matrix product = m1.multiply(m2);    assertNotSame(m1, product);    assertNotSame(m2, product);        assertMatrixValuesEqualTo(new float[] { 0, 1, 2, 1, 2, 3, 2, 3, 4 }, m1);        assertMatrixValuesEqualTo(new float[] { 0, 1, 2, 1, 2, 3, 2, 3, 4 }, m2);    assertMatrixValuesEqualTo(new float[] { 5, 8, 11, 8, 14, 20, 11, 20, 29 }, product);            Matrix resultMatrix = new Matrix();    Matrix retVal = m1.multiply(m2, resultMatrix);    assertSame(retVal, resultMatrix);        assertMatrixValuesEqualTo(new float[] { 0, 1, 2, 1, 2, 3, 2, 3, 4 }, m1);        assertMatrixValuesEqualTo(new float[] { 0, 1, 2, 1, 2, 3, 2, 3, 4 }, m2);    assertMatrixValuesEqualTo(new float[] { 5, 8, 11, 8, 14, 20, 11, 20, 29 }, resultMatrix);        retVal = m1.multiply(m2, m2);    assertSame(retVal, m2);        assertMatrixValuesEqualTo(new float[] { 0, 1, 2, 1, 2, 3, 2, 3, 4 }, m1);    assertMatrixValuesEqualTo(new float[] { 5, 8, 11, 8, 14, 20, 11, 20, 29 }, retVal);        m1 = testMatrix.clone();    m2 = testMatrix.clone();    retVal = m1.multiply(m2, m1);    assertSame(retVal, m1);        assertMatrixValuesEqualTo(new float[] { 0, 1, 2, 1, 2, 3, 2, 3, 4 }, m2);    assertMatrixValuesEqualTo(new float[] { 5, 8, 11, 8, 14, 20, 11, 20, 29 }, retVal);        m1 = testMatrix.clone();    retVal = m1.multiply(m1, m1);    assertSame(retVal, m1);    assertMatrixValuesEqualTo(new float[] { 5, 8, 11, 8, 14, 20, 11, 20, 29 }, retVal);}
private void pdfbox_f8577_0(Matrix m)
{    assertMatrixValuesEqualTo(new float[] { 1, 0, 0, 0, 1, 0, 0, 0, 1 }, m);}
private void pdfbox_f8578_0(float[] values, Matrix m)
{    float delta = 0.00001f;    for (int i = 0; i < values.length; i++) {                int row = (int) Math.floor(i / 3);        int column = i % 3;        StringBuilder failureMsg = new StringBuilder();        failureMsg.append("Incorrect value for matrix[").append(row).append(",").append(column).append("]");        assertEquals(failureMsg.toString(), values[i], m.getValue(row, column), delta);    }}
public static Test pdfbox_f8579_0()
{    return new TestSuite(TestMatrix.class);}
public static void pdfbox_f8580_0(String[] args)
{    String[] arg = { TestMatrix.class.getName() };    junit.textui.TestRunner.main(arg);}
public void pdfbox_f8581_0()
{    assertEquals(2, NumberFormatUtil.formatFloatFast(51, 5, buffer));    assertArrayEquals(new byte[] { '5', '1' }, Arrays.copyOfRange(buffer, 0, 2));    assertEquals(3, NumberFormatUtil.formatFloatFast(-51, 5, buffer));    assertArrayEquals(new byte[] { '-', '5', '1' }, Arrays.copyOfRange(buffer, 0, 3));    assertEquals(1, NumberFormatUtil.formatFloatFast(0, 5, buffer));    assertArrayEquals(new byte[] { '0' }, Arrays.copyOfRange(buffer, 0, 1));    assertEquals(19, NumberFormatUtil.formatFloatFast(Long.MAX_VALUE, 5, buffer));    assertArrayEquals(new byte[] { '9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5', '4', '7', '7', '5', '8', '0', '7' }, Arrays.copyOfRange(buffer, 0, 19));                assertEquals(10, NumberFormatUtil.formatFloatFast(Integer.MAX_VALUE, 5, buffer));    assertArrayEquals(new byte[] { '2', '1', '4', '7', '4', '8', '3', '6', '4', '8' }, Arrays.copyOfRange(buffer, 0, 10));    assertEquals(11, NumberFormatUtil.formatFloatFast(Integer.MIN_VALUE, 5, buffer));    assertArrayEquals(new byte[] { '-', '2', '1', '4', '7', '4', '8', '3', '6', '4', '8' }, Arrays.copyOfRange(buffer, 0, 11));}
public void pdfbox_f8582_0()
{    assertEquals(3, NumberFormatUtil.formatFloatFast(0.7f, 5, buffer));    assertArrayEquals(new byte[] { '0', '.', '7' }, Arrays.copyOfRange(buffer, 0, 3));    assertEquals(4, NumberFormatUtil.formatFloatFast(-0.7f, 5, buffer));    assertArrayEquals(new byte[] { '-', '0', '.', '7' }, Arrays.copyOfRange(buffer, 0, 4));    assertEquals(5, NumberFormatUtil.formatFloatFast(0.003f, 5, buffer));    assertArrayEquals(new byte[] { '0', '.', '0', '0', '3' }, Arrays.copyOfRange(buffer, 0, 5));    assertEquals(6, NumberFormatUtil.formatFloatFast(-0.003f, 5, buffer));    assertArrayEquals(new byte[] { '-', '0', '.', '0', '0', '3' }, Arrays.copyOfRange(buffer, 0, 6));}
public void pdfbox_f8583_0()
{    assertEquals("NaN should not be formattable", -1, NumberFormatUtil.formatFloatFast(Float.NaN, 5, buffer));    assertEquals("+Infinity should not be formattable", -1, NumberFormatUtil.formatFloatFast(Float.POSITIVE_INFINITY, 5, buffer));    assertEquals("-Infinity should not be formattable", -1, NumberFormatUtil.formatFloatFast(Float.NEGATIVE_INFINITY, 5, buffer));    assertEquals("Too big number should not be formattable", -1, NumberFormatUtil.formatFloatFast(((float) Long.MAX_VALUE) + 1000000000000f, 5, buffer));    assertEquals("Too big negative number should not be formattable", -1, NumberFormatUtil.formatFloatFast(Long.MIN_VALUE, 5, buffer));}
public void pdfbox_f8584_0()
{    assertEquals(1, NumberFormatUtil.formatFloatFast(0.999999f, 5, buffer));    assertArrayEquals(new byte[] { '1' }, Arrays.copyOfRange(buffer, 0, 1));    assertEquals(4, NumberFormatUtil.formatFloatFast(0.125f, 2, buffer));    assertArrayEquals(new byte[] { '0', '.', '1', '3' }, Arrays.copyOfRange(buffer, 0, 4));    assertEquals(2, NumberFormatUtil.formatFloatFast(-0.999999f, 5, buffer));    assertArrayEquals(new byte[] { '-', '1' }, Arrays.copyOfRange(buffer, 0, 2));}
public void pdfbox_f8585_0()
{    assertEquals(4, NumberFormatUtil.formatFloatFast(0.994f, 2, buffer));    assertArrayEquals(new byte[] { '0', '.', '9', '9' }, Arrays.copyOfRange(buffer, 0, 4));}
public void pdfbox_f8586_0()
{        BigDecimal minVal = new BigDecimal("-10");    BigDecimal maxVal = new BigDecimal("10");    BigDecimal maxDelta = BigDecimal.ZERO;    Pattern pattern = Pattern.compile("^\\-?\\d+(\\.\\d+)?$");    byte[] formatBuffer = new byte[32];    for (int maxFractionDigits = 0; maxFractionDigits <= 5; maxFractionDigits++) {        BigDecimal increment = new BigDecimal(10).pow(-maxFractionDigits, MathContext.DECIMAL128);        for (BigDecimal value = minVal; value.compareTo(maxVal) < 0; value = value.add(increment)) {                        int byteCount = NumberFormatUtil.formatFloatFast(value.floatValue(), maxFractionDigits, formatBuffer);            assertFalse(byteCount == -1);            String newStringResult = new String(formatBuffer, 0, byteCount, Charsets.US_ASCII);            BigDecimal formattedDecimal = new BigDecimal(newStringResult);                                                BigDecimal expectedDecimal = new BigDecimal(value.floatValue());            expectedDecimal = expectedDecimal.setScale(maxFractionDigits, RoundingMode.HALF_UP);            BigDecimal diff = formattedDecimal.subtract(expectedDecimal).abs();            assertTrue(pattern.matcher(newStringResult).matches());                        if (diff.compareTo(maxDelta) > 0) {                fail("Expected: " + expectedDecimal + ", actual: " + newStringResult + ", diff: " + diff);            }        }    }}
private void pdfbox_f8587_0(byte[] expected, byte[] actual)
{    assertEquals("Length of byte array not equal", expected.length, actual.length);    for (int idx = 0; idx < expected.length; idx++) {        if (expected[idx] != actual[idx]) {            fail(String.format("Byte at index %d not equal. Expected '%02X' but got '%02X'", idx, expected[idx], actual[idx]));        }    }}
public static Test pdfbox_f8588_0()
{    return new TestSuite(TestNumberFormatUtil.class);}
public static void pdfbox_f8589_0(String[] args)
{    String[] arg = { TestNumberFormatUtil.class.getName() };    junit.textui.TestRunner.main(arg);}
 void pdfbox_f8590_0(T[] input, T[] expected)
{    List<T> list = Arrays.asList(input);    QuickSort.sort(list);    boolean equal = Arrays.equals(list.toArray(new Object[input.length]), expected);    assertTrue(equal);}
public void pdfbox_f8591_0()
{    {        Integer[] input = new Integer[] { 9, 8, 7, 6, 5, 4, 3, 2, 1 };        Integer[] expected = new Integer[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };        doTest(input, expected);    }    {        Integer[] input = new Integer[] { 4, 3, 2, 1, 9, 8, 7, 6, 5 };        Integer[] expected = new Integer[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };        doTest(input, expected);    }    {        Integer[] input = new Integer[] {};        Integer[] expected = new Integer[] {};        doTest(input, expected);    }    {        Integer[] input = new Integer[] { 5 };        Integer[] expected = new Integer[] { 5 };        doTest(input, expected);    }    {        Integer[] input = new Integer[] { 5, 6 };        Integer[] expected = new Integer[] { 5, 6 };        doTest(input, expected);    }    {        Integer[] input = new Integer[] { 6, 5 };        Integer[] expected = new Integer[] { 5, 6 };        doTest(input, expected);    }    Random rnd = new Random(12345);    for (int cnt = 0; cnt < 100; ++cnt) {        int len = rnd.nextInt(20000) + 2;        Integer[] input = new Integer[len];        Integer[] expected = new Integer[len];        for (int i = 0; i < len; ++i) {                        expected[i] = input[i] = rnd.nextInt(rnd.nextInt(100) + 1);        }        Arrays.sort(expected);        doTest(input, expected);    }}
public boolean pdfbox_f8592_0()
{    return this.aaKey != null;}
public COSDictionary pdfbox_f8593_0()
{    return actionDictionnary;}
public String pdfbox_f8594_0()
{    return aaKey;}
protected boolean pdfbox_f8595_0() throws ValidationException
{    List<AbstractActionManager> lActions = this.actionFact.getNextActions(this.context, this.actionDictionnary);    for (AbstractActionManager nAction : lActions) {        if (!nAction.innerValid()) {            return false;        }    }    return true;}
public boolean pdfbox_f8596_0() throws ValidationException
{    return valid(false);}
public boolean pdfbox_f8597_0(boolean additionalActionAuth) throws ValidationException
{    if (isAdditionalAction() && !additionalActionAuth) {        context.addValidationError(new ValidationError(ERROR_ACTION_FORBIDDEN_ADDITIONAL_ACTION, "Additional Action are forbidden"));        return false;    }    if (innerValid()) {        return validNextActions();    }    return true;}
public final List<AbstractActionManager> pdfbox_f8598_0(PreflightContext ctx, COSDictionary dictionary) throws ValidationException
{    List<AbstractActionManager> result = new ArrayList<>(0);    Map<COSObjectKey, Boolean> alreadyCreated = new HashMap<>();    COSBase aDict = dictionary.getDictionaryObject(COSName.A);    if (aDict != null) {        callCreateAction(aDict, ctx, result, alreadyCreated);    }    COSBase oaDict = dictionary.getDictionaryObject(COSName.OPEN_ACTION);    if (oaDict != null && !(oaDict instanceof COSArray)) {        callCreateAction(oaDict, ctx, result, alreadyCreated);    }        COSDictionary aaDict = dictionary.getCOSDictionary(COSName.AA);    if (aaDict != null) {        for (COSName name : aaDict.keySet()) {            callCreateAction(aaDict.getDictionaryObject(name), ctx, result, name.getName(), alreadyCreated);        }    }    return result;}
private void pdfbox_f8599_0(COSBase aDict, PreflightContext ctx, List<AbstractActionManager> result, Map<COSObjectKey, Boolean> alreadyCreated) throws ValidationException
{    callCreateAction(aDict, ctx, result, null, alreadyCreated);}
private void pdfbox_f8600_0(COSBase aDict, PreflightContext ctx, List<AbstractActionManager> result, String additionActionKey, Map<COSObjectKey, Boolean> alreadyCreated) throws ValidationException
{    if (aDict instanceof COSDictionary || aDict instanceof COSObject && ((COSObject) aDict).getObject() instanceof COSDictionary) {        if (aDict instanceof COSObject) {            COSObjectKey cok = new COSObjectKey((COSObject) aDict);            COSDictionary indirectDict = (COSDictionary) ((COSObject) aDict).getObject();            if (!alreadyCreated.containsKey(cok)) {                result.add(createActionManager(ctx, indirectDict, additionActionKey));                alreadyCreated.put(cok, true);            }        } else {            result.add(createActionManager(ctx, (COSDictionary) aDict, additionActionKey));        }    } else {        ctx.addValidationError(new ValidationError(PreflightConstants.ERROR_ACTION_INVALID_TYPE, "Action entry isn't an instance of COSDictionary"));    }}
public final List<AbstractActionManager> pdfbox_f8601_0(PreflightContext ctx, COSDictionary actionDictionary) throws ValidationException
{    List<AbstractActionManager> result = new ArrayList<>(0);    Map<COSObjectKey, Boolean> alreadyCreated = new HashMap<>();    COSBase nextDict = actionDictionary.getDictionaryObject(COSName.NEXT);    if (nextDict != null) {        if (nextDict instanceof COSArray) {            COSArray array = (COSArray) nextDict;                        for (int i = 0; i < array.size(); ++i) {                callCreateAction(array.getObject(i), ctx, result, alreadyCreated);            }        } else {                        callCreateAction(nextDict, ctx, result, alreadyCreated);        }    }    return result;}
protected AbstractActionManager pdfbox_f8602_0(PreflightContext ctx, COSDictionary action, String aaKey) throws ValidationException
{    String type = action.getNameAsString(COSName.TYPE);    if (type != null && !ACTION_DICTIONARY_VALUE_TYPE.equals(type)) {        throw new ValidationException("The given dictionary isn't the dictionary of an Action");    }            String s = action.getNameAsString(COSName.S);        if (ACTION_DICTIONARY_VALUE_ATYPE_GOTO.equals(s)) {        return new GoToAction(this, action, ctx, aaKey);    }    if (ACTION_DICTIONARY_VALUE_ATYPE_GOTOR.equals(s)) {        return new GoToRemoteAction(this, action, ctx, aaKey);    }    if (ACTION_DICTIONARY_VALUE_ATYPE_THREAD.equals(s)) {        return new ThreadAction(this, action, ctx, aaKey);    }    if (ACTION_DICTIONARY_VALUE_ATYPE_URI.equals(s)) {        return new UriAction(this, action, ctx, aaKey);    }    if (ACTION_DICTIONARY_VALUE_ATYPE_HIDE.equals(s)) {        return new HideAction(this, action, ctx, aaKey);    }    if (ACTION_DICTIONARY_VALUE_ATYPE_NAMED.equals(s)) {        return new NamedAction(this, action, ctx, aaKey);    }    if (ACTION_DICTIONARY_VALUE_ATYPE_SUBMIT.equals(s)) {        return new SubmitAction(this, action, ctx, aaKey);    }        if (ACTION_DICTIONARY_VALUE_ATYPE_LAUNCH.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_SOUND.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_MOVIE.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_RESET.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_IMPORT.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_JAVASCRIPT.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_SETSTATE.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_NOOP.equals(s)) {        return new InvalidAction(this, action, ctx, aaKey, s);    }        return new UndefAction(this, action, ctx, aaKey, s);}
protected boolean pdfbox_f8603_0() throws ValidationException
{    COSBase dest = this.actionDictionnary.getItem(COSName.D);        if (dest == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "D entry is mandatory for the GoToActions"));        return false;    }    ContextHelper.validateElement(context, dest, DESTINATION_PROCESS);    return true;}
protected boolean pdfbox_f8604_0() throws ValidationException
{    COSBase dest = this.actionDictionnary.getItem(COSName.D);        if (dest == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "/D entry is mandatory for the GoToActions"));        return false;    }    if (!(dest instanceof COSName || dest instanceof COSString || dest instanceof COSArray)) {        context.addValidationError(new ValidationError(ERROR_ACTION_INVALID_TYPE, "Type " + dest.getClass().getSimpleName() + " of /D entry is invalid"));        return false;    }    COSBase f = this.actionDictionnary.getItem(COSName.F);    if (f == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "/F entry is mandatory for the GoToRemoteActions"));        return false;    }    if (dest instanceof COSArray) {        COSArray ar = (COSArray) dest;        if (ar.size() < 2) {            context.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, "Destination array must have at least 2 elements"));            return false;        }        if (!(ar.get(1) instanceof COSName)) {            context.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, "Second element of destination array must be a name"));            return false;        }        validateExplicitDestination(ar);    }    try {        PDDestination.create(dest);    } catch (IOException e) {        context.addValidationError(new ValidationResult.ValidationError(PreflightConstants.ERROR_SYNTAX_DICT_INVALID, e.getMessage(), e));        return false;    }    return true;}
private boolean pdfbox_f8605_0(COSArray ar)
{    if (!(ar.get(0) instanceof COSNumber)) {                context.addValidationError(new ValidationError(ERROR_ACTION_INVALID_TYPE, "First element in /D array entry of GoToRemoteAction must be a page number, but is " + ar.get(0)));        return false;    }    return true;}
protected boolean pdfbox_f8606_0()
{    COSBase t = this.actionDictionnary.getDictionaryObject(COSName.T);        if (t == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "T entry is mandatory for the NamedActions"));        return false;    }    if (!(t instanceof COSDictionary || t instanceof COSArray || t instanceof COSString || t instanceof COSName)) {        context.addValidationError(new ValidationError(ERROR_ACTION_INVALID_TYPE, "T entry type is invalid"));        return false;    }    /*         * ---- H entry is optional but the default value is True (annotations of the T entry will be hidden) according         * to the aim of a PDF/A it should be false (annotations of the T entry will be shown).         *          * We check the H value and we throw an error if it is true because of the PDF/A Application Notes sentence :         *          * The PDF Reference supports a concept whereby something will happen when the user performs an explicit or         * implicit action in a PDF viewer - these "things" are called Actions. PDF/A-1 permits a limited set of these         * Actions, which are detailed in section 6.6.1. Specifically, any action that could change the visual         * representation of the document or is not documented in the PDF Reference is not permitted. This includes the         * /Hide action which isn't specifically prohibited by PDF/A-1, but should have been.         */    boolean h = this.actionDictionnary.getBoolean(COSName.H, true);    if (h) {        context.addValidationError(new ValidationError(ERROR_ACTION_HIDE_H_INVALID, "H entry is \"true\""));        return false;    }    return true;}
protected boolean pdfbox_f8607_0()
{    context.addValidationError(new ValidationError(ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN, "The action " + actionName + " is forbidden"));    return false;}
protected boolean pdfbox_f8608_0()
{    String n = this.actionDictionnary.getNameAsString(COSName.N);        if (n == null || "".equals(n)) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "N entry is mandatory for the NamedActions"));        return false;    }        if (!(ACTION_DICTIONARY_VALUE_ATYPE_NAMED_FIRST.equals(n) || ACTION_DICTIONARY_VALUE_ATYPE_NAMED_LAST.equals(n) || ACTION_DICTIONARY_VALUE_ATYPE_NAMED_NEXT.equals(n) || ACTION_DICTIONARY_VALUE_ATYPE_NAMED_PREV.equals(n))) {        context.addValidationError(new ValidationError(ERROR_ACTION_FORBIDDEN_ACTIONS_NAMED, n + " isn't authorized as named action"));        return false;    }    return true;}
protected boolean pdfbox_f8609_0()
{    COSBase f = this.actionDictionnary.getItem(COSName.F);    if (f == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "F entry is mandatory for the SubmitActions"));        return false;    }    return true;}
protected boolean pdfbox_f8610_0()
{    COSBase d = this.actionDictionnary.getDictionaryObject(COSName.D);        if (d == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "D entry is mandatory for the ThreadAction"));        return false;    }    if (!(d instanceof COSInteger || d instanceof COSName || d instanceof COSString || d instanceof COSDictionary)) {        context.addValidationError(new ValidationError(ERROR_ACTION_INVALID_TYPE, "D entry type is invalid"));        return false;    }    return true;}
protected boolean pdfbox_f8611_0()
{    context.addValidationError(new ValidationError(ERROR_ACTION_FORBIDDEN_ACTIONS_UNDEF, "The action " + actionName + " is undefined"));    return false;}
protected boolean pdfbox_f8612_0()
{    COSBase uri = this.actionDictionnary.getDictionaryObject(COSName.URI);    if (uri == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "URI entry is mandatory for the UriAction"));        return false;    }    if (!(uri instanceof COSString)) {        context.addValidationError(new ValidationError(ERROR_ACTION_INVALID_TYPE, "URI entry should be a string"));        return false;    }    return true;}
protected boolean pdfbox_f8613_0()
{    boolean result = this.pdAnnot.isPrinted();    result = result && !this.pdAnnot.isHidden();    result = result && !this.pdAnnot.isInvisible();    result = result && !this.pdAnnot.isNoView();    if (!result) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_FLAG, "Flags of " + pdAnnot.getSubtype() + " annotation are invalid"));    }    return result;}
protected boolean pdfbox_f8614_0()
{    COSBase ca = this.pdAnnot.getCOSObject().getDictionaryObject(COSName.CA);    if (ca instanceof COSFloat) {        float caf = ((COSFloat) ca).floatValue();        if (Float.compare(caf, 1.0f) != 0) {                        ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_CA, "CA entry is invalid. Expected 1.0 / Read " + caf));            return false;        }    }        return true;}
protected boolean pdfbox_f8615_0() throws ValidationException
{    if (this.pdAnnot.getColor() != null && !searchRGBProfile()) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_COLOR, "Annotation uses a Color profile which isn't the same than the profile contained by the OutputIntent"));        return false;    }    return true;}
protected boolean pdfbox_f8616_0() throws ValidationException
{    ICCProfileWrapper iccpw = ICCProfileWrapper.getOrSearchICCProfile(ctx);    if (iccpw != null) {        return iccpw.isRGBColorSpace();    }    return false;}
protected boolean pdfbox_f8617_0() throws ValidationException
{    PDAppearanceDictionary ap = this.pdAnnot.getAppearance();    if (ap != null) {        COSDictionary apDict = ap.getCOSObject();                if (apDict.getItem(COSName.D) != null || apDict.getItem(COSName.R) != null) {            ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_AP_CONTENT, "Only the N Appearance is authorized"));            return false;        } else if (apDict.getItem(COSName.N) == null) {                        ctx.addValidationError(new ValidationError(ERROR_ANNOT_MISSING_AP_N_CONTENT, "The N Appearance must be present"));            return false;        } else {            COSBase apn = apDict.getDictionaryObject(COSName.N);            COSName subtype = annotDictionary.getCOSName(COSName.SUBTYPE);            COSBase ft = getFieldType();            if (COSName.WIDGET.equals(subtype) && COSName.BTN.equals(ft)) {                                if (apn instanceof COSStream) {                    ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_AP_CONTENT, "The N Appearance of a Btn widget must not be a stream, but an appearance subdictionary"));                                                            ContextHelper.validateElement(ctx, new PDFormXObject((COSStream) apn), GRAPHIC_PROCESS);                    return false;                }                if (apn instanceof COSDictionary) {                    for (COSBase val : ((COSDictionary) apn).getValues()) {                                                if (val instanceof COSObject) {                            val = ((COSObject) val).getObject();                        }                        ContextHelper.validateElement(ctx, new PDFormXObject((COSStream) val), GRAPHIC_PROCESS);                    }                } else {                    ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_AP_CONTENT, "The N Appearance must be an appearance subdictionary"));                    return false;                }            } else {                                if (apn instanceof COSStream) {                                        ContextHelper.validateElement(ctx, new PDFormXObject((COSStream) apn), GRAPHIC_PROCESS);                } else {                    ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_AP_CONTENT, "The N Appearance must be a Stream"));                    return false;                }            }        }    } else if (this.pdAnnot instanceof PDAnnotationWidget && this.pdAnnot.getAppearance() == null) {                                ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_AP_CONTENT, "widget annotation lacks an appearance dictionary"));        return false;    }        return true;}
protected boolean pdfbox_f8618_0() throws ValidationException
{    ContextHelper.validateElement(ctx, annotDictionary, ACTIONS_PROCESS);    return true;}
protected boolean pdfbox_f8619_0() throws ValidationException
{    COSBase cosPopup = this.annotDictionary.getDictionaryObject(COSName.getPDFName(ANNOT_DICTIONARY_VALUE_SUBTYPE_POPUP));    if (cosPopup != null) {        if (!(cosPopup instanceof COSDictionary)) {            ctx.addValidationError(new ValidationError(ERROR_SYNTAX_DICT_INVALID, "An Annotation has a Popup entry, but the value is missing or isn't a dictionary"));            return false;        }        AnnotationValidator popupVal = this.annotFact.getAnnotationValidator(ctx, (COSDictionary) cosPopup);        return popupVal.validate();    }    return true;}
public boolean pdfbox_f8620_0() throws ValidationException
{    boolean isValid = checkMandatoryFields();    isValid = checkFlags() && isValid;    isValid = checkColors() && isValid;    isValid = checkAP() && isValid;    isValid = checkCA() && isValid;    isValid = checkActions() && isValid;    isValid = checkPopup() && isValid;    return isValid;}
protected boolean pdfbox_f8621_0()
{    boolean subtype = this.annotDictionary.containsKey(COSName.SUBTYPE);    boolean rect = this.annotDictionary.containsKey(COSName.RECT);    boolean result = (subtype && rect && checkSpecificMandatoryFields());    if (!result) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_MISSING_FIELDS, "A mandatory field for the " + this.pdAnnot.getSubtype() + " annotation is missing"));    }    return result;}
protected boolean pdfbox_f8622_0()
{    return true;}
public final void pdfbox_f8623_0(AnnotationValidatorFactory fact)
{    this.annotFact = fact;}
private COSBase pdfbox_f8624_0()
{    COSBase ft = annotDictionary.getDictionaryObject(COSName.FT);    COSDictionary parent = annotDictionary;    while (ft == null) {                COSBase parentBase = parent.getDictionaryObject(COSName.PARENT);        if (parentBase instanceof COSDictionary) {            parent = (COSDictionary) parentBase;            ft = parent.getDictionaryObject(COSName.FT);        } else {            break;        }    }    return ft;}
public final void pdfbox_f8625_0(ActionManagerFactory _actionFact)
{    this.actionFact = _actionFact;}
public final AnnotationValidator pdfbox_f8626_0(PreflightContext ctx, COSDictionary annotDic) throws ValidationException
{    AnnotationValidator result = null;    String subtype = annotDic.getNameAsString(COSName.SUBTYPE);    Class<? extends AnnotationValidator> clazz = this.validatorClasses.get(subtype);    if (clazz == null) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_SUBTYPE, "The subtype isn't authorized : " + subtype));    } else {        try {            Constructor<? extends AnnotationValidator> constructor = clazz.getDeclaredConstructor(PreflightContext.class, COSDictionary.class);            result = constructor.newInstance(ctx, annotDic);            result.setFactory(this);        } catch (Exception e) {            throw new ValidationException(e.getMessage(), e);        }    }    return result;}
protected boolean pdfbox_f8627_0()
{    return this.annotDictionary.containsKey(COSName.DA);}
protected boolean pdfbox_f8628_0()
{    return this.annotDictionary.containsKey(COSName.getPDFName(ANNOT_DICTIONARY_KEY_INKLIST));}
public boolean pdfbox_f8629_0() throws ValidationException
{    boolean isValid = super.validate();    isValid = checkIColors() && isValid;    return isValid;}
protected boolean pdfbox_f8630_0() throws ValidationException
{    if (this.pdLine.getInteriorColor() != null && !searchRGBProfile()) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_COLOR, "Annotation uses a Color profile which isn't the same than the profile contained by the OutputIntent"));        return false;    }    return true;}
protected boolean pdfbox_f8631_0()
{    return this.annotDictionary.containsKey(COSName.L);}
public boolean pdfbox_f8632_0() throws ValidationException
{    boolean isValid = super.validate();    isValid = checkDest() && isValid;    return isValid;}
protected boolean pdfbox_f8633_0()
{    try {        if (this.pdLink.getDestination() != null && this.pdLink.getAction() != null) {            ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_DEST, "Dest can't be used due to A element"));            return false;        }        COSDictionary dict = pdLink.getCOSObject();        COSBase dest = dict.getDictionaryObject(COSName.DEST);        if (dest != null) {            ContextHelper.validateElement(ctx, dest, DESTINATION_PROCESS);        }    } catch (IOException e) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_DEST, e.getMessage(), e));        return false;    }    return true;}
protected boolean pdfbox_f8634_0()
{    return this.annotDictionary.containsKey(COSName.getPDFName(ANNOT_DICTIONARY_KEY_QUADPOINTS));}
protected void pdfbox_f8635_0()
{    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_TEXT, TextAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_LINK, LinkAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_FREETEXT, FreeTextAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_LINE, LineAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_SQUARE, SquareAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_CIRCLE, CircleAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_HIGHLIGHT, HighlightAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_UNDERLINE, UnderlineAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_STRIKEOUT, StrikeoutAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_SQUIGGLY, SquigglyAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_STAMP, RubberStampAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_INK, InkAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_POPUP, PopupAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_WIDGET, WidgetAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_PRINTERMARK, PrintMarkAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_TRAPNET, TrapNetAnnotationValidator.class);}
public boolean pdfbox_f8636_0() throws ValidationException
{    boolean isValid = super.validate();    isValid = checkIColors() && isValid;    return isValid;}
protected boolean pdfbox_f8637_0() throws ValidationException
{    if (this.pdSquareCircle.getInteriorColor() != null && !searchRGBProfile()) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_COLOR, "Annotation uses a Color profile which isn't the same than the profile contained by the OutputIntent"));        return false;    }    return true;}
protected boolean pdfbox_f8638_0()
{        boolean result = super.checkFlags();    /*         * For Text Annotation, this two flags should be set to avoid potential ambiguity between the annotation         * dictionary and the reader behavior.         */    result = result && this.pdAnnot.isNoRotate();    result = result && this.pdAnnot.isNoZoom();    if (!result) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_NOT_RECOMMENDED_FLAG));    }    return result;}
public boolean pdfbox_f8639_0() throws ValidationException
{    boolean isValid = super.validate();    return checkAAField() && isValid;}
protected boolean pdfbox_f8640_0()
{    if (this.pdWidget.getActions() != null) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_AA));        return false;    }    return true;}
public String pdfbox_f8641_0()
{    return errorCode;}
public void pdfbox_f8642_0(String errorCode)
{    this.errorCode = errorCode;}
public void pdfbox_f8643_0() throws ValidationException
{    try {        if (processedPage.hasContents()) {            processPage(processedPage);        }    } catch (ContentStreamException e) {        context.addValidationError(new ValidationError(e.getErrorCode(), e.getMessage()));    } catch (IOException e) {        throw new ValidationException("Unable to check the Page ContentStream : " + e.getMessage(), e);    }}
public void pdfbox_f8644_0(PDFormXObject form) throws ValidationException
{    try {                if (processedPage == null) {                        processChildStream(form, new PDPage());        } else {            processChildStream(form, processedPage);        }    } catch (ContentStreamException e) {        context.addValidationError(new ValidationError(e.getErrorCode(), e.getMessage()));    } catch (IOException e) {        throw new ValidationException("Unable to check the XObject ContentStream : " + e.getMessage(), e);    }}
public void pdfbox_f8645_0(PDTilingPattern pattern) throws ValidationException
{    try {        processChildStream(pattern, processedPage);    } catch (ContentStreamException e) {        context.addValidationError(new ValidationError(e.getErrorCode(), e.getMessage()));    } catch (IOException e) {        throw new ValidationException("Unable to check the Pattern ContentStream : " + e.getMessage(), e);    }}
protected void pdfbox_f8646_0(Operator operator, List<COSBase> operands) throws IOException
{    super.processOperator(operator, operands);    /*         * Process Specific Validation. The Generic Processing is useless for PDF/A validation         */    if (OperatorName.BEGIN_INLINE_IMAGE.equals(operator.getName())) {        validateInlineImageFilter(operator);        validateInlineImageColorSpace(operator);    }    checkShowTextOperators(operator, operands);    checkColorOperators(operator.getName());    validateRenderingIntent(operator, operands);    checkSetColorSpaceOperators(operator, operands);    validateNumberOfGraphicStates(operator);    validateDefaultColorSpace(operator);}
protected void pdfbox_f8647_0(Operator operator, List<COSBase> arguments)
{    registerError("The operator \"" + operator.getName() + "\" isn't supported.", ERROR_SYNTAX_CONTENT_STREAM_UNSUPPORTED_OP);}
protected void pdfbox_f8648_0(Operator operator, List<?> arguments) throws IOException
{    String op = operator.getName();    if (OperatorName.SHOW_TEXT.equals(op) || OperatorName.SHOW_TEXT_LINE.equals(op) || OperatorName.SHOW_TEXT_LINE_AND_SPACE.equals(op)) {        validateStringDefinition(operator, arguments);    }    if (OperatorName.SHOW_TEXT_ADJUSTED.equals(op)) {        validateStringArray(operator, arguments);    }}
private void pdfbox_f8649_0(Operator operator, List<?> arguments) throws IOException
{    /*         * For a Text operator, the arguments list should contain only one COSString object         */    if (OperatorName.SHOW_TEXT_LINE_AND_SPACE.equals(operator.getName())) {        if (arguments.size() != 3) {            registerError("Invalid argument for the operator : " + operator.getName(), ERROR_SYNTAX_CONTENT_STREAM_INVALID_ARGUMENT);            return;        }        Object arg0 = arguments.get(0);        Object arg1 = arguments.get(1);        Object arg2 = arguments.get(2);        if (!(arg0 instanceof COSInteger || arg0 instanceof COSFloat) || !(arg1 instanceof COSInteger || arg1 instanceof COSFloat)) {            registerError("Invalid argument for the operator : " + operator.getName(), ERROR_SYNTAX_CONTENT_STREAM_INVALID_ARGUMENT);            return;        }        if (arg2 instanceof COSString) {            validateText(((COSString) arg2).getBytes());        } else {            registerError("Invalid argument for the operator : " + operator.getName(), ERROR_SYNTAX_CONTENT_STREAM_INVALID_ARGUMENT);        }    } else {        Object objStr = arguments.get(0);        if (objStr instanceof COSString) {            validateText(((COSString) objStr).getBytes());        } else if (!(objStr instanceof COSInteger)) {            registerError("Invalid argument for the operator : " + operator.getName(), ERROR_SYNTAX_CONTENT_STREAM_INVALID_ARGUMENT);        }    }}
private void pdfbox_f8650_0(Operator operator, List<?> arguments) throws IOException
{    for (Object object : arguments) {        if (object instanceof COSArray) {            validateStringArray(operator, ((COSArray) object).toList());        } else if (object instanceof COSString) {            validateText(((COSString) object).getBytes());        } else if (!(object instanceof COSInteger || object instanceof COSFloat)) {            registerError("Invalid argument for the operator : " + operator.getName(), ERROR_SYNTAX_CONTENT_STREAM_INVALID_ARGUMENT);            return;        }    }}
public void pdfbox_f8651_0(byte[] string) throws IOException
{        PDTextState textState = getGraphicsState().getTextState();    final RenderingMode renderingMode = textState.getRenderingMode();    final PDFont font = textState.getFont();    if (font == null) {                registerError("Text operator can't be processed without a Font", ERROR_FONTS_UNKNOWN_FONT_REF);        return;    }    FontContainer<?> fontContainer = context.getFontContainer(font.getCOSObject());    if (renderingMode == RenderingMode.NEITHER && (fontContainer == null || !fontContainer.isEmbeddedFont())) {                return;    } else if (fontContainer == null) {                if (font.getName() == null) {            registerError("invalid font dictionary", ERROR_FONTS_UNKNOWN_FONT_REF);        } else {            registerError("font '" + font.getName() + "' is missing", ERROR_FONTS_UNKNOWN_FONT_REF);        }        return;    } else if (!fontContainer.isValid() && !fontContainer.errorsAleadyMerged()) {        context.addValidationErrors(fontContainer.getAllErrors());        fontContainer.setErrorsAlreadyMerged(true);        return;    }    if (!fontContainer.isValid() && fontContainer.errorsAleadyMerged()) {                return;    }    InputStream in = new ByteArrayInputStream(string);    while (in.available() > 0) {        try {            int code = font.readCode(in);            fontContainer.checkGlyphWidth(code);        } catch (IOException e) {            registerError("Encoding can't interpret the character code", ERROR_FONTS_ENCODING_ERROR, e);            return;        } catch (GlyphException e) {            if (renderingMode != RenderingMode.NEITHER) {                registerError(e.getMessage(), e.getErrorCode(), e);                return;            }        }    }}
protected void pdfbox_f8652_0(Operator operator, List<COSBase> arguments) throws ContentStreamException
{    if (OperatorName.SET_RENDERINGINTENT.equals(operator.getName())) {        String riArgument0 = "";        if (arguments.get(0) instanceof COSName) {            riArgument0 = ((COSName) arguments.get(0)).getName();        }        if (!RenderingIntents.contains(riArgument0)) {            registerError("Unexpected value '" + arguments.get(0) + "' for ri operand. ", ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY);        }    }}
protected void pdfbox_f8653_0(Operator operator) throws ContentStreamException
{    if (OperatorName.SAVE.equals(operator.getName())) {        int numberOfGraphicStates = this.getGraphicsStackSize();        if (numberOfGraphicStates > MAX_GRAPHIC_STATES) {            registerError("Too many graphic states", ERROR_GRAPHIC_TOO_MANY_GRAPHIC_STATES);        }    }}
protected void pdfbox_f8654_0(Operator operator) throws ContentStreamException
{    COSDictionary dict = operator.getImageParameters();    /*         * Search a Filter declaration in the InlinedImage dictionary. The LZWDecode Filter is forbidden.         */    COSBase filter = dict.getDictionaryObject(COSName.F, COSName.FILTER);    FilterHelper.isAuthorizedFilter(context, filter instanceof COSName ? ((COSName) filter).getName() : null);}
protected void pdfbox_f8655_0(Operator operator) throws IOException
{    COSDictionary dict = operator.getImageParameters();    COSBase csInlinedBase = dict.getDictionaryObject(COSName.CS, COSName.COLORSPACE);    ColorSpaceHelper csHelper = null;    if (csInlinedBase != null) {        if (csInlinedBase instanceof COSName) {                                    String colorSpace = ((COSName) csInlinedBase).getName();            ColorSpaces cs = null;            try {                cs = ColorSpaces.valueOf(colorSpace);            } catch (IllegalArgumentException e) {                                                PDColorSpace pdCS = this.getResources().getColorSpace(COSName.getPDFName(colorSpace));                if (pdCS != null) {                    cs = ColorSpaces.valueOf(pdCS.getName());                    csHelper = getColorSpaceHelper(pdCS);                }            }            if (cs == null) {                registerError("The ColorSpace " + colorSpace + " is unknown", ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY);                return;            }        }        if (csHelper == null) {                        csInlinedBase = toLongName(csInlinedBase);            if (csInlinedBase instanceof COSArray && ((COSArray) csInlinedBase).size() > 1) {                COSArray srcArray = (COSArray) csInlinedBase;                COSBase csType = srcArray.get(0);                if (COSName.I.equals(csType) || COSName.INDEXED.equals(csType)) {                    COSArray dstArray = new COSArray();                    dstArray.addAll(srcArray);                    dstArray.set(0, COSName.INDEXED);                    dstArray.set(1, toLongName(srcArray.get(1)));                    csInlinedBase = dstArray;                }            }            PDColorSpace pdCS = PDColorSpace.create(csInlinedBase);            csHelper = getColorSpaceHelper(pdCS);        }        csHelper.validate();    }}
private ColorSpaceHelper pdfbox_f8656_0(PDColorSpace pdCS)
{    PreflightConfiguration cfg = context.getConfig();    ColorSpaceHelperFactory csFact = cfg.getColorSpaceHelperFact();    return csFact.getColorSpaceHelper(context, pdCS, ColorSpaceRestriction.ONLY_DEVICE);}
private COSBase pdfbox_f8657_0(COSBase cs)
{    if (COSName.RGB.equals(cs)) {        return COSName.DEVICERGB;    }    if (COSName.CMYK.equals(cs)) {        return COSName.DEVICECMYK;    }    if (COSName.G.equals(cs)) {        return COSName.DEVICEGRAY;    }    return cs;}
protected void pdfbox_f8658_0(String operation) throws ContentStreamException
{    PDColorSpace cs = getColorSpace(operation);    if ((OperatorName.NON_STROKING_RGB.equals(operation) || OperatorName.STROKING_COLOR_RGB.equals(operation)) && !validColorSpace(cs, ColorSpaceType.RGB)) {        registerError("The operator \"" + operation + "\" can't be used with CMYK Profile", ERROR_GRAPHIC_INVALID_COLOR_SPACE_RGB);        return;    }    if ((OperatorName.NON_STROKING_CMYK.equals(operation) || OperatorName.STROKING_COLOR_CMYK.equals(operation)) && !validColorSpace(cs, ColorSpaceType.CMYK)) {        registerError("The operator \"" + operation + "\" can't be used with RGB Profile", ERROR_GRAPHIC_INVALID_COLOR_SPACE_CMYK);        return;    }    if ((OperatorName.NON_STROKING_GRAY.equals(operation) || OperatorName.STROKING_COLOR_GRAY.equals(operation) || OperatorName.FILL_NON_ZERO.equals(operation) || OperatorName.LEGACY_FILL_NON_ZERO.equals(operation) || OperatorName.FILL_EVEN_ODD.equals(operation) || OperatorName.FILL_NON_ZERO_AND_STROKE.equals(operation) || OperatorName.FILL_EVEN_ODD_AND_STROKE.equals(operation) || OperatorName.CLOSE_FILL_NON_ZERO_AND_STROKE.equals(operation) || OperatorName.CLOSE_FILL_EVEN_ODD_AND_STROKE.equals(operation)) && !validColorSpace(cs, ColorSpaceType.ALL)) {        registerError("The operator \"" + operation + "\" can't be used without Color Profile", ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING);    }}
 void pdfbox_f8659_0(Operator operator) throws ContentStreamException
{    boolean v = false;    String op = operator.getName();    if (OperatorName.SHOW_TEXT.equals(op) || OperatorName.SHOW_TEXT_ADJUSTED.equals(op) || OperatorName.SHOW_TEXT_LINE.equals(op) || OperatorName.SHOW_TEXT_LINE_AND_SPACE.equals(op)) {        RenderingMode rm = getGraphicsState().getTextState().getRenderingMode();        if (rm.isFill() && getGraphicsState().getNonStrokingColor().getColorSpace() instanceof PDDeviceGray) {            v = true;        }        if (rm.isStroke() && getGraphicsState().getStrokingColor().getColorSpace() instanceof PDDeviceGray) {            v = true;        }    }        if ((OperatorName.FILL_NON_ZERO.equals(op) || OperatorName.LEGACY_FILL_NON_ZERO.equals(op) || OperatorName.FILL_EVEN_ODD.equals(op) || OperatorName.FILL_NON_ZERO_AND_STROKE.equals(op) || OperatorName.FILL_EVEN_ODD_AND_STROKE.equals(op) || OperatorName.CLOSE_FILL_NON_ZERO_AND_STROKE.equals(op) || OperatorName.CLOSE_FILL_EVEN_ODD_AND_STROKE.equals(op)) && getGraphicsState().getNonStrokingColor().getColorSpace() instanceof PDDeviceGray) {        v = true;    }        if ((OperatorName.FILL_NON_ZERO_AND_STROKE.equals(op) || OperatorName.FILL_EVEN_ODD_AND_STROKE.equals(op) || OperatorName.CLOSE_FILL_NON_ZERO_AND_STROKE.equals(op) || OperatorName.CLOSE_FILL_EVEN_ODD_AND_STROKE.equals(op) || OperatorName.CLOSE_AND_STROKE.equals(op) || OperatorName.STROKE_PATH.equals(op)) && getGraphicsState().getStrokingColor().getColorSpace() instanceof PDDeviceGray) {        v = true;    }    if (v && !validColorSpaceDestOutputProfile(PreflightStreamEngine.ColorSpaceType.ALL)) {        registerError("/DeviceGray default for operator \"" + op + "\" can't be used without Color Profile", ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING);    }}
private boolean pdfbox_f8660_0(PDColorSpace colorSpace, ColorSpaceType expectedIccType) throws ContentStreamException
{    if (colorSpace == null) {        return validColorSpaceDestOutputProfile(expectedIccType);    } else {        return isDeviceIndependent(colorSpace, expectedIccType) || validColorSpaceDestOutputProfile(expectedIccType);    }}
private boolean pdfbox_f8661_0(ColorSpaceType expectedType) throws ContentStreamException
{    try {        ICCProfileWrapper profileWrapper = ICCProfileWrapper.getOrSearchICCProfile(context);        if (profileWrapper == null) {            return false;        }        switch(expectedType) {            case RGB:                return profileWrapper.isRGBColorSpace();            case CMYK:                return profileWrapper.isCMYKColorSpace();            default:                return true;        }    } catch (ValidationException e) {        throw new ContentStreamException(e);    }}
private boolean pdfbox_f8662_0(PDColorSpace cs, ColorSpaceType expectedIccType)
{    if (cs instanceof PDICCBased) {        int type = ((PDICCBased) cs).getColorSpaceType();        switch(expectedIccType) {            case RGB:                return type == ICC_ColorSpace.TYPE_RGB;            case CMYK:                return type == ICC_ColorSpace.TYPE_CMYK;            default:                return true;        }    } else if (cs instanceof PDSeparation) {        return isDeviceIndependent(((PDSeparation) cs).getAlternateColorSpace(), expectedIccType);    } else {        return cs instanceof PDCIEBasedColorSpace;    }}
private PDColorSpace pdfbox_f8663_0(String operation)
{    if (getGraphicsState() == null) {        return null;    }    if (operation.equals("rg") || operation.equals("g") || operation.equals("k") || operation.equals("f") || operation.equals("F") || operation.equals("f*")) {                return getGraphicsState().getNonStrokingColorSpace();    } else {                return getGraphicsState().getStrokingColorSpace();    }}
protected void pdfbox_f8664_0(Operator operator, List<COSBase> arguments) throws IOException
{    if (!OperatorName.STROKING_COLORSPACE.equals(operator.getName()) && !OperatorName.NON_STROKING_COLORSPACE.equals(operator.getName())) {        return;    }    String colorSpaceName;    if (arguments.get(0) instanceof COSString) {        colorSpaceName = (arguments.get(0)).toString();    } else if (arguments.get(0) instanceof COSName) {        colorSpaceName = ((COSName) arguments.get(0)).getName();    } else {        registerError("The operand " + arguments.get(0) + " for colorSpace operator " + operator.getName() + " doesn't have the expected type", ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY);        return;    }    ColorSpaceHelper csHelper = null;    ColorSpaces cs = null;    try {        cs = ColorSpaces.valueOf(colorSpaceName);    } catch (IllegalArgumentException e) {        /*             * The color space is unknown. Try to access the resources dictionary, the color space can be a reference.             */        PDColorSpace pdCS = this.getResources().getColorSpace(COSName.getPDFName(colorSpaceName));        if (pdCS != null) {            cs = ColorSpaces.valueOf(pdCS.getName());            PreflightConfiguration cfg = context.getConfig();            ColorSpaceHelperFactory csFact = cfg.getColorSpaceHelperFact();            csHelper = csFact.getColorSpaceHelper(context, pdCS, ColorSpaceRestriction.NO_RESTRICTION);        }    }    if (cs == null) {        registerError("The ColorSpace " + colorSpaceName + " is unknown", ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY);        return;    }    if (csHelper == null) {        PDColorSpace pdCS = PDColorSpace.create(COSName.getPDFName(colorSpaceName));        PreflightConfiguration cfg = context.getConfig();        ColorSpaceHelperFactory csFact = cfg.getColorSpaceHelperFact();        csHelper = csFact.getColorSpaceHelper(context, pdCS, ColorSpaceRestriction.NO_RESTRICTION);    }    csHelper.validate();}
protected void pdfbox_f8665_0(String msg, String errorCode)
{    registerError(msg, errorCode, null);}
public void pdfbox_f8666_0(String msg, String errorCode, Throwable cause)
{    registerError(msg, errorCode, false, cause);}
protected void pdfbox_f8667_0(String msg, String errorCode, boolean warning)
{    registerError(msg, errorCode, warning, null);}
public void pdfbox_f8668_0(String msg, String errorCode, boolean warning, Throwable cause)
{    ValidationError error = new ValidationError(errorCode, msg, cause);    error.setWarning(warning);    this.context.addValidationError(error);}
public void pdfbox_f8669_0(Operator operator, List<COSBase> arguments) throws IOException
{    String opName = operator.getName();    if (CHECK_NO_OPERANDS.contains(opName)) {        checkNoOperands(arguments);    } else if (CHECK_STRING_OPERANDS.contains(opName)) {        checkStringOperands(arguments, 1);    } else if (CHECK_TAG_AND_PROPERTY_OPERANDS.contains(opName)) {        checkTagAndPropertyOperands(arguments);    } else if (CHECK_NUMBER_OPERANDS_6.contains(opName)) {        checkNumberOperands(arguments, 6);    } else if (CHECK_NUMBER_OPERANDS_4.contains(opName)) {        checkNumberOperands(arguments, 4);    } else if (CHECK_NUMBER_OPERANDS_2.contains(opName)) {        checkNumberOperands(arguments, 2);    } else if (CHECK_NUMBER_OPERANDS.contains(opName)) {        checkNumberOperands(arguments, 1);    } else if (CHECK_ARRAY_OPERANDS.contains(opName)) {        checkArrayOperands(arguments, 1);    } else if (OperatorName.SHOW_TEXT_LINE_AND_SPACE.equals(opName)) {        checkNumberOperands(arguments.subList(0, 2), 2);        checkStringOperands(arguments.subList(2, arguments.size()), 1);    }}
private void pdfbox_f8670_0(List<COSBase> arguments) throws ContentStreamException
{    if (arguments != null && !arguments.isEmpty()) {        throw createInvalidArgumentsError();    }}
private void pdfbox_f8671_0(List<COSBase> arguments, int length) throws ContentStreamException
{    if (arguments == null || arguments.isEmpty() || arguments.size() != length) {        throw createInvalidArgumentsError();    }    for (int i = 0; i < length; ++i) {        COSBase arg = arguments.get(i);        if (!(arg instanceof COSName) && !(arg instanceof COSString)) {            throw createInvalidArgumentsError();        }        if (arg instanceof COSName && ((COSName) arg).getName().length() > MAX_NAME_SIZE) {            throw createLimitError(ERROR_SYNTAX_NAME_TOO_LONG, "A Name operand is too long");        }        if (arg instanceof COSString && ((COSString) arg).getString().getBytes().length > MAX_STRING_LENGTH) {            throw createLimitError(ERROR_SYNTAX_LITERAL_TOO_LONG, "A String operand is too long");        }    }}
private void pdfbox_f8672_0(List<COSBase> arguments, int length) throws ContentStreamException
{    if (arguments == null || arguments.isEmpty() || arguments.size() != length) {        throw createInvalidArgumentsError();    }    for (int i = 0; i < length; ++i) {        COSBase arg = arguments.get(i);        if (!(arg instanceof COSArray)) {            throw createInvalidArgumentsError();        }        if (((COSArray) arg).size() > MAX_ARRAY_ELEMENTS) {            throw createLimitError(ERROR_SYNTAX_ARRAY_TOO_LONG, "Array has " + ((COSArray) arg).size() + " elements");        }    }}
private void pdfbox_f8673_0(List<COSBase> arguments, int length) throws ContentStreamException
{    if (arguments == null || arguments.isEmpty() || arguments.size() != length) {        throw createInvalidArgumentsError();    }    for (COSBase arg : arguments) {        if (!(arg instanceof COSFloat) && !(arg instanceof COSInteger)) {            throw createInvalidArgumentsError();        }        if (arg instanceof COSInteger && (((COSInteger) arg).longValue() > Integer.MAX_VALUE || ((COSInteger) arg).longValue() < Integer.MIN_VALUE)) {            throw createLimitError(ERROR_SYNTAX_NUMERIC_RANGE, "Invalid integer range in a Number operand");        }        if (arg instanceof COSFloat && (((COSFloat) arg).doubleValue() > MAX_POSITIVE_FLOAT || ((COSFloat) arg).doubleValue() < MAX_NEGATIVE_FLOAT)) {            throw createLimitError(ERROR_SYNTAX_NUMERIC_RANGE, "Invalid float range in a Number operand");        }    }}
private void pdfbox_f8674_0(List<COSBase> arguments) throws ContentStreamException
{    if (arguments == null || arguments.isEmpty() || arguments.size() != 2) {        throw createInvalidArgumentsError();    }    COSBase arg = arguments.get(0);    if (!(arg instanceof COSName) && !(arg instanceof COSString)) {        throw createInvalidArgumentsError();    }    if (arg instanceof COSName && ((COSName) arg).getName().length() > MAX_NAME_SIZE) {        throw createLimitError(ERROR_SYNTAX_NAME_TOO_LONG, "A Name operand is too long");    }    if (arg instanceof COSString && ((COSString) arg).getString().getBytes().length > MAX_STRING_LENGTH) {        throw createLimitError(ERROR_SYNTAX_LITERAL_TOO_LONG, "A String operand is too long");    }    COSBase arg2 = arguments.get(1);    if (!(arg2 instanceof COSName) && !(arg2 instanceof COSString) && !(arg2 instanceof COSDictionary)) {        throw createInvalidArgumentsError();    }    if (arg2 instanceof COSName && ((COSName) arg2).getName().length() > MAX_NAME_SIZE) {        throw createLimitError(ERROR_SYNTAX_NAME_TOO_LONG, "A Name operand is too long");    }    if (arg2 instanceof COSString && ((COSString) arg2).getString().getBytes().length > MAX_STRING_LENGTH) {        throw createLimitError(ERROR_SYNTAX_LITERAL_TOO_LONG, "A String operand is too long");    }    if (arg2 instanceof COSDictionary && ((COSDictionary) arg2).size() > MAX_DICT_ENTRIES) {        throw createLimitError(ERROR_SYNTAX_TOO_MANY_ENTRIES, "Dictionary has " + ((COSDictionary) arg2).size() + " entries");    }}
private ContentStreamException pdfbox_f8675_0()
{    ContentStreamException ex = new ContentStreamException("Invalid arguments");    ex.setErrorCode(ERROR_SYNTAX_CONTENT_STREAM_INVALID_ARGUMENT);    return ex;}
private ContentStreamException pdfbox_f8676_0(String errorCode, String details)
{    ContentStreamException ex = new ContentStreamException(details);    ex.setErrorCode(errorCode);    return ex;}
public String pdfbox_f8677_0()
{    return name;}
public String pdfbox_f8678_0()
{    return processName;}
public ValidationResult pdfbox_f8679_0()
{    return result;}
public Integer pdfbox_f8680_0()
{    return pageNumber;}
protected void pdfbox_f8681_0(COSBase ctog)
{    checkCIDToGIDMap(ctog, false);}
protected void pdfbox_f8682_0()
{    this.descriptorHelper = new CIDType0DescriptorHelper(context, font, fontContainer);}
protected void pdfbox_f8683_0(COSBase ctog)
{    checkCIDToGIDMap(ctog, true);}
protected void pdfbox_f8684_0()
{    this.descriptorHelper = new CIDType2DescriptorHelper(context, font, fontContainer);}
public boolean pdfbox_f8685_0(int code) throws IOException
{    return font.codeToGID(code) != 0;}
public boolean pdfbox_f8686_0(int code) throws IOException
{    return font.codeToGID(code) != 0;}
public void pdfbox_f8687_0(ValidationError error)
{    this.errorBuffer.add(error);}
public void pdfbox_f8688_0(List<ValidationError> errors)
{    this.errorBuffer.addAll(errors);}
public List<ValidationError> pdfbox_f8689_0()
{    return this.errorBuffer;}
public boolean pdfbox_f8690_0()
{    return this.errorBuffer.isEmpty() && isEmbeddedFont();}
public boolean pdfbox_f8691_0()
{    return errorsAlreadyMerged;}
public void pdfbox_f8692_0(boolean errorsAlreadyMerged)
{    this.errorsAlreadyMerged = errorsAlreadyMerged;}
public boolean pdfbox_f8693_0()
{    return embeddedFont;}
public void pdfbox_f8694_0()
{    this.embeddedFont = false;}
public void pdfbox_f8695_0(int code) throws GlyphException
{    if (isAlreadyProcessed(code)) {        return;    }    try {                if (!hasGlyph(code)) {            GlyphException e = new GlyphException(PreflightConstants.ERROR_FONTS_GLYPH_MISSING, code, "The character code " + code + " in the font program \"" + font.getName() + "\" is missing from the Character Encoding");            markAsInvalid(code, e);            throw e;        }                float expectedWidth = font.getWidth(code);        float foundWidth = font.getWidthFromFont(code);        checkWidthsConsistency(code, expectedWidth, foundWidth);    } catch (IOException e) {        throw new GlyphException(PreflightConstants.ERROR_FONTS_GLYPH, code, "Unexpected error during the width validation for the character code " + code + " : " + e.getMessage(), e);    }}
private boolean pdfbox_f8696_0(int code) throws GlyphException
{    boolean already = false;    GlyphDetail detail = codeToDetail.get(code);    if (detail != null) {        detail.throwExceptionIfNotValid();        already = true;    }    return already;}
private void pdfbox_f8697_0(int code, float expectedWidth, float foundWidth) throws GlyphException
{        if (Math.abs(foundWidth - expectedWidth) > 1) {        GlyphException e = new GlyphException(PreflightConstants.ERROR_FONTS_METRICS, code, "Width (" + foundWidth + ") of the character \"" + code + "\" in the font program \"" + this.font.getName() + "\" is inconsistent with the width (" + expectedWidth + ") in the PDF dictionary.");        markAsInvalid(code, e);        throw e;    }    markAsValid(code);}
public final void pdfbox_f8698_0(int code)
{    this.codeToDetail.put(code, new GlyphDetail(code));}
public final void pdfbox_f8699_0(int code, GlyphException e)
{    this.codeToDetail.put(code, new GlyphDetail(code, e));}
public boolean pdfbox_f8700_0(int code) throws IOException
{    if (font.isEmbedded()) {        int gid = font.codeToGID(code);        return gid != 0;    }    return false;}
public void pdfbox_f8701_0(FontContainer<?> delegateFontContainer)
{    this.delegateFontContainer = delegateFontContainer;}
public List<ValidationError> pdfbox_f8702_0()
{    if (this.delegateFontContainer != null) {        this.errorBuffer.addAll(this.delegateFontContainer.getAllErrors());    }    return this.errorBuffer;}
public boolean pdfbox_f8703_0()
{    boolean result = (this.errorBuffer.isEmpty() && isEmbeddedFont());    if (this.delegateFontContainer != null) {        result &= this.delegateFontContainer.isValid();    }    return result;}
public boolean pdfbox_f8704_0()
{    boolean result = embeddedFont;    if (this.delegateFontContainer != null) {        result &= this.delegateFontContainer.isEmbeddedFont();    }    return result;}
public boolean pdfbox_f8705_0(int code) throws IOException
{    return this.delegateFontContainer.hasGlyph(code);}
public boolean pdfbox_f8706_0(int code) throws IOException
{    if (font.isEmbedded()) {        String name = font.getEncoding().getName(code);        return font.getFontBoxFont().hasGlyph(name);    }    return false;}
public boolean pdfbox_f8707_0(int code) throws IOException
{    return font.getCharProc(code) != null;}
protected void pdfbox_f8708_0()
{    boolean arePresent = fontDictionary.containsKey(COSName.TYPE);    arePresent &= fontDictionary.containsKey(COSName.SUBTYPE);    arePresent &= fontDictionary.containsKey(COSName.BASE_FONT);    arePresent &= fontDictionary.containsKey(COSName.CIDSYSTEMINFO);    arePresent &= fontDictionary.containsKey(COSName.FONT_DESC);    if (!arePresent) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": Required keys are missing"));    }    checkCIDSystemInfo(fontDictionary.getCOSDictionary(COSName.CIDSYSTEMINFO));    checkCIDToGIDMap(fontDictionary.getDictionaryObject(COSName.CID_TO_GID_MAP));}
protected void pdfbox_f8709_0(COSDictionary sysinfo)
{    if (sysinfo != null) {        String reg = sysinfo.getString(COSName.REGISTRY);        String ord = sysinfo.getString(COSName.ORDERING);        COSBase sup = sysinfo.getDictionaryObject(COSName.SUPPLEMENT);        if (!(reg != null && ord != null && sup instanceof COSInteger)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_SYSINFO));        }    } else {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_SYSINFO));    }}
protected void pdfbox_f8710_0(COSBase ctog, boolean mandatory)
{    if (ctog instanceof COSName) {                if (!COSName.IDENTITY.equals(ctog)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CIDTOGID, font.getName() + ": The CIDToGID entry is invalid"));        }    } else if (ctog instanceof COSStream) {        try {                        InputStream is = ((COSStream) ctog).createInputStream();            is.close();        } catch (IOException e) {                        this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CIDTOGID, font.getName() + ": error getting CIDToGIDMap", e));        }    } else if (mandatory) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CIDTOGID, font.getName() + ": mandatory CIDToGIDMap missing"));    }}
public PDStream pdfbox_f8711_0(PDFontDescriptor fontDescriptor)
{    PDStream ff3 = fontDescriptor.getFontFile3();    if (ff3 != null) {                COSStream stream = ff3.getCOSObject();        if (stream == null) {            this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": The FontFile is missing"));            this.fContainer.notEmbedded();        } else {                                    String st = stream.getNameAsString(COSName.SUBTYPE);            if (!(FONT_DICTIONARY_VALUE_TYPE0C.equals(st) || FONT_DICTIONARY_VALUE_TYPE1C.equals(st))) {                this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": invalid /Subtype /" + st + " in /FontFile3 stream"));            }            checkCIDSet(fontDescriptor);        }    }    return ff3;}
protected void pdfbox_f8712_0(PDFontDescriptor pfDescriptor)
{    if (isSubSet(pfDescriptor.getFontName())) {        COSBase cidset = pfDescriptor.getCOSObject().getDictionaryObject(COSName.CID_SET);        if (!(cidset instanceof COSStream)) {            this.fContainer.push(new ValidationResult.ValidationError(ERROR_FONTS_CIDSET_MISSING_FOR_SUBSET, pfDescriptor.getFontName() + ": The CIDSet entry is missing for the Composite Subset"));        }    }}
protected void pdfbox_f8713_0(PDFontDescriptor fontDescriptor, PDStream fontFile)
{    if (font.isDamaged()) {        this.fContainer.push(new ValidationError(ERROR_FONTS_CID_DAMAGED, font.getName() + ": The FontFile can't be read"));    }}
protected void pdfbox_f8714_0(PDFontDescriptor pfDescriptor)
{    if (isSubSet(pfDescriptor.getFontName())) {        COSBase cidset = pfDescriptor.getCOSObject().getDictionaryObject(COSName.CID_SET);        if (!(cidset instanceof COSStream)) {            this.fContainer.push(new ValidationResult.ValidationError(ERROR_FONTS_CIDSET_MISSING_FOR_SUBSET, pfDescriptor.getFontName() + ": The CIDSet entry is missing for the Composite Subset"));        }    }}
public PDStream pdfbox_f8715_0(PDFontDescriptor fontDescriptor)
{    PDStream ff2 = fontDescriptor.getFontFile2();    if (ff2 != null) {                COSStream stream = ff2.getCOSObject();        if (stream == null) {            this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": The FontFile is missing"));            this.fContainer.notEmbedded();        }    }    checkCIDSet(fontDescriptor);    return ff2;}
protected void pdfbox_f8716_0(PDFontDescriptor fontDescriptor, PDStream fontFile)
{    if (font.isDamaged()) {        this.fContainer.push(new ValidationError(ERROR_FONTS_CID_DAMAGED, font.getName() + ": The FontFile can't be read"));    }}
public void pdfbox_f8717_0()
{    PDFontDescriptor fd = this.font.getFontDescriptor();    boolean isStandard14 = false;    if (this.font instanceof PDFont) {        isStandard14 = ((PDFont) font).isStandard14();    }        if (fd != null) {        fontDescriptor = fd;        if (!isStandard14) {            checkMandatoryFields(fontDescriptor.getCOSObject());        }        if (hasOnlyOneFontFile(fontDescriptor)) {            PDStream fontFile = extractFontFile(fontDescriptor);            if (fontFile != null) {                processFontFile(fontDescriptor, fontFile);                checkFontFileMetaData(fontDescriptor, fontFile);            }        } else {            if (fontFileNotEmbedded(fontDescriptor)) {                this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": FontFile entry is missing from FontDescriptor"));                this.fContainer.notEmbedded();            } else {                this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": They is more than one FontFile"));            }        }    } else {        this.fContainer.push(new ValidationError(ERROR_FONTS_DESCRIPTOR_INVALID, this.font.getName() + ": FontDescriptor is null or is an AFM Descriptor"));        this.fContainer.notEmbedded();    }}
protected boolean pdfbox_f8718_0(COSDictionary fDescriptor)
{    boolean result = true;    StringBuilder missingFields = new StringBuilder();    for (String field : MANDATORYFIELDS) {        if (!fDescriptor.containsKey(field)) {            if (missingFields.length() > 1) {                missingFields.append(", ");            }            missingFields.append(field);        }    }    if (fDescriptor.containsKey(COSName.TYPE)) {        COSBase type = fDescriptor.getItem(COSName.TYPE);        if (!COSName.FONT_DESC.equals(type)) {            this.fContainer.push(new ValidationError(ERROR_FONTS_DESCRIPTOR_INVALID, this.font.getName() + ": /Type in FontDescriptor must be /FontDescriptor, but is " + type));            result = false;        }    }    if (missingFields.length() > 0) {        this.fContainer.push(new ValidationError(ERROR_FONTS_DESCRIPTOR_INVALID, this.font.getName() + ": some mandatory fields are missing from the FontDescriptor: " + missingFields + "."));        result = false;    }    return result;}
protected boolean pdfbox_f8719_0(PDFontDescriptor fontDescriptor)
{    PDStream ff1 = fontDescriptor.getFontFile();    PDStream ff2 = fontDescriptor.getFontFile2();    PDStream ff3 = fontDescriptor.getFontFile3();    return (ff1 != null ^ ff2 != null ^ ff3 != null);}
protected boolean pdfbox_f8720_0(PDFontDescriptor fontDescriptor)
{    PDStream ff1 = fontDescriptor.getFontFile();    PDStream ff2 = fontDescriptor.getFontFile2();    PDStream ff3 = fontDescriptor.getFontFile3();    return (ff1 == null && ff2 == null && ff3 == null);}
protected void pdfbox_f8721_0(PDFontDescriptor fontDescriptor, PDStream fontFile)
{    try {        PDMetadata metadata = fontFile.getMetadata();        if (metadata != null) {                        if (metadata.getFilters() != null && !metadata.getFilters().isEmpty()) {                this.fContainer.push(new ValidationError(ERROR_SYNTAX_STREAM_INVALID_FILTER, this.font.getName() + ": Filter specified in font file metadata dictionnary"));                return;            }            byte[] mdAsBytes = getMetaDataStreamAsBytes(metadata);            try {                DomXmpParser xmpBuilder = new DomXmpParser();                XMPMetadata xmpMeta = xmpBuilder.parse(mdAsBytes);                FontMetaDataValidation fontMDval = new FontMetaDataValidation();                List<ValidationError> ve = new ArrayList<>();                fontMDval.analyseFontName(xmpMeta, fontDescriptor, ve);                fontMDval.analyseRights(xmpMeta, fontDescriptor, ve);                this.fContainer.push(ve);            } catch (XmpParsingException e) {                if (e.getErrorType() == ErrorType.NoValueType) {                    this.fContainer.push(new ValidationError(ERROR_METADATA_UNKNOWN_VALUETYPE, e.getMessage(), e));                } else if (e.getErrorType() == ErrorType.XpacketBadEnd) {                    this.fContainer.push(new ValidationError(ERROR_METADATA_FORMAT_XPACKET, this.font.getName() + ": Unable to parse font metadata due to : " + e.getMessage(), e));                } else {                    this.fContainer.push(new ValidationError(ERROR_METADATA_FORMAT, e.getMessage(), e));                }            }        }    } catch (IllegalStateException e) {        this.fContainer.push(new ValidationError(ERROR_METADATA_FORMAT_UNKOWN, this.font.getName() + ": The Metadata entry doesn't reference a stream object", e));    }}
protected final byte[] pdfbox_f8722_0(PDMetadata metadata)
{    try (InputStream metaDataContent = metadata.createInputStream()) {        return IOUtils.toByteArray(metaDataContent);    } catch (IOException e) {        this.fContainer.push(new ValidationError(ERROR_METADATA_FORMAT_STREAM, this.font.getName() + ": Unable to read font metadata due to : " + e.getMessage(), e));        return null;    }}
public static boolean pdfbox_f8723_0(String fontName)
{    return fontName != null && fontName.matches("^[A-Z]{6}\\+.*");}
public PDStream pdfbox_f8724_0(PDFontDescriptor fontDescriptor)
{    PDStream fontFile = fontDescriptor.getFontFile2();    COSStream stream = (fontFile == null ? null : fontFile.getCOSObject());    if (stream == null) {        this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": The FontFile2 is missing"));        this.fContainer.notEmbedded();        return null;    }    if (stream.getInt(COSName.LENGTH1) <= 0) {        this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": The FontFile entry /Length1 is invalid"));        return null;    }    return fontFile;}
protected void pdfbox_f8725_0(PDFontDescriptor fontDescriptor, PDStream fontFile)
{    if (font.isDamaged()) {        this.fContainer.push(new ValidationError(ERROR_FONTS_TRUETYPE_DAMAGED, this.font.getName() + ": The FontFile can't be read"));    } else {                TrueTypeFont ttf = pdTrueTypeFont.getTrueTypeFont();        try {            if (pdTrueTypeFont.isSymbolic() && ttf.getCmap().getCmaps().length != 1) {                this.fContainer.push(new ValidationError(ERROR_FONTS_ENCODING, this.font.getName() + ": Symbolic TrueType font has more than one 'cmap' entry"));            }        } catch (IOException e) {            this.fContainer.push(new ValidationError(ERROR_FONTS_TRUETYPE_DAMAGED, this.font.getName() + ": The TTF 'cmap' could not be read"));        }    }}
protected boolean pdfbox_f8726_0(COSDictionary fDescriptor)
{    boolean result = super.checkMandatoryFields(fDescriptor);    /*         * if this font is a subset, the CharSet entry must be present in the FontDescriptor         */    if (isSubSet(fontDescriptor.getFontName())) {        String charsetStr = fontDescriptor.getCharSet();        if (charsetStr == null || "".equals(charsetStr)) {            this.fContainer.push(new ValidationError(ERROR_FONTS_CHARSET_MISSING_FOR_SUBSET, fontDescriptor.getFontName() + ": The Charset entry is missing for the Type1 Subset"));            result = false;        }    }    return result;}
public PDStream pdfbox_f8727_0(PDFontDescriptor fontDescriptor)
{    PDStream ff1 = fontDescriptor.getFontFile();    PDStream ff3 = fontDescriptor.getFontFile3();    if (ff1 != null) {        COSStream stream = ff1.getCOSObject();        if (stream == null) {            this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": The FontFile is missing"));            this.fContainer.notEmbedded();            return null;        }        boolean hasLength1 = stream.getInt(COSName.LENGTH1) > 0;        boolean hasLength2 = stream.getInt(COSName.getPDFName(FONT_DICTIONARY_KEY_LENGTH2)) > 0;        boolean hasLength3 = stream.getInt(COSName.getPDFName(FONT_DICTIONARY_KEY_LENGTH3)) >= 0;        if (!(hasLength1 && hasLength2 && hasLength3)) {            this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": The FontFile is invalid"));            return null;        }        return ff1;    } else {        return ff3;    }}
protected void pdfbox_f8728_0(PDFontDescriptor fontDescriptor, PDStream fontFile)
{    if (font.isDamaged()) {        this.fContainer.push(new ValidationError(ERROR_FONTS_TYPE1_DAMAGED, this.font.getName() + ": The FontFile can't be read"));    }}
public T pdfbox_f8731_0()
{    return fontContainer;}
public void pdfbox_f8732_0() throws ValidationException
{    checkMandatoryField();    createFontDescriptorHelper();    processFontDescriptorValidation();    checkEncoding();    checkToUnicode();}
protected void pdfbox_f8733_0()
{    String missingFields = "";    boolean areFieldsPresent = fontDictionary.containsKey(COSName.TYPE);    if (!areFieldsPresent) {        missingFields = "type, ";    }    boolean subType = fontDictionary.containsKey(COSName.SUBTYPE);    areFieldsPresent &= subType;    if (!subType) {        missingFields += "subType, ";    }    boolean baseFont = fontDictionary.containsKey(COSName.BASE_FONT);    areFieldsPresent &= baseFont;    if (!baseFont) {        missingFields += "baseFont, ";    }    boolean firstChar = fontDictionary.containsKey(COSName.FIRST_CHAR);    areFieldsPresent &= firstChar;    if (!firstChar) {        missingFields += "firstChar, ";    }    boolean lastChar = fontDictionary.containsKey(COSName.LAST_CHAR);    areFieldsPresent &= lastChar;    if (!lastChar) {        missingFields += "lastChar, ";    }    boolean widths = fontDictionary.containsKey(COSName.WIDTHS);    areFieldsPresent &= widths;    if (!widths) {        missingFields += "widths, ";    }    if (!areFieldsPresent) {        if (missingFields.endsWith(", ")) {            missingFields = missingFields.substring(0, missingFields.length() - 2);        }        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, this.font.getName() + ": some required fields are missing from the Font dictionary: " + missingFields + "."));    }}
protected void pdfbox_f8734_0()
{    this.descriptorHelper.validate();}
protected void pdfbox_f8735_0()
{    this.descriptorHelper = new TrueTypeDescriptorHelper(context, (PDTrueTypeFont) font, fontContainer);}
protected void pdfbox_f8736_0()
{    PDTrueTypeFont ttFont = (PDTrueTypeFont) font;    PDFontDescriptor fd = ttFont.getFontDescriptor();    if (fd != null) {        /*             * only MacRomanEncoding or WinAnsiEncoding are allowed for a non symbolic font.             */        if (fd.isNonSymbolic()) {            Encoding encodingValue = ttFont.getEncoding();            if (!(encodingValue instanceof MacRomanEncoding || encodingValue instanceof WinAnsiEncoding)) {                this.fontContainer.push(new ValidationError(ERROR_FONTS_ENCODING, fd.getFontName() + ": The Encoding is invalid for the NonSymbolic TTF"));            }        }        /*             * For symbolic font, no encoding entry is allowed and only one encoding entry is expected into the FontFile             * CMap (Check latter when the FontFile stream will be checked)             */        if (fd.isSymbolic() && fontDictionary.getItem(COSName.ENCODING) != null) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_ENCODING, fd.getFontName() + ": The Encoding should be missing for the Symbolic TTF"));        }    }}
public void pdfbox_f8737_0() throws ValidationException
{    checkMandatoryFields();    processDescendantFont();    checkEncoding();    checkToUnicode();}
protected void pdfbox_f8738_0()
{    COSDictionary fontDictionary = font.getCOSObject();    boolean areFieldsPResent = fontDictionary.containsKey(COSName.TYPE);    areFieldsPResent &= fontDictionary.containsKey(COSName.SUBTYPE);    areFieldsPResent &= fontDictionary.containsKey(COSName.BASE_FONT);    areFieldsPResent &= fontDictionary.containsKey(COSName.DESCENDANT_FONTS);    areFieldsPResent &= fontDictionary.containsKey(COSName.ENCODING);    if (!areFieldsPResent) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": Some keys are missing from composite font dictionary"));    }}
protected void pdfbox_f8739_0() throws ValidationException
{    COSDictionary fontDictionary = font.getCOSObject();        COSArray array = fontDictionary.getCOSArray(COSName.DESCENDANT_FONTS);    if (array == null || array.size() != 1) {        /*             * in PDF 1.4, this array must contain only one element, because of a PDF/A should be a PDF 1.4, this method             * returns an error if the array has more than one element.             */        this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_INVALID, font.getName() + ": CIDFont is missing from the DescendantFonts array or the size of array is greater than 1"));        return;    }    COSDictionary cidFont = (COSDictionary) array.getObject(0);    if (cidFont == null) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_INVALID, font.getName() + ": The DescendantFonts array should have one element with is a dictionary."));        return;    }    FontValidator<? extends FontContainer<? extends PDCIDFont>> cidFontValidator = createDescendantValidator(cidFont);    if (cidFontValidator != null) {        this.fontContainer.setDelegateFontContainer(cidFontValidator.getFontContainer());        cidFontValidator.validate();    }}
protected FontValidator<? extends FontContainer<? extends PDCIDFont>> pdfbox_f8740_0(COSDictionary cidFont)
{    COSName subtype = cidFont.getCOSName(COSName.SUBTYPE);    FontValidator<? extends FontContainer<? extends PDCIDFont>> cidFontValidator = null;    if (COSName.CID_FONT_TYPE0.equals(subtype)) {        cidFontValidator = createCIDType0FontValidator(cidFont);    } else if (COSName.CID_FONT_TYPE2.equals(subtype)) {        cidFontValidator = createCIDType2FontValidator(cidFont);    } else {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": Type and/or Subtype keys are missing"));    }    return cidFontValidator;}
protected FontValidator<? extends FontContainer<PDCIDFontType0>> pdfbox_f8741_0(COSDictionary fDict)
{    try {        return new CIDType0FontValidator(context, new PDCIDFontType0(fDict, (PDType0Font) font));    } catch (IOException e) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CID_DAMAGED, font.getName() + ": The CIDType0 font is damaged", e));        return null;    }}
protected FontValidator<? extends FontContainer<PDCIDFontType2>> pdfbox_f8742_0(COSDictionary fDict)
{    try {        return new CIDType2FontValidator(context, new PDCIDFontType2(fDict, (PDType0Font) font));    } catch (IOException e) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CID_DAMAGED, font.getName() + ": The CIDType2 font is damaged", e));        return null;    }}
protected void pdfbox_f8743_0()
{    COSBase encoding = (font.getCOSObject()).getDictionaryObject(COSName.ENCODING);    checkCMapEncoding(encoding);}
protected void pdfbox_f8744_0(COSBase encoding)
{    if (encoding instanceof COSName || encoding instanceof COSString) {                String str = encoding instanceof COSName ? ((COSName) encoding).getName() : ((COSString) encoding).getString();        if (!(FONT_DICTIONARY_VALUE_CMAP_IDENTITY_V.equals(str) || FONT_DICTIONARY_VALUE_CMAP_IDENTITY_H.equals(str))) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_INVALID, font.getName() + ": The CMap is a string but it isn't an Identity-H/V"));        }    } else if (encoding instanceof COSStream) {        /*             * If the CMap is a stream, some fields are mandatory and the CIDSytemInfo must be compared with the             * CIDSystemInfo entry of the CIDFont.             */        processCMapAsStream((COSStream) encoding);    } else {                this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CMAP_INVALID_OR_MISSING, font.getName() + ": The CMap type is invalid"));    }}
private void pdfbox_f8745_0(COSStream aCMap)
{    checkCIDSystemInfo(aCMap.getCOSDictionary(COSName.CIDSYSTEMINFO));    try (InputStream cmapStream = aCMap.createInputStream()) {                CMap fontboxCMap = new CMapParser().parse(cmapStream);        int wmValue = fontboxCMap.getWMode();        String cmnValue = fontboxCMap.getName();        /*             * According to the getInt javadoc, -1 is returned if there is no result. In the PDF Reference v1.7 p449,             * we can read that the default value is 0.             */        int wmode = aCMap.getInt(COSName.getPDFName(FONT_DICTIONARY_KEY_CMAP_WMODE), FONT_DICTIONARY_DEFAULT_CMAP_WMODE);        COSName type = aCMap.getCOSName(COSName.TYPE);        String cmapName = aCMap.getNameAsString(COSName.CMAPNAME);        if (cmapName == null || "".equals(cmapName) || wmode > 1) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CMAP_INVALID_OR_MISSING, font.getName() + ": Some elements in the CMap dictionary are missing or invalid"));        } else if (!(wmValue == wmode && cmapName.equals(cmnValue))) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CMAP_INVALID_OR_MISSING, font.getName() + ": CMapName or WMode is inconsistent"));        } else if (!COSName.CMAP.equals(type)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CMAP_INVALID_OR_MISSING, font.getName() + ": The CMap type is invalid"));        }    } catch (IOException e) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CID_CMAP_DAMAGED, font.getName() + ": The CMap type is damaged", e));    }    COSDictionary cmapUsed = (COSDictionary) aCMap.getDictionaryObject(COSName.getPDFName(FONT_DICTIONARY_KEY_CMAP_USECMAP));    if (cmapUsed != null) {        checkCMapEncoding(cmapUsed);    }    compareCIDSystemInfo(aCMap);}
protected boolean pdfbox_f8746_0(COSDictionary cidSysInfo)
{    boolean result = true;    if (cidSysInfo != null) {        String reg = cidSysInfo.getString(COSName.REGISTRY);        String ord = cidSysInfo.getString(COSName.ORDERING);        COSBase sup = cidSysInfo.getDictionaryObject(COSName.SUPPLEMENT);        if (!(reg != null && ord != null && sup instanceof COSInteger)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_SYSINFO));            result = false;        }    } else {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_SYSINFO));        result = false;    }    return result;}
private void pdfbox_f8747_0(COSDictionary cmap)
{    COSDictionary fontDictionary = font.getCOSObject();    COSArray array = fontDictionary.getCOSArray(COSName.DESCENDANT_FONTS);    if (array != null && array.size() > 0) {        COSDictionary cidFont = (COSDictionary) array.getObject(0);        COSDictionary cmsi = cmap.getCOSDictionary(COSName.CIDSYSTEMINFO);        COSDictionary cfsi = cidFont.getCOSDictionary(COSName.CIDSYSTEMINFO);        String regCM = cmsi.getString(COSName.REGISTRY);        String ordCM = cmsi.getString(COSName.ORDERING);        String regCF = cfsi.getString(COSName.REGISTRY);        String ordCF = cfsi.getString(COSName.ORDERING);        if (!regCF.equals(regCM) || !ordCF.equals(ordCM)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_SYSINFO, font.getName() + ": The CIDSystemInfo is inconsistent"));        }    }}
protected void pdfbox_f8748_0()
{    this.descriptorHelper = new Type1DescriptorHelper(context, (PDSimpleFont) font, fontContainer);}
protected void pdfbox_f8749_0()
{    COSBase encoding = fontDictionary.getDictionaryObject(COSName.ENCODING);    if (encoding != null) {        if (encoding instanceof COSName) {            String encodingName = ((COSName) encoding).getName();            if (!(encodingName.equals(FONT_DICTIONARY_VALUE_ENCODING_MAC) || encodingName.equals(FONT_DICTIONARY_VALUE_ENCODING_MAC_EXP) || encodingName.equals(FONT_DICTIONARY_VALUE_ENCODING_WIN) || encodingName.equals(FONT_DICTIONARY_VALUE_ENCODING_PDFDOC) || encodingName.equals(FONT_DICTIONARY_VALUE_ENCODING_STD))) {                this.fontContainer.push(new ValidationError(ERROR_FONTS_ENCODING));            }        } else if (!(encoding instanceof COSDictionary)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_ENCODING));        }    }}
public void pdfbox_f8750_0() throws ValidationException
{    checkMandatoryField();    checkFontBBox();    checkFontMatrix();    checkEncoding();    checkResources();    checkCharProcsAndMetrics();    checkToUnicode();}
protected void pdfbox_f8751_0()
{    boolean areFieldsPResent = fontDictionary.containsKey(COSName.FONT_BBOX);    areFieldsPResent &= fontDictionary.containsKey(COSName.FONT_MATRIX);    areFieldsPResent &= fontDictionary.containsKey(COSName.CHAR_PROCS);    areFieldsPResent &= fontDictionary.containsKey(COSName.ENCODING);    areFieldsPResent &= fontDictionary.containsKey(COSName.FIRST_CHAR);    areFieldsPResent &= fontDictionary.containsKey(COSName.LAST_CHAR);    areFieldsPResent &= fontDictionary.containsKey(COSName.WIDTHS);    if (!areFieldsPResent) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": Some required fields are missing from the Font dictionary."));    }}
private void pdfbox_f8752_0()
{    COSBase fontBBox = fontDictionary.getDictionaryObject(COSName.FONT_BBOX);    if (!(fontBBox instanceof COSArray)) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The FontBBox element isn't an array"));        return;    }    /*         * check the content of the FontBBox. Should be an array with 4 numbers         */    COSArray bbox = (COSArray) fontBBox;    if (bbox.size() != 4) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The FontBBox element is invalid"));        return;    }    for (int i = 0; i < 4; i++) {        COSBase elt = bbox.get(i);        if (!(elt instanceof COSFloat || elt instanceof COSInteger)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": An element of FontBBox isn't a number"));            return;        }    }}
private void pdfbox_f8753_0()
{    COSBase fontMatrix = fontDictionary.getDictionaryObject(COSName.FONT_MATRIX);    if (!(fontMatrix instanceof COSArray)) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The FontMatrix element isn't an array"));        return;    }    /*         * Check the content of the FontMatrix. Should be an array with 6 numbers         */    COSArray matrix = (COSArray) fontMatrix;    if (matrix.size() != 6) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The FontMatrix element is invalid"));        return;    }    for (int i = 0; i < 6; i++) {        COSBase elt = matrix.get(i);        if (!(elt instanceof COSFloat || elt instanceof COSInteger)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": An element of FontMatrix isn't a number"));            return;        }    }}
protected void pdfbox_f8754_0()
{    COSBase fontEncoding = fontDictionary.getDictionaryObject(COSName.ENCODING);    if (fontEncoding instanceof COSName) {        checkEncodingAsString(((COSName) fontEncoding).getName());    } else if (fontEncoding instanceof COSDictionary) {        checkEncodingAsDictionary((COSDictionary) fontDictionary);    } else {                this.fontContainer.push(new ValidationError(ERROR_FONTS_TYPE3_DAMAGED, font.getName() + ": The Encoding entry doesn't have the right type"));    }}
private void pdfbox_f8755_0(String enc)
{        Encoding encodingInstance = Encoding.getInstance(COSName.getPDFName(enc));    if (encodingInstance == null) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_TYPE3_DAMAGED, "The encoding '" + enc + "' doesn't exist"));    }}
private void pdfbox_f8756_0(COSDictionary encodingDictionary)
{    if (encodingDictionary.containsKey(COSName.BASE_ENCODING)) {        checkEncodingAsString(encodingDictionary.getString(COSName.BASE_ENCODING));    }    COSBase diff = encodingDictionary.getDictionaryObject(COSName.DIFFERENCES);    if (diff != null) {        if (!(diff instanceof COSArray)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_TYPE3_DAMAGED, "The differences element of the encoding dictionary isn't an array"));            return;        }                                COSArray diffArray = (COSArray) diff;        for (int i = 0; i < diffArray.size(); ++i) {            COSBase item = diffArray.get(i);            if (!(item instanceof COSInteger || item instanceof COSName)) {                                this.fontContainer.push(new ValidationError(ERROR_FONTS_TYPE3_DAMAGED, "Differences Array should contain COSInt or COSName, no other type"));                return;            }        }    }}
private void pdfbox_f8757_0() throws ValidationException
{    List<Float> widths = getWidths(font);    if (widths == null || widths.isEmpty()) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The Witdhs array is unreachable"));        return;    }    COSDictionary charProcs = fontDictionary.getCOSDictionary(COSName.CHAR_PROCS);    if (charProcs == null) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The CharProcs element isn't a dictionary"));        return;    }    int fc = font.getCOSObject().getInt(COSName.FIRST_CHAR, -1);    int lc = font.getCOSObject().getInt(COSName.LAST_CHAR, -1);    /*         * wArr length = (lc - fc) + 1 and it is an array of int.          * If FirstChar is greater than LastChar, the validation         * will fail because of the array will have an expected size &lt;= 0.         */    int expectedLength = (lc - fc) + 1;    if (widths.size() != expectedLength) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The length of Witdhs array is invalid. Expected : \"" + expectedLength + "\" Current : \"" + widths.size() + "\""));        return;    }        for (int i = 0; i < expectedLength; i++) {        int code = fc + i;        float width = widths.get(i);        PDType3CharProc charProc = getCharProc(code);        if (charProc != null) {            try {                float fontProgramWidth = getWidthFromCharProc(charProc);                if (Math.abs(width - fontProgramWidth) < 0.001f) {                                                                                                                        this.fontContainer.markAsValid(code);                } else {                    GlyphException glyphEx = new GlyphException(ERROR_FONTS_METRICS, code, font.getName() + ": The character with CID " + code + " should have a width equals to " + width + ", but has " + fontProgramWidth);                    this.fontContainer.markAsInvalid(code, glyphEx);                }            } catch (ContentStreamException e) {                                                this.context.addValidationError(new ValidationError(e.getErrorCode(), e.getMessage(), e));                return;            } catch (IOException e) {                this.fontContainer.push(new ValidationError(ERROR_FONTS_TYPE3_DAMAGED, font.getName() + ": The CharProcs references an element which can't be read", e));                return;            }        }    }}
public List<Float> pdfbox_f8758_0(PDFont font)
{    List<Float> widths;    COSArray array = (COSArray) font.getCOSObject().getDictionaryObject(COSName.WIDTHS);    if (array != null) {        widths = COSArrayList.convertFloatCOSArrayToList(array);    } else {        widths = Collections.emptyList();    }    return widths;}
private PDType3CharProc pdfbox_f8759_0(int code) throws ValidationException
{    PDType3CharProc charProc = font.getCharProc(code);    if (charProc == null) {                        GlyphException glyphEx = new GlyphException(ERROR_FONTS_METRICS, code, font.getName() + ": The CharProcs \"" + font.getEncoding().getName(code) + "\" doesn't exist");        this.fontContainer.markAsInvalid(code, glyphEx);    }    return charProc;}
private float pdfbox_f8760_0(PDType3CharProc charProc) throws IOException
{    PreflightPath vPath = context.getValidationPath();    PreflightType3Stream parser = new PreflightType3Stream(context, vPath.getClosestPathElement(PDPage.class), charProc);    parser.showType3Character(charProc);    return parser.getWidth();}
private void pdfbox_f8761_0() throws ValidationException
{    COSBase resources = this.fontDictionary.getDictionaryObject(COSName.RESOURCES);    if (resources != null) {        if (!(resources instanceof COSDictionary)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The Resources element isn't a dictionary"));            return;        }        COSDictionary dictionary = (COSDictionary) resources;                ContextHelper.validateElement(context, new PDResources(dictionary), RESOURCES_PROCESS);        COSDictionary dicFonts = dictionary.getCOSDictionary(COSName.FONT);        if (dicFonts != null) {            /*                 * Check that all referenced object are present in the PDF file                 */            Set<COSName> keyList = dicFonts.keySet();            for (COSName key : keyList) {                COSDictionary xObjFont = dicFonts.getCOSDictionary(key);                try {                    PDFont aFont = PDFontFactory.createFont(xObjFont);                    FontContainer<?> aContainer = this.context.getFontContainer(aFont.getCOSObject());                                        if (!aContainer.isValid()) {                        this.fontContainer.push(new ValidationError(ERROR_FONTS_TYPE3_DAMAGED, font.getName() + ": The Resources dictionary of type 3 font contains invalid font"));                    }                } catch (IOException e) {                    context.addValidationError(new ValidationError(PreflightConstants.ERROR_FONTS_DAMAGED, font.getName() + ": Unable to valid the Type3 : " + e.getMessage(), e));                }            }        }    }}
public List<ValidationError> pdfbox_f8762_0(XMPMetadata metadata, PDFontDescriptor fontDesc) throws ValidationException
{    List<ValidationError> ve = new ArrayList<>();    analyseFontName(metadata, fontDesc, ve);    analyseRights(metadata, fontDesc, ve);    return ve;}
public boolean pdfbox_f8763_0(XMPMetadata metadata, PDFontDescriptor fontDesc, List<ValidationError> ve)
{    String fontName = fontDesc.getFontName();    String noSubSetName = fontName;    if (FontDescriptorHelper.isSubSet(fontName)) {        noSubSetName = fontName.split("\\+")[1];    }    DublinCoreSchema dc = metadata.getDublinCoreSchema();    if (dc != null && dc.getTitleProperty() != null) {        String defaultTitle = dc.getTitle("x-default");        if (defaultTitle != null) {            if (!defaultTitle.equals(fontName) && (noSubSetName != null && !defaultTitle.equals(noSubSetName))) {                StringBuilder sb = new StringBuilder(80);                sb.append("FontName").append(" present in the FontDescriptor dictionary doesn't match with XMP information dc:title of the Font File Stream.");                ve.add(new ValidationError(PreflightConstants.ERROR_METADATA_MISMATCH, sb.toString()));                return false;            }                        return true;        } else {            Iterator<AbstractField> it = dc.getTitleProperty().getContainer().getAllProperties().iterator();            boolean empty = true;            while (it.hasNext()) {                empty = false;                AbstractField tmp = it.next();                if (tmp instanceof TextType) {                    String val = ((TextType) tmp).getStringValue();                    if (val.equals(fontName) || val.equals(noSubSetName)) {                                                return true;                    }                }            }                        StringBuilder sb = new StringBuilder(80);            sb.append("FontName");            if (empty) {                sb.append(" present in the FontDescriptor dictionary can't be found in XMP information the Font File Stream.");                ve.add(new ValidationError(PreflightConstants.ERROR_METADATA_PROPERTY_MISSING, sb.toString()));            } else {                sb.append(" present in the FontDescriptor dictionary doesn't match with XMP information dc:title of the Font File Stream.");                ve.add(new ValidationError(PreflightConstants.ERROR_METADATA_MISMATCH, sb.toString()));            }            return false;        }    }    return true;}
public boolean pdfbox_f8764_0(XMPMetadata metadata, PDFontDescriptor fontDesc, List<ValidationError> ve)
{    DublinCoreSchema dc = metadata.getDublinCoreSchema();    if (dc != null) {        ArrayProperty copyrights = dc.getRightsProperty();        if (copyrights == null || copyrights.getContainer() == null || copyrights.getContainer().getAllProperties().isEmpty()) {            ve.add(new ValidationError(PreflightConstants.ERROR_METADATA_PROPERTY_MISSING, "CopyRights is missing from the XMP information (dc:rights) of the Font File Stream."));            return false;        }    }    XMPRightsManagementSchema rights = metadata.getXMPRightsManagementSchema();    if (rights != null) {        BooleanType marked = rights.getMarkedProperty();        if (marked != null && !marked.getValue()) {            ve.add(new ValidationError(PreflightConstants.ERROR_METADATA_PROPERTY_MISSING, "the XMP information (xmpRights:Marked) is invalid for the Font File Stream."));            return false;        }    /*             * rights.getUsageTerms() & rights.getOwnerValue() should be present but it is only a recommendation : may             * be it should be useful to append a Warning if these entries are missing.             */    }    return true;}
public void pdfbox_f8765_0() throws GlyphException
{    if (this.exception != null) {        throw this.exception;    }}
public int pdfbox_f8766_0()
{    return this.code;}
public String pdfbox_f8767_0()
{    return errorCode;}
public int pdfbox_f8768_0()
{    return invalidCid;}
public void pdfbox_f8769_0(PDType3CharProc charProc) throws IOException
{        processChildStream(charProc, new PDPage());}
public Image pdfbox_f8770_0() throws IOException
{    showType3Character(charProc);    return image.getImage();}
protected void pdfbox_f8771_0(Operator operator, List<COSBase> operands) throws IOException
{    super.processOperator(operator, operands);    String operation = operator.getName();    if (operation.equals(OperatorName.BEGIN_INLINE_IMAGE)) {        image = new PDInlineImage(operator.getImageParameters(), operator.getImageData(), getResources());        validateInlineImageFilter(operator);        validateInlineImageColorSpace(operator);    }    if (operation.equals(OperatorName.TYPE3_D0)) {        checkType3FirstOperator(operands);    } else if (operation.equals(OperatorName.TYPE3_D1)) {        COSNumber llx = (COSNumber) operands.get(2);        COSNumber lly = (COSNumber) operands.get(3);        COSNumber urx = (COSNumber) operands.get(4);        COSNumber ury = (COSNumber) operands.get(5);        box = new BoundingBox();        box.setLowerLeftX(llx.floatValue());        box.setLowerLeftY(lly.floatValue());        box.setUpperRightX(urx.floatValue());        box.setUpperRightY(ury.floatValue());        checkType3FirstOperator(operands);    }    checkColorOperators(operation);    validateRenderingIntent(operator, operands);    checkSetColorSpaceOperators(operator, operands);    validateNumberOfGraphicStates(operator);    firstOperator = false;}
private void pdfbox_f8772_0(List<COSBase> arguments) throws IOException
{    if (!firstOperator) {        throw new IOException("Type3 CharProc : First operator must be d0 or d1");    }    COSBase obj = arguments.get(0);    if (obj instanceof COSNumber) {        width = ((COSNumber) obj).floatValue();    } else {        throw new IOException("Unexpected argument type. Expected : COSInteger or Number / Received : " + obj.getClass().getName());    }}
public float pdfbox_f8773_0()
{    return this.width;}
public String pdfbox_f8774_0()
{    return fname;}
public ColorSpaceHelper pdfbox_f8775_0(PreflightContext context, PDColorSpace cs, ColorSpaceRestriction csr)
{    switch(csr) {        case NO_PATTERN:            return new NoPatternColorSpaceHelper(context, cs);        case ONLY_DEVICE:            return new DeviceColorSpaceHelper(context, cs);        default:            return new StandardColorSpaceHelper(context, cs);    }}
public String pdfbox_f8776_0()
{    return label;}
public void pdfbox_f8777_0(String label)
{    this.label = label;}
protected void pdfbox_f8778_0(PDColorSpace colorSpace)
{    context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_FORBIDDEN, "Pattern ColorSpace is forbidden"));}
protected void pdfbox_f8779_0(PDColorSpace colorSpace)
{    context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_FORBIDDEN, "DeviceN ColorSpace is forbidden"));}
protected void pdfbox_f8780_0(PDColorSpace colorSpace)
{    PDIndexed indexed = (PDIndexed) colorSpace;    PDColorSpace baseColorSpace = indexed.getBaseColorSpace();    ColorSpaces colorSpaces = ColorSpaces.valueOf(baseColorSpace.getName());    switch(colorSpaces) {        case Indexed:        case I:        case Pattern:            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_FORBIDDEN, colorSpaces.getLabel() + " ColorSpace is forbidden"));            break;        default:            processAllColorSpace(baseColorSpace);    }}
public int pdfbox_f8781_0()
{    return colorSpace.getType();}
public ICC_Profile pdfbox_f8782_0()
{    return profile;}
public boolean pdfbox_f8783_0()
{    return ICC_ColorSpace.TYPE_RGB == colorSpace.getType();}
public boolean pdfbox_f8784_0()
{    return ICC_ColorSpace.TYPE_CMYK == colorSpace.getType();}
public boolean pdfbox_f8785_0()
{    return ICC_ColorSpace.TYPE_GRAY == colorSpace.getType();}
private static ICCProfileWrapper pdfbox_f8786_0(PreflightContext context)
{    PreflightDocument document = context.getDocument();    PDDocumentCatalog catalog = document.getDocumentCatalog();    COSArray outputIntents = catalog.getCOSObject().getCOSArray(COSName.OUTPUT_INTENTS);    for (int i = 0; outputIntents != null && i < outputIntents.size(); ++i) {        COSDictionary outputIntentDict = (COSDictionary) outputIntents.getObject(i);        COSBase destOutputProfile = outputIntentDict.getDictionaryObject(COSName.DEST_OUTPUT_PROFILE);        if (destOutputProfile instanceof COSStream) {            try (InputStream is = ((COSStream) destOutputProfile).createInputStream()) {                return new ICCProfileWrapper(ICC_Profile.getInstance(is));            } catch (IllegalArgumentException e) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_ICC_PROFILE_INVALID, "DestOutputProfile isn't a valid ICCProfile. Caused by : " + e.getMessage(), e));            } catch (IOException e) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_ICC_PROFILE_INVALID, "Unable to parse the ICCProfile. Caused by : " + e.getMessage(), e));            }        }    }    return null;}
public static ICCProfileWrapper pdfbox_f8787_0(PreflightContext context) throws ValidationException
{    ICCProfileWrapper profileWrapper = context.getIccProfileWrapper();    if (profileWrapper == null && !context.isIccProfileAlreadySearched()) {        profileWrapper = searchFirstICCProfile(context);        context.setIccProfileAlreadySearched(true);    }    return profileWrapper;}
protected void pdfbox_f8788_0(PDColorSpace colorSpace)
{    context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_PATTERN_COLOR_SPACE_FORBIDDEN, "Pattern color space is forbidden"));}
public final void pdfbox_f8789_0() throws ValidationException
{    if (pdcs == null) {        throw new ValidationException("Unable to create a PDColorSpace with the value null");    }    this.iccpw = ICCProfileWrapper.getOrSearchICCProfile(context);    processAllColorSpace(pdcs);}
protected final void pdfbox_f8790_0(PDColorSpace colorSpace)
{    ColorSpaces cs = ColorSpaces.valueOf(colorSpace.getName());    switch(cs) {        case DeviceRGB:        case RGB:            processRGBColorSpace(colorSpace);            break;        case DeviceCMYK:        case CMYK:            processCYMKColorSpace(colorSpace);            break;        case CalRGB:        case CalGray:        case Lab:            processCalibratedColorSpace(colorSpace);            break;        case DeviceGray:        case G:            processGrayColorSpace(colorSpace);            break;        case ICCBased:            processICCBasedColorSpace(colorSpace);            break;        case DeviceN:            processDeviceNColorSpace(colorSpace);            break;        case Indexed:        case I:            processIndexedColorSpace(colorSpace);            break;        case Separation:            processSeparationColorSpace(colorSpace);            break;        case Pattern:            processPatternColorSpace(colorSpace);            break;        default:            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_UNKNOWN_COLOR_SPACE, cs.getLabel() + " is unknown as ColorSpace"));    }}
protected void pdfbox_f8791_0(PDColorSpace colorSpace)
{    if (!processDefaultColorSpace(colorSpace)) {        if (iccpw == null) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING, "DestOutputProfile is missing"));        } else if (!iccpw.isRGBColorSpace()) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_RGB, "DestOutputProfile isn't RGB ColorSpace"));        }    }}
protected void pdfbox_f8792_0(PDColorSpace colorSpace)
{    if (!processDefaultColorSpace(colorSpace)) {        if (iccpw == null) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING, "DestOutputProfile is missing"));        } else if (!iccpw.isCMYKColorSpace()) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_CMYK, "DestOutputProfile isn't CMYK ColorSpace"));        }    }}
protected void pdfbox_f8793_0(PDColorSpace colorSpace)
{    if (iccpw == null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING, "DestOutputProfile is missing"));    }}
protected void pdfbox_f8794_0(PDColorSpace colorSpace)
{    if (!processDefaultColorSpace(colorSpace) && iccpw == null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING, "DestOutputProfile is missing"));    }}
protected void pdfbox_f8796_0(PDColorSpace colorSpace)
{    PDICCBased iccBased = (PDICCBased) colorSpace;    try {        ICC_Profile iccp;        try (InputStream is = iccBased.getPDStream().createInputStream()) {                                    iccp = ICC_Profile.getInstance(is);        }        PDColorSpace altpdcs = iccBased.getAlternateColorSpace();        if (altpdcs != null) {            ColorSpaces altCsId = ColorSpaces.valueOf(altpdcs.getName());            if (altCsId == ColorSpaces.Pattern) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_PATTERN_COLOR_SPACE_FORBIDDEN, "Pattern is forbidden as AlternateColorSpace of a ICCBased"));            }                        if (!validateICCProfileNEntry(iccBased.getPDStream().getCOSObject(), iccp)) {                return;            }            if (!validateICCProfileVersion(iccp)) {                return;            }            validateICCProfileAlternateEntry(iccBased);        }    } catch (IllegalArgumentException e) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_ICCBASED, "ICCBased color space is invalid: " + e.getMessage(), e));    } catch (IOException e) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE, "Unable to read ICCBase color space: " + e.getMessage(), e));    }}
protected void pdfbox_f8797_0(PDColorSpace colorSpace)
{    PDDeviceN deviceN = (PDDeviceN) colorSpace;    try {        if (iccpw == null) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING, "DestOutputProfile is missing"));            return;        }        COSBase cosAlt = ((COSArray) colorSpace.getCOSObject()).getObject(2);        PDColorSpace altColor = PDColorSpace.create(cosAlt);        if (altColor != null) {            processAllColorSpace(altColor);        }        int numberOfColorants = 0;        PDDeviceNAttributes attr = deviceN.getAttributes();        if (attr != null) {            final Map<String, PDSeparation> colorants = attr.getColorants();            numberOfColorants = colorants.size();            for (PDSeparation col : colorants.values()) {                if (col != null) {                    processAllColorSpace(col);                }            }            PDDeviceNProcess process = attr.getProcess();            if (process != null) {                processAllColorSpace(process.getColorSpace());            }        }        int numberOfComponents = deviceN.getNumberOfComponents();        if (numberOfColorants > MAX_DEVICE_N_LIMIT || numberOfComponents > MAX_DEVICE_N_LIMIT) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_TOO_MANY_COMPONENTS_DEVICEN, "DeviceN has too many tint components or colorants"));        }    } catch (IOException e) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE, "Unable to read DeviceN color space : " + e.getMessage(), e));    }}
protected void pdfbox_f8798_0(PDColorSpace colorSpace)
{    PDIndexed indexed = (PDIndexed) colorSpace;    PDColorSpace based = indexed.getBaseColorSpace();    ColorSpaces cs = ColorSpaces.valueOf(based.getName());    if (cs == ColorSpaces.Indexed || cs == ColorSpaces.I) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_INDEXED, "Indexed color space can't be used as Base color space"));        return;    }    if (cs == ColorSpaces.Pattern) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_INDEXED, "Pattern color space can't be used as Base color space"));        return;    }    processAllColorSpace(based);}
protected void pdfbox_f8799_0(PDColorSpace colorSpace)
{    try {        COSBase cosAlt = ((COSArray) colorSpace.getCOSObject()).getObject(2);        PDColorSpace altCol = PDColorSpace.create(cosAlt);        if (altCol != null) {            ColorSpaces acs = ColorSpaces.valueOf(altCol.getName());            switch(acs) {                case Separation:                case DeviceN:                case Pattern:                case Indexed:                case I:                    context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_ALTERNATE, acs.getLabel() + " color space can't be used as alternate color space"));                    break;                default:                    processAllColorSpace(altCol);            }        }    } catch (IOException e) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE, "Unable to read Separation color space : " + e.getMessage(), e));    }}
protected boolean pdfbox_f8800_0(PDColorSpace colorSpace)
{    boolean result = false;        PreflightPath vPath = context.getValidationPath();    PDResources resources = vPath.getClosestPathElement(PDResources.class);    if (resources != null) {        PDColorSpace defaultCS = null;        try {            if (colorSpace.getName().equals(ColorSpaces.DeviceCMYK.getLabel()) && resources.hasColorSpace(COSName.DEFAULT_CMYK)) {                defaultCS = resources.getColorSpace(COSName.DEFAULT_CMYK);            } else if (colorSpace.getName().equals(ColorSpaces.DeviceRGB.getLabel()) && resources.hasColorSpace(COSName.DEFAULT_RGB)) {                defaultCS = resources.getColorSpace(COSName.DEFAULT_RGB);            } else if (colorSpace.getName().equals(ColorSpaces.DeviceGray.getLabel()) && resources.hasColorSpace(COSName.DEFAULT_GRAY)) {                defaultCS = resources.getColorSpace(COSName.DEFAULT_GRAY);            }        } catch (IOException e) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE, "Unable to read default color space : " + e.getMessage(), e));        }        if (defaultCS != null) {                        int nbOfErrors = context.getDocument().getResult().getErrorsList().size();            processAllColorSpace(defaultCS);            int newNbOfErrors = context.getDocument().getResult().getErrorsList().size();            result = (nbOfErrors == newNbOfErrors);        }    }    return result;}
private boolean pdfbox_f8801_0(ICC_Profile iccp)
{    PreflightConfiguration config = context.getConfig();        if (iccp.getMajorVersion() == 2) {        if (iccp.getMinorVersion() > 0x40) {                                                ValidationError error = new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_ICC_PROFILE_TOO_RECENT, "Invalid version of the ICCProfile");            error.setWarning(config.isLazyValidation());            context.addValidationError(error);            return false;        }        } else if (iccp.getMajorVersion() > 2) {                                ValidationError error = new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_ICC_PROFILE_TOO_RECENT, "Invalid version of the ICCProfile");        error.setWarning(config.isLazyValidation());        context.addValidationError(error);        return false;    }        return true;}
private boolean pdfbox_f8802_0(COSStream stream, ICC_Profile iccp) throws IOException
{    COSDictionary streamDict = (COSDictionary) stream.getCOSObject();    if (!streamDict.containsKey(COSName.N)) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "/N entry of ICC profile is mandatory"));        return false;    }    COSBase nValue = streamDict.getItem(COSName.N);    if (!(nValue instanceof COSNumber)) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "/N entry of ICC profile must be a number, but is " + nValue));        return false;    }    int nNumberValue = ((COSNumber) nValue).intValue();    if (nNumberValue != 1 && nNumberValue != 3 && nNumberValue != 4) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "/N entry of ICC profile must be 1, 3 or 4, but is " + nNumberValue));        return false;    }    if (iccp.getNumComponents() != nNumberValue) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "/N entry of ICC profile is " + nNumberValue + " but the ICC profile has " + iccp.getNumComponents() + " components"));        return false;    }    return true;}
private void pdfbox_f8803_0(PDICCBased iccBased) throws IOException
{    PDColorSpace altCS = iccBased.getAlternateColorSpace();    if (altCS != null && altCS.getNumberOfComponents() != iccBased.getNumberOfComponents()) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "/N entry of ICC profile is different (" + iccBased.getNumberOfComponents() + ") than alternate entry colorspace component count (" + altCS.getNumberOfComponents() + ")"));    }}
public List<ValidationError> pdfbox_f8804_0(XMPMetadata metadata) throws ValidationException
{    List<ValidationError> ve = new ArrayList<>();    PDFAIdentificationSchema id = metadata.getPDFIdentificationSchema();    if (id == null) {        ve.add(new ValidationError(ERROR_METADATA_PDFA_ID_MISSING, "PDF/A identification schema " + PDFAIdentificationSchema.class.getAnnotation(StructuredType.class).namespace() + " is missing"));        return ve;    }        StructuredType stBasic = XMPBasicSchema.class.getAnnotation(StructuredType.class);    StructuredType stPdfaIdent = PDFAIdentificationSchema.class.getAnnotation(StructuredType.class);    if (!id.getPrefix().equals(stPdfaIdent.preferedPrefix())) {        if (metadata.getSchema(stPdfaIdent.preferedPrefix(), stBasic.namespace()) == null) {            ve.add(unexpectedPrefixFoundError(id.getPrefix(), stPdfaIdent.preferedPrefix(), PDFAIdentificationSchema.class.getName()));        } else {            id = (PDFAIdentificationSchema) metadata.getSchema(stPdfaIdent.preferedPrefix(), stPdfaIdent.namespace());        }    }    checkConformanceLevel(ve, id.getConformance());    checkPartNumber(ve, id.getPart() == null ? -1 : id.getPart());    return ve;}
protected ValidationError pdfbox_f8805_0(String prefFound, String prefExpected, String schema)
{    StringBuilder sb = new StringBuilder(80);    sb.append(schema).append(" found but prefix used is '").append(prefFound).append("', prefix '").append(prefExpected).append("' is expected.");    return new ValidationError(ERROR_METADATA_WRONG_NS_PREFIX, sb.toString());}
protected void pdfbox_f8806_0(List<ValidationError> ve, String value)
{    if (value == null || !(value.equals("A") || value.equals("B"))) {        ve.add(new ValidationError(ERROR_METADATA_INVALID_PDFA_CONFORMANCE));    }}
protected void pdfbox_f8807_0(List<ValidationError> ve, int value)
{    if (value != 1) {        ve.add(new ValidationError(ERROR_METADATA_INVALID_PDFA_VERSION_ID));    }}
public void pdfbox_f8808_0(XMPMetadata metadata) throws ValidationException, DifferentRDFAboutException
{    List<XMPSchema> schemas = metadata.getAllSchemas();    if (schemas.isEmpty()) {        throw new ValidationException("Schemas not found in the given metadata representation");    }    String about = schemas.get(0).getAboutValue();        for (XMPSchema xmpSchema : schemas) {                String schemaAboutValue = xmpSchema.getAboutValue();        if (!("".equals(schemaAboutValue) || "".equals(about) || about.equals(schemaAboutValue))) {            throw new DifferentRDFAboutException();        }        if ("".equals(about)) {            about = schemaAboutValue;        }    }}
protected void pdfbox_f8809_0(PDDocumentInformation dico, DublinCoreSchema dc, List<ValidationError> ve)
{    String title = dico.getTitle();    if (title != null) {                title = removeTrailingNul(title);        if (dc != null) {                        if (dc.getTitle() != null) {                if (dc.getTitle("x-default") != null) {                    if (!dc.getTitle("x-default").equals(title)) {                        ve.add(unsynchronizedMetaDataError("Title"));                    }                } else {                                                                                                    Iterator<AbstractField> it = dc.getTitleProperty().getContainer().getAllProperties().iterator();                    if (it.hasNext()) {                        AbstractField tmp = it.next();                        if (tmp instanceof TextType) {                            if (!((TextType) tmp).getStringValue().equals(title)) {                                ve.add(unsynchronizedMetaDataError("Title"));                            }                        } else {                            ve.add(absentXMPPropertyError("Title", "Property is badly defined"));                        }                    } else {                        ve.add(absentXMPPropertyError("Title", "Property is not defined"));                    }                }            } else {                ve.add(absentXMPPropertyError("Title", "Property is not defined"));            }        } else {            ve.add(absentSchemaMetaDataError("Title", "Dublin Core"));        }    }}
protected void pdfbox_f8810_0(PDDocumentInformation dico, DublinCoreSchema dc, List<ValidationError> ve)
{    String author = dico.getAuthor();    if (author != null) {                author = removeTrailingNul(author);        if (dc != null) {            if (dc.getCreatorsProperty() != null) {                if (dc.getCreators().size() != 1) {                    ve.add(absentXMPPropertyError("Author", "In XMP metadata, Author(s) must be represented by a single entry in a text array (dc:creator) "));                } else {                    if (dc.getCreators().get(0) == null) {                        ve.add(absentXMPPropertyError("Author", "Property is defined as null"));                    } else {                        if (!dc.getCreators().get(0).equals(author)) {                            ve.add(unsynchronizedMetaDataError("Author"));                        }                    }                }            } else {                ve.add(absentXMPPropertyError("Author", "Property is not defined in XMP Metadata"));            }        } else {            ve.add(absentSchemaMetaDataError("Author", "Dublin Core"));        }    }}
protected void pdfbox_f8811_0(PDDocumentInformation dico, DublinCoreSchema dc, List<ValidationError> ve)
{    String subject = dico.getSubject();    if (subject != null) {                subject = removeTrailingNul(subject);        if (dc != null) {                        if (dc.getDescriptionProperty() != null) {                if (dc.getDescription("x-default") == null) {                    ve.add(absentXMPPropertyError("Subject", "Subject not found in XMP (dc:description[\"x-default\"] not found)"));                } else {                    if (!dc.getDescription("x-default").equals(subject)) {                        ve.add(unsynchronizedMetaDataError("Subject"));                    }                }            } else {                ve.add(absentXMPPropertyError("Subject", "Property is defined as null"));            }        } else {            ve.add(absentSchemaMetaDataError("Subject", "Dublin Core"));        }    }}
protected void pdfbox_f8812_0(PDDocumentInformation dico, AdobePDFSchema pdf, List<ValidationError> ve)
{    String keyword = dico.getKeywords();    if (keyword != null) {                keyword = removeTrailingNul(keyword);        if (pdf != null) {            if (pdf.getKeywordsProperty() == null) {                ve.add(absentXMPPropertyError("Keywords", "Property is not defined"));            } else {                if (!pdf.getKeywords().equals(keyword)) {                    ve.add(unsynchronizedMetaDataError("Keywords"));                }            }        } else {            ve.add(absentSchemaMetaDataError("Keywords", "PDF"));        }    }}
protected void pdfbox_f8813_0(PDDocumentInformation dico, AdobePDFSchema pdf, List<ValidationError> ve)
{    String producer = dico.getProducer();    if (producer != null) {                producer = removeTrailingNul(producer);        if (pdf != null) {            if (pdf.getProducerProperty() == null) {                ve.add(absentXMPPropertyError("Producer", "Property is not defined"));            } else {                if (!pdf.getProducer().equals(producer)) {                    ve.add(unsynchronizedMetaDataError("Producer"));                }            }        } else {            ve.add(absentSchemaMetaDataError("Producer", "PDF"));        }    }}
protected void pdfbox_f8814_0(PDDocumentInformation dico, XMPBasicSchema xmp, List<ValidationError> ve)
{    String creatorTool = dico.getCreator();    if (creatorTool != null) {                creatorTool = removeTrailingNul(creatorTool);        if (xmp != null) {            if (xmp.getCreatorToolProperty() == null) {                ve.add(absentXMPPropertyError("CreatorTool", "Property is not defined"));            } else {                if (!xmp.getCreatorTool().equals(creatorTool)) {                    ve.add(unsynchronizedMetaDataError("CreatorTool"));                }            }        } else {            ve.add(absentSchemaMetaDataError("CreatorTool", "PDF"));        }    }}
protected void pdfbox_f8815_0(PDDocumentInformation dico, XMPBasicSchema xmp, List<ValidationError> ve) throws ValidationException
{    Calendar creationDate = dico.getCreationDate();    COSBase item = dico.getCOSObject().getItem(COSName.CREATION_DATE);    if (creationDate != null && isValidPDFDateFormat(item)) {        if (xmp != null) {            Calendar xmpCreationDate = xmp.getCreateDate();            if (xmpCreationDate == null) {                ve.add(absentXMPPropertyError("CreationDate", "Property is not defined"));            } else {                if (xmpCreationDate.compareTo(creationDate) != 0) {                    ve.add(unsynchronizedMetaDataError("CreationDate"));                } else if (hasTimeZone(xmp.getCreateDateProperty().getRawValue()) != hasTimeZone(dico.getPropertyStringValue("CreationDate"))) {                    ve.add(unsynchronizedMetaDataError("CreationDate"));                }            }        } else {            ve.add(absentSchemaMetaDataError("CreationDate", "Basic XMP"));        }    }}
protected void pdfbox_f8816_0(PDDocumentInformation dico, XMPBasicSchema xmp, List<ValidationError> ve) throws ValidationException
{    Calendar modifyDate = dico.getModificationDate();    COSBase item = dico.getCOSObject().getItem(COSName.MOD_DATE);    if (modifyDate != null && isValidPDFDateFormat(item)) {        if (xmp != null) {            Calendar xmpModifyDate = xmp.getModifyDate();            if (xmpModifyDate == null) {                ve.add(absentXMPPropertyError("ModifyDate", "Property is not defined"));            } else {                if (xmpModifyDate.compareTo(modifyDate) != 0) {                    ve.add(unsynchronizedMetaDataError("ModificationDate"));                } else if (hasTimeZone(xmp.getModifyDateProperty().getRawValue()) != hasTimeZone(dico.getPropertyStringValue("ModDate"))) {                    ve.add(unsynchronizedMetaDataError("ModificationDate"));                }            }        } else {            ve.add(absentSchemaMetaDataError("ModifyDate", "Basic XMP"));        }    }}
public List<ValidationError> pdfbox_f8817_0(PDDocument document, XMPMetadata metadata) throws ValidationException
{    List<ValidationError> ve = new ArrayList<>();    if (document == null) {        throw new ValidationException("Document provided is null");    } else {        PDDocumentInformation dico = document.getDocumentInformation();        if (metadata == null) {            throw new ValidationException("Metadata provided are null");        } else {            DublinCoreSchema dc = metadata.getDublinCoreSchema();                        analyzeTitleProperty(dico, dc, ve);                        analyzeAuthorProperty(dico, dc, ve);                        analyzeSubjectProperty(dico, dc, ve);            AdobePDFSchema pdf = metadata.getAdobePDFSchema();                        analyzeKeywordsProperty(dico, pdf, ve);                        analyzeProducerProperty(dico, pdf, ve);            XMPBasicSchema xmp = metadata.getXMPBasicSchema();                        analyzeCreatorToolProperty(dico, xmp, ve);                        analyzeCreationDateProperty(dico, xmp, ve);                        analyzeModifyDateProperty(dico, xmp, ve);        }    }    return ve;}
protected ValidationError pdfbox_f8818_0(String prefFound, String prefExpected, String schema)
{    StringBuilder sb = new StringBuilder(80);    sb.append(schema).append(" found but prefix used is '").append(prefFound).append("', prefix '").append(prefExpected).append("' is expected.");    return new ValidationError(PreflightConstants.ERROR_METADATA_WRONG_NS_PREFIX, sb.toString());}
protected ValidationException pdfbox_f8819_0(String target, Throwable cause)
{    StringBuilder sb = new StringBuilder(80);    sb.append("Cannot access to the ").append(target).append(" schema");    return new ValidationException(sb.toString(), cause);}
protected ValidationError pdfbox_f8820_0(String target)
{    StringBuilder sb = new StringBuilder(80);    sb.append(target).append(" present in the document catalog dictionary doesn't match with XMP information");    return new ValidationError(PreflightConstants.ERROR_METADATA_MISMATCH, sb.toString());}
protected ValidationError pdfbox_f8821_0(String target, String schema)
{    StringBuilder sb = new StringBuilder(80);    sb.append(target).append(" present in the document catalog dictionary can't be found in XMP information (").append(schema).append(" schema not declared)");    return new ValidationError(PreflightConstants.ERROR_METADATA_MISMATCH, sb.toString());}
protected ValidationError pdfbox_f8822_0(String target, String details)
{    StringBuilder sb = new StringBuilder(80);    sb.append(target).append(" present in the document catalog dictionary can't be found in XMP information (").append(details).append(")");    return new ValidationError(PreflightConstants.ERROR_METADATA_MISMATCH, sb.toString());}
private String pdfbox_f8823_0(String string)
{        int length = string.length();    while (length > 0 && string.charAt(length - 1) == 0) {        length--;    }    return string.substring(0, length);}
private boolean pdfbox_f8824_0(Object date)
{    final String datePattern = "^D:.*[Z]$|^D:.*[+-].*|^\\d{4}.*T.*Z(\\d{2}:\\d{2}){0,1}$|^\\d{4}.*T.*[+-]\\d{2}.*$";    if (date instanceof Calendar) {                return true;    } else if (date instanceof String) {        return Pattern.matches(datePattern, (String) date);    }    return false;}
private boolean pdfbox_f8825_0(COSBase item)
{    if (item instanceof COSString) {        String date = ((COSString) item).getString();        if (date.matches("D:\\d{4}(\\d{2}(\\d{2}(\\d{2}(\\d{2}(\\d{2}([\\+\\-Z](\\d{2}'\\d{2}')?)?)?)?)?)?)?")) {            return true;        }    }    return false;}
public ValidationError pdfbox_f8826_0()
{    return error;}
protected static ValidationResult pdfbox_f8827_0()
{    ValidationError error = new ValidationError(PreflightConstants.ERROR_UNKOWN_ERROR);    return new ValidationResult(error);}
protected void pdfbox_f8828_0(ValidationError error)
{    if (this.validationResult == null) {        this.validationResult = new ValidationResult(error.isWarning());    }    this.validationResult.addError(error);}
protected void pdfbox_f8829_0(List<ValidationError> errors)
{    errors.forEach(this::addValidationError);}
public void pdfbox_f8830_0() throws IOException
{    parse(Format.PDF_A1B);}
public void pdfbox_f8831_0(Format format) throws IOException
{    parse(format, null);}
public void pdfbox_f8832_0(Format format, PreflightConfiguration config) throws IOException
{    checkPdfHeader();    try {        super.parse();    } catch (IOException e) {        addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_COMMON, e.getMessage()));        throw new SyntaxValidationException(e, this.validationResult);    } finally {                IOUtils.closeQuietly(source);    }    Format formatToUse = (format == null ? Format.PDF_A1B : format);    createPdfADocument(formatToUse, config);    createContext();}
protected void pdfbox_f8833_0(Format format, PreflightConfiguration config) throws IOException
{    COSDocument cosDocument = getDocument();    this.preflightDocument = new PreflightDocument(cosDocument, format, config);}
protected void pdfbox_f8834_0()
{    ctx = new PreflightContext();    ctx.setDocument(preflightDocument);    preflightDocument.setContext(ctx);    ctx.setXrefTrailerResolver(xrefTrailerResolver);    ctx.setFileLen(this.fileLen);}
public PDDocument pdfbox_f8835_0() throws IOException
{    preflightDocument.setResult(validationResult);        return preflightDocument;}
public PreflightDocument pdfbox_f8836_0() throws IOException
{    return (PreflightDocument) getPDDocument();}
protected void pdfbox_f8837_0() throws IOException
{    super.initialParse();            Map<COSObjectKey, Long> xrefTable = document.getXrefTable();    for (Entry<COSObjectKey, Long> entry : xrefTable.entrySet()) {        COSObject co = document.getObjectFromPool(entry.getKey());        if (co.getObject() == null) {                        parseObjectDynamically(co, true);        }    }}
protected void pdfbox_f8838_0()
{    try {        source.seek(0);        String firstLine = readLine();        if (firstLine == null || !firstLine.matches("%PDF-1\\.[1-9]")) {            addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_HEADER, "First line must match %PDF-1.\\d"));        }        String secondLine = readLine();        if (secondLine != null) {            byte[] secondLineAsBytes = secondLine.getBytes(encoding.name());            if (secondLineAsBytes.length >= 5) {                if (secondLineAsBytes[0] != '%') {                    addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_HEADER, "Second line must begin with '%' followed by at least 4 bytes greater than 127"));                } else {                    for (int i = 1; i < 5; ++i) {                        byte b = secondLineAsBytes[i];                        if ((b & 0xFF) < 0x80) {                            addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_HEADER, "Second line must begin with '%' followed by at least 4 bytes greater than 127"));                            break;                        }                    }                }            } else {                addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_HEADER, "Second line must begin with '%' followed by at least 4 bytes greater than 127"));            }        }        source.seek(0);    } catch (IOException e) {        addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_HEADER, "Unable to read the PDF file : " + e.getMessage(), e));    }}
protected boolean pdfbox_f8839_0(long startByteOffset) throws IOException
{    if (source.peek() != 'x') {        return false;    }    String xref = readString();    if (!xref.equals("xref")) {        addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_CROSS_REF, "xref must be followed by a EOL character"));        return false;    }    if (!nextIsEOL()) {        addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_CROSS_REF, "xref must be followed by EOL"));    }        xrefTrailerResolver.nextXrefObj(startByteOffset, XRefType.TABLE);        while (true) {                        long currObjID;                int count;        long offset = source.getPosition();        String line = readLine();        Pattern pattern = Pattern.compile("(\\d+)\\s(\\d+)(\\s*)");        Matcher matcher = pattern.matcher(line);        if (matcher.matches()) {            currObjID = Long.parseLong(matcher.group(1));            count = Integer.parseInt(matcher.group(2));        } else {            addValidationError(new ValidationError(ERROR_SYNTAX_CROSS_REF, "Cross reference subsection header is invalid: '" + line + "' at position " + source.getPosition()));                        source.seek(offset);                        currObjID = readObjectNumber();                        count = readInt();        }        skipSpaces();        for (int i = 0; i < count; i++) {            if (source.isEOF() || isEndOfName((char) source.peek())) {                break;            }            if (source.peek() == 't') {                addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_CROSS_REF, "Expected xref line but 't' found"));                break;            }                        String currentLine = readLine();            String[] splitString = currentLine.split(" ");            if (splitString.length < 3) {                addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_CROSS_REF, "invalid xref line: " + currentLine));                break;            }                        if (splitString[splitString.length - 1].equals("n")) {                try {                    long currOffset = Long.parseLong(splitString[0]);                    int currGenID = Integer.parseInt(splitString[1]);                    COSObjectKey objKey = new COSObjectKey(currObjID, currGenID);                    xrefTrailerResolver.setXRef(objKey, currOffset);                } catch (NumberFormatException e) {                    addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_CROSS_REF, "offset or genid can't be read as number " + e.getMessage(), e));                }            } else if (!splitString[2].equals("f")) {                addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_CROSS_REF, "Corrupt XRefTable Entry - ObjID:" + currObjID));            }            currObjID++;            skipSpaces();        }        skipSpaces();        if (!isDigit()) {            break;        }    }    return true;}
protected COSStream pdfbox_f8840_0(COSDictionary dic) throws IOException
{    long startOffset = checkStreamKeyWord();    COSStream result = super.parseCOSStream(dic);    checkEndstreamKeyWord(dic, startOffset);    return result;}
private long pdfbox_f8841_0() throws IOException
{    String streamV = readString();    if (!streamV.equals("stream")) {        addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_DELIMITER, "Expected 'stream' keyword but found '" + streamV + "' at offset " + source.getPosition()));    }    long startOffset = source.getPosition();    int nextChar = source.read();    if (nextChar == 13 && source.peek() == 10) {        startOffset += 2;    } else if (nextChar == 10) {        startOffset++;    } else {        addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_DELIMITER, "Expected 'EOL' after the stream keyword at offset " + source.getPosition()));    }        source.seek(source.getPosition() - 7);    return startOffset;}
private void pdfbox_f8842_0(COSDictionary dic, long startOffset) throws IOException
{    source.seek(source.getPosition() - 10);    long endOffset = source.getPosition();    int nextChar = source.read();    boolean eolFound = false;    boolean crlfFound = false;        if (nextChar == '\n') {        eolFound = true;                source.rewind(2);        if (source.read() == '\r') {            endOffset--;            crlfFound = true;        }        source.read();    }    boolean addStreamLengthErrorMessage = false;    long actualLength = endOffset - startOffset;    if (!eolFound) {        addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_DELIMITER, "Expected 'EOL' before the endstream keyword at offset " + source.getPosition() + " but found '" + source.peek() + "'"));        addStreamLengthErrorMessage = true;    }    String endstreamV = readString();    if (!endstreamV.equals("endstream")) {        addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_DELIMITER, "Expected 'endstream' keyword at offset " + source.getPosition() + " but found '" + endstreamV + "'"));        addStreamLengthErrorMessage = true;    }    int length = dic.getInt(COSName.LENGTH);    if (    addStreamLengthErrorMessage || (length > -1 && ((!crlfFound && length - actualLength != 0) || (crlfFound && length - actualLength > 1)))) {        addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_LENGTH_INVALID, "Stream length is invalid [dic=" + dic + "; defined length=" + length + "; actual length=" + actualLength + ", starting offset=" + startOffset));    }}
private boolean pdfbox_f8843_0() throws IOException
{    boolean succeed = false;    int nextChar = source.read();    if (ASCII_CR == nextChar && ASCII_LF == source.peek()) {        source.read();        succeed = true;    } else if (ASCII_CR == nextChar || ASCII_LF == nextChar) {        succeed = true;    }    return succeed;}
protected COSArray pdfbox_f8844_0() throws IOException
{    COSArray result = super.parseCOSArray();    if (result != null && result.size() > MAX_ARRAY_ELEMENTS) {        addValidationError(new ValidationError(ERROR_SYNTAX_ARRAY_TOO_LONG, "Array too long : " + result.size()));    }    return result;}
protected COSName pdfbox_f8845_0() throws IOException
{    COSName result = super.parseCOSName();    if (result != null && result.getName().getBytes().length > MAX_NAME_SIZE) {        addValidationError(new ValidationError(ERROR_SYNTAX_NAME_TOO_LONG, "Name too long: " + result.getName()));    }    return result;}
protected COSString pdfbox_f8846_0() throws IOException
{        long offset = source.getPosition();    char nextChar = (char) source.read();    int count = 0;    if (nextChar == '<') {        do {            nextChar = (char) source.read();            if (nextChar != '>') {                if (isWhitespace(nextChar)) {                                        continue;                }                if (Character.digit(nextChar, 16) >= 0) {                    count++;                } else {                    addValidationError(new ValidationError(ERROR_SYNTAX_HEXA_STRING_INVALID, "Hexa String must have only Hexadecimal Characters (found '" + nextChar + "') at offset " + source.getPosition()));                    break;                }            }        } while (nextChar != '>');    }    if (count % 2 != 0) {        addValidationError(new ValidationError(ERROR_SYNTAX_HEXA_STRING_EVEN_NUMBER, "Hexa string shall contain even number of non white space char at offset " + source.getPosition()));    }        source.seek(offset);    COSString result = super.parseCOSString();    if (result.getString().length() > MAX_STRING_LENGTH) {        addValidationError(new ValidationError(ERROR_SYNTAX_HEXA_STRING_TOO_LONG, "Hexa string is too long at offset " + source.getPosition()));    }    return result;}
protected COSBase pdfbox_f8847_0() throws IOException
{    COSBase result = super.parseDirObject();    if (result instanceof COSNumber) {        COSNumber number = (COSNumber) result;        if (number instanceof COSFloat) {            Double real = number.doubleValue();            if (real > MAX_POSITIVE_FLOAT || real < MAX_NEGATIVE_FLOAT) {                addValidationError(new ValidationError(ERROR_SYNTAX_NUMERIC_RANGE, "Float is too long or too small: " + real + "  at offset " + source.getPosition()));            }        } else {            long numAsLong = number.longValue();            if (numAsLong > Integer.MAX_VALUE || numAsLong < Integer.MIN_VALUE) {                addValidationError(new ValidationError(ERROR_SYNTAX_NUMERIC_RANGE, "Numeric is too long or too small: " + numAsLong + "  at offset " + source.getPosition()));            }        }    }    if (result instanceof COSDictionary) {        COSDictionary dic = (COSDictionary) result;        if (dic.size() > MAX_DICT_ENTRIES) {            addValidationError(new ValidationError(ERROR_SYNTAX_TOO_MANY_ENTRIES, "Too Many Entries In Dictionary at offset " + source.getPosition()));        }    }    return result;}
protected COSBase pdfbox_f8848_0(long objNr, int objGenNr, boolean requireExistingNotCompressedObj) throws IOException
{        final COSObjectKey objKey = new COSObjectKey(objNr, objGenNr);    final COSObject pdfObject = document.getObjectFromPool(objKey);    if (pdfObject.getObject() == null) {                        Long offsetOrObjstmObNr = document.getXrefTable().get(objKey);                if (requireExistingNotCompressedObj && ((offsetOrObjstmObNr == null))) {            addValidationError(new ValidationError(ERROR_SYNTAX_MISSING_OFFSET, "Object must be defined and must not be compressed object: " + objKey.getNumber() + ":" + objKey.getGeneration()));            throw new SyntaxValidationException("Object must be defined and must not be compressed object: " + objKey.getNumber() + ":" + objKey.getGeneration(), validationResult);        }        if (offsetOrObjstmObNr == null) {                        pdfObject.setObject(COSNull.NULL);        } else if (offsetOrObjstmObNr == 0) {            addValidationError(new ValidationError(ERROR_SYNTAX_INVALID_OFFSET, "Object {" + objKey.getNumber() + ":" + objKey.getGeneration() + "} has an offset of 0"));        } else if (offsetOrObjstmObNr > 0) {                                    source.seek(offsetOrObjstmObNr);                        long readObjNr;            int readObjGen;            long offset = source.getPosition();            String line = readLine();            Pattern pattern = Pattern.compile("(\\d+)\\s(\\d+)\\sobj");            Matcher matcher = pattern.matcher(line);            if (matcher.matches()) {                readObjNr = Long.parseLong(matcher.group(1));                readObjGen = Integer.parseInt(matcher.group(2));            } else {                addValidationError(new ValidationError(ERROR_SYNTAX_OBJ_DELIMITER, "Single space expected [offset=" + offset + "; key=" + offsetOrObjstmObNr.toString() + "; line=" + line + "; object=" + pdfObject.toString() + "]"));                                source.seek(offset);                readObjNr = readObjectNumber();                readObjGen = readGenerationNumber();                                skipSpaces();                for (char c : OBJ_MARKER) {                    if (source.read() != c) {                        addValidationError(new ValidationError(ERROR_SYNTAX_OBJ_DELIMITER, "Expected pattern '" + new String(OBJ_MARKER) + " but missed at character '" + c + "'"));                        throw new SyntaxValidationException("Expected pattern '" + new String(OBJ_MARKER) + " but missed at character '" + c + "'", validationResult);                    }                }            }                        if ((readObjNr != objKey.getNumber()) || (readObjGen != objKey.getGeneration())) {                throw new IOException("XREF for " + objKey.getNumber() + ":" + objKey.getGeneration() + " points to wrong object: " + readObjNr + ":" + readObjGen);            }            skipSpaces();            COSBase pb = parseDirObject();            skipSpaces();            long endObjectOffset = source.getPosition();            String endObjectKey = readString();            if (endObjectKey.equals("stream")) {                source.seek(endObjectOffset);                if (pb instanceof COSDictionary) {                    COSStream stream = parseCOSStream((COSDictionary) pb);                    if (securityHandler != null) {                        securityHandler.decryptStream(stream, objNr, objGenNr);                    }                    pb = stream;                } else {                                        throw new IOException("Stream not preceded by dictionary (offset: " + offsetOrObjstmObNr + ").");                }                skipSpaces();                endObjectOffset = source.getPosition();                endObjectKey = readString();                                if (!endObjectKey.startsWith("endobj")) {                    if (endObjectKey.startsWith("endstream")) {                        endObjectKey = endObjectKey.substring(9).trim();                        if (endObjectKey.length() == 0) {                                                                                    endObjectKey = readString();                        }                    }                }            } else if (securityHandler != null) {                securityHandler.decrypt(pb, objNr, objGenNr);            }            pdfObject.setObject(pb);            if (!endObjectKey.startsWith("endobj")) {                throw new IOException("Object (" + readObjNr + ":" + readObjGen + ") at offset " + offsetOrObjstmObNr + " does not end with 'endobj'.");            } else {                offset = source.getPosition();                source.seek(endObjectOffset - 1);                if (!nextIsEOL()) {                    addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_OBJ_DELIMITER, "EOL expected before the 'endobj' keyword at offset " + source.getPosition()));                }                source.seek(offset);            }            if (!nextIsEOL()) {                addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_OBJ_DELIMITER, "EOL expected after the 'endobj' keyword at offset " + source.getPosition()));            }        } else {                                    final int objstmObjNr = (int) (-offsetOrObjstmObNr);            final COSBase objstmBaseObj = parseObjectDynamically(objstmObjNr, 0, true);            if (objstmBaseObj instanceof COSStream) {                                PDFObjectStreamParser parser = new PDFObjectStreamParser((COSStream) objstmBaseObj, document);                parser.parse();                                parser.getObjects().forEach(next -> {                    COSObjectKey stmObjKey = new COSObjectKey(next);                    Long offset = document.getXrefTable().get(stmObjKey);                    if (offset != null && offset == -objstmObjNr) {                        COSObject stmObj = document.getObjectFromPool(stmObjKey);                        stmObj.setObject(next.getObject());                    }                });            }        }    }    return pdfObject.getObject();}
protected int pdfbox_f8849_0(final char[] pattern, final byte[] buf, final int endOff)
{    int offset = super.lastIndexOf(pattern, buf, endOff);    if (offset > 0 && Arrays.equals(pattern, EOF_MARKER)) {                        int tmpOffset = offset + pattern.length;        if (tmpOffset != buf.length) {                        if ((buf.length - tmpOffset) > 2 || (buf.length - tmpOffset == 2 && (buf[tmpOffset] != 13 || buf[tmpOffset + 1] != 10)) || (buf.length - tmpOffset == 1 && (buf[tmpOffset] != 13 && buf[tmpOffset] != 10))) {                long position;                try {                    position = source.getPosition();                } catch (IOException excpetion) {                    position = Long.MIN_VALUE;                }                addValidationError(new ValidationError(ERROR_SYNTAX_TRAILER_EOF, "File contains data after the last %%EOF sequence at offset " + position));            }        }    }    return offset;}
public Element pdfbox_f8850_0(File file) throws IOException
{    return validate(new RandomAccessBufferedFileInputStream(file), file.getName());}
public Element pdfbox_f8851_0(Document rdocument, File file) throws IOException
{    return validate(rdocument, new RandomAccessBufferedFileInputStream(file), file.getName());}
private Element pdfbox_f8852_0(RandomAccessRead source, String name) throws IOException
{    try {        Document rdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();        return validate(rdocument, source, name);    } catch (ParserConfigurationException e) {        throw new IOException("Failed to init document builder", e);    }}
private Element pdfbox_f8853_0(Document rdocument, RandomAccessRead source, String name) throws IOException
{    String pdfType = null;    ValidationResult result;    long before = System.currentTimeMillis();    try {        PreflightParser parser = new PreflightParser(source);        try {            parser.parse();            try (PreflightDocument document = parser.getPreflightDocument()) {                document.validate();                pdfType = document.getSpecification().getFname();                result = document.getResult();            }        } catch (SyntaxValidationException e) {            result = e.getResult();        }    } catch (Exception e) {        long after = System.currentTimeMillis();        return generateFailureResponse(rdocument, name, after - before, pdfType, e);    }    long after = System.currentTimeMillis();    if (result.isValid()) {        Element preflight = generateResponseSkeleton(rdocument, name, after - before);                Element valid = rdocument.createElement("isValid");        valid.setAttribute("type", pdfType);        valid.setTextContent("true");        preflight.appendChild(valid);        return preflight;    } else {        Element preflight = generateResponseSkeleton(rdocument, name, after - before);                createResponseWithError(rdocument, pdfType, result, preflight);        return preflight;    }}
protected void pdfbox_f8854_0(Document rdocument, String pdfType, ValidationResult result, Element preflight)
{    Element valid = rdocument.createElement("isValid");    valid.setAttribute("type", pdfType);    valid.setTextContent("false");    preflight.appendChild(valid);        Element errors = rdocument.createElement("errors");    Map<ValidationError, Integer> cleaned = cleanErrorList(result.getErrorsList());    preflight.appendChild(errors);    int totalCount = 0;    for (Map.Entry<ValidationError, Integer> entry : cleaned.entrySet()) {        Element error = rdocument.createElement("error");        int count = entry.getValue();        error.setAttribute("count", String.format("%d", count));        totalCount += count;        Element code = rdocument.createElement("code");        ValidationError ve = entry.getKey();        code.setTextContent(ve.getErrorCode());        error.appendChild(code);        Element detail = rdocument.createElement("details");        detail.setTextContent(ve.getDetails());        error.appendChild(detail);        if (ve.getPageNumber() != null) {            Element page = rdocument.createElement("page");            page.setTextContent(ve.getPageNumber().toString());            error.appendChild(page);        }        errors.appendChild(error);    }    errors.setAttribute("count", String.format("%d", totalCount));}
private Map<ValidationError, Integer> pdfbox_f8855_0(List<ValidationError> errors)
{    Map<ValidationError, Integer> cleaned = new HashMap<>(errors.size());    for (ValidationError ve : errors) {        Integer found = cleaned.get(ve);        if (found != null) {            cleaned.put(ve, found + 1);        } else {            cleaned.put(ve, 1);        }    }    return cleaned;}
protected Element pdfbox_f8856_0(Document rdocument, String name, long duration, String pdfType, Exception e)
{    Element preflight = generateResponseSkeleton(rdocument, name, duration);        Element valid = rdocument.createElement("isValid");    valid.setAttribute("type", pdfType);    valid.setTextContent("false");    preflight.appendChild(valid);        Element exception = rdocument.createElement("exceptionThrown");    Element message = rdocument.createElement("message");    message.setTextContent(e.getMessage());    StringWriter sw = new StringWriter();    PrintWriter pw = new PrintWriter(sw);    e.printStackTrace(pw);    pw.close();    Element stack = rdocument.createElement("stackTrace");    stack.setTextContent(sw.toString());    exception.appendChild(message);    exception.appendChild(stack);    preflight.appendChild(exception);    return preflight;}
protected Element pdfbox_f8857_0(Document rdocument, String name, long duration)
{    Element preflight = rdocument.createElement("preflight");    preflight.setAttribute("name", name);        Element eduration = rdocument.createElement("executionTimeMS");    eduration.setTextContent(String.format("%d", duration));    preflight.appendChild(eduration);        return preflight;}
public static PreflightConfiguration pdfbox_f8858_0()
{    PreflightConfiguration configuration = new PreflightConfiguration();    configuration.replaceProcess(CATALOG_PROCESS, CatalogValidationProcess.class);    configuration.replaceProcess(FILE_SPECIF_PROCESS, FileSpecificationValidationProcess.class);    configuration.replaceProcess(TRAILER_PROCESS, TrailerValidationProcess.class);    configuration.replaceProcess(XREF_PROCESS, XRefValidationProcess.class);    configuration.replaceProcess(ACRO_FORM_PROCESS, AcroFormValidationProcess.class);    configuration.replaceProcess(BOOKMARK_PROCESS, BookmarkValidationProcess.class);    configuration.replaceProcess(PAGES_TREE_PROCESS, PageTreeValidationProcess.class);    configuration.replaceProcess(META_DATA_PROCESS, MetadataValidationProcess.class);    configuration.replaceProcess(STREAM_PROCESS, StreamValidationProcess.class);    configuration.replacePageProcess(PAGE_PROCESS, SinglePageValidationProcess.class);    configuration.replacePageProcess(EXTGSTATE_PROCESS, ExtGStateValidationProcess.class);    configuration.replacePageProcess(SHADING_PATTERN_PROCESS, ShadingPatternValidationProcess.class);    configuration.replacePageProcess(GRAPHIC_PROCESS, GraphicObjectPageValidationProcess.class);    configuration.replacePageProcess(TILING_PATTERN_PROCESS, TilingPatternValidationProcess.class);    configuration.replacePageProcess(RESOURCES_PROCESS, ResourcesValidationProcess.class);    configuration.replacePageProcess(FONT_PROCESS, FontValidationProcess.class);    configuration.replacePageProcess(ACTIONS_PROCESS, ActionsValidationProcess.class);    configuration.replacePageProcess(ANNOTATIONS_PROCESS, AnnotationValidationProcess.class);    configuration.replacePageProcess(DESTINATION_PROCESS, DestinationValidationProcess.class);    configuration.actionFact = new ActionManagerFactory();    configuration.annotFact = new PDFAbAnnotationFactory();    configuration.colorSpaceHelperFact = new ColorSpaceHelperFactory();    return configuration;}
public Collection<String> pdfbox_f8859_0()
{    return this.processes.keySet();}
public ValidationProcess pdfbox_f8860_0(String processName) throws ValidationException
{    Class<? extends ValidationProcess> clazz = null;    if (processes.containsKey(processName)) {        clazz = processes.get(processName);    } else if (innerProcesses.containsKey(processName)) {        clazz = innerProcesses.get(processName);    } else if (errorOnMissingProcess) {        throw new MissingValidationProcessException(processName);    } else {        return new EmptyValidationProcess();    }    try {        return clazz.getDeclaredConstructor().newInstance();    } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException e) {        throw new ValidationException(processName + " can't be created", e);    }}
public void pdfbox_f8861_0(String processName, Class<? extends ValidationProcess> process)
{    if (process == null) {        removeProcess(processName);    } else {        this.processes.put(processName, process);    }}
public void pdfbox_f8862_0(String processName)
{    this.processes.remove(processName);}
public Collection<String> pdfbox_f8863_0()
{    return this.innerProcesses.keySet();}
public void pdfbox_f8864_0(String processName, Class<? extends ValidationProcess> process)
{    if (process == null) {        removePageProcess(processName);    } else {        this.innerProcesses.put(processName, process);    }}
public void pdfbox_f8865_0(String processName)
{    this.innerProcesses.remove(processName);}
public boolean pdfbox_f8866_0()
{    return errorOnMissingProcess;}
public void pdfbox_f8867_0(boolean errorOnMissingProcess)
{    this.errorOnMissingProcess = errorOnMissingProcess;}
public boolean pdfbox_f8868_0()
{    return lazyValidation;}
public void pdfbox_f8869_0(boolean lazyValidation)
{    this.lazyValidation = lazyValidation;}
public AnnotationValidatorFactory pdfbox_f8870_0()
{    return annotFact;}
public void pdfbox_f8871_0(AnnotationValidatorFactory annotFact)
{    this.annotFact = annotFact;}
public ActionManagerFactory pdfbox_f8872_0()
{    return actionFact;}
public void pdfbox_f8873_0(ActionManagerFactory actionFact)
{    this.actionFact = actionFact;}
public ColorSpaceHelperFactory pdfbox_f8874_0()
{    return colorSpaceHelperFact;}
public void pdfbox_f8875_0(ColorSpaceHelperFactory colorSpaceHelperFact)
{    this.colorSpaceHelperFact = colorSpaceHelperFact;}
public int pdfbox_f8876_0()
{    return maxErrors;}
public void pdfbox_f8877_0(int maxErrors)
{    this.maxErrors = maxErrors;}
public XMPMetadata pdfbox_f8878_0()
{    return metadata;}
public void pdfbox_f8879_0(XMPMetadata metadata)
{    this.metadata = metadata;}
public PreflightDocument pdfbox_f8880_0()
{    return document;}
public XrefTrailerResolver pdfbox_f8881_0()
{    return xrefTrailerResolver;}
public void pdfbox_f8882_0(XrefTrailerResolver xrefTrailerResolver)
{    this.xrefTrailerResolver = xrefTrailerResolver;}
public void pdfbox_f8883_0(PreflightDocument document)
{    this.document = document;}
public void pdfbox_f8884_0(COSBase cBase, FontContainer<?> fc)
{    this.fontContainers.put(cBase, fc);}
public FontContainer<?> pdfbox_f8885_0(COSBase cBase)
{    return this.fontContainers.get(cBase);}
public ICCProfileWrapper pdfbox_f8886_0()
{    return iccProfileWrapper;}
public void pdfbox_f8887_0(ICCProfileWrapper iccProfileWrapper)
{    this.iccProfileWrapper = iccProfileWrapper;}
public PreflightConfiguration pdfbox_f8888_0()
{    return config;}
public void pdfbox_f8889_0(PreflightConfiguration config)
{    this.config = config;}
public void pdfbox_f8890_0()
{    IOUtils.closeQuietly(document);}
public void pdfbox_f8891_0(ValidationError error)
{    PreflightDocument pfDoc = this.document;    error.setPageNumber(currentPageNumber);    pfDoc.addValidationError(error);}
public void pdfbox_f8892_0(List<ValidationError> errors)
{    PreflightDocument pfDoc = this.document;    for (ValidationError error : errors) {        pfDoc.addValidationError(error);    }}
public PreflightPath pdfbox_f8893_0()
{    return validationPath;}
public void pdfbox_f8894_0(PreflightPath validationPath)
{    this.validationPath = validationPath;}
public boolean pdfbox_f8895_0()
{    return iccProfileAlreadySearched;}
public void pdfbox_f8896_0(boolean iccProfileAlreadySearched)
{    this.iccProfileAlreadySearched = iccProfileAlreadySearched;}
public void pdfbox_f8897_0(Integer currentPageNumber)
{    this.currentPageNumber = currentPageNumber;}
public Integer pdfbox_f8898_0()
{    return currentPageNumber;}
public void pdfbox_f8899_0(long fileLen)
{    this.fileLen = fileLen;}
public long pdfbox_f8900_0()
{    return fileLen;}
public void pdfbox_f8901_0(COSObjectable cos)
{    processedSet.add(cos);}
public boolean pdfbox_f8902_0(COSObjectable cos)
{    return processedSet.contains(cos);}
private void pdfbox_f8903_0(Format format)
{    switch(format) {        default:                        this.config = PreflightConfiguration.createPdfA1BConfiguration();            break;    }}
public ValidationResult pdfbox_f8904_0()
{    return result;}
public void pdfbox_f8905_0(ValidationResult result)
{    if (this.result != null) {        this.result.mergeResult(result);    } else if (result != null) {        this.result = result;    } else {        this.result = new ValidationResult(true);    }}
public void pdfbox_f8906_0(ValidationError error)
{    if (error != null) {        if (result == null) {            this.result = new ValidationResult(error.isWarning());        }        this.result.addError(error);    }}
public PreflightContext pdfbox_f8907_0()
{    return this.context;}
public void pdfbox_f8908_0(PreflightContext context)
{    this.context = context;}
public void pdfbox_f8909_0() throws ValidationException
{            javax.xml.bind.DatatypeConverter.parseInt("0");    context.setConfig(config);    Collection<String> processes = config.getProcessNames();    for (String name : processes) {        ContextHelper.validateElement(context, name);    }}
public Format pdfbox_f8910_0()
{    return specification;}
public boolean pdfbox_f8911_0(Object pathElement)
{    boolean pushed = false;    if (pathElement != null) {        this.objectPath.push(pathElement);        this.classObjPath.push(pathElement.getClass());        pushed = true;    }    return pushed;}
public T pdfbox_f8912_0(int position, Class<T> expectedType)
{    if (position < 0 || position >= this.objectPath.size()) {        return null;    }    return (T) this.objectPath.get(position);}
public int pdfbox_f8913_0(Class<T> type)
{    for (int i = this.objectPath.size(); i-- > 0; ) {        if (this.classObjPath.get(i).equals(type)) {            return i;        }    }    return -1;}
public T pdfbox_f8914_0(Class<T> type)
{    return getPathElement(getClosestTypePosition(type), type);}
public Object pdfbox_f8915_0()
{    return this.objectPath.peek();}
public Object pdfbox_f8916_0()
{    this.classObjPath.pop();    return this.objectPath.pop();}
public void pdfbox_f8917_0()
{    this.classObjPath.clear();    this.objectPath.clear();}
public int pdfbox_f8918_0()
{    return this.objectPath.size();}
public boolean pdfbox_f8919_0()
{    return this.objectPath.isEmpty();}
public boolean pdfbox_f8920_0(Class<?> type)
{    @SuppressWarnings("rawtypes")    Class knownType = this.classObjPath.peek();    return (knownType != null && (type.equals(knownType) || type.isAssignableFrom(knownType)));}
protected void pdfbox_f8921_0(PreflightContext ctx, ValidationError error)
{    ctx.addValidationError(error);}
protected void pdfbox_f8922_0(PreflightContext ctx, List<ValidationError> errors)
{    for (ValidationError error : errors) {        addValidationError(ctx, error);    }}
protected void pdfbox_f8923_0(COSDictionary dictionary, PreflightContext context, IOException e)
{    COSName type = dictionary.getCOSName(COSName.TYPE, COSName.FONT);    if (!COSName.FONT.equals(type)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_UNKNOWN_FONT_TYPE, "Expected 'Font' dictionary but found '" + type.getName() + "'"));    }    String fontName = "Unknown";    if (dictionary.containsKey(COSName.BASE_FONT)) {        fontName = dictionary.getNameAsString(COSName.BASE_FONT);    }    COSName subType = dictionary.getCOSName(COSName.SUBTYPE);    if (COSName.TYPE1.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_TYPE1_DAMAGED, "The FontFile can't be read for " + fontName + ": " + e.getMessage()));    } else if (COSName.MM_TYPE1.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_TYPE1_DAMAGED, "The FontFile can't be read for " + fontName + ": " + e.getMessage()));    } else if (COSName.TRUE_TYPE.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_TRUETYPE_DAMAGED, "The FontFile can't be read for " + fontName + ": " + e.getMessage()));    } else if (COSName.TYPE3.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_TYPE3_DAMAGED, "The FontFile can't be read for " + fontName + ": " + e.getMessage()));    } else if (COSName.TYPE0.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_CID_DAMAGED, "The FontFile can't be read for " + fontName + ": " + e.getMessage()));    } else if (COSName.CID_FONT_TYPE0.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_UNKNOWN_FONT_TYPE, "Unexpected CIDFontType0 descendant font for " + fontName + ": " + e.getMessage()));    } else if (COSName.CID_FONT_TYPE2.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_UNKNOWN_FONT_TYPE, "Unexpected CIDFontType2 descendant font for " + fontName + ": " + e.getMessage()));    } else {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_UNKNOWN_FONT_TYPE, "Unknown font type for " + fontName));    }}
public void pdfbox_f8924_0(PreflightContext ctx) throws ValidationException
{    PDDocumentCatalog catalog = ctx.getDocument().getDocumentCatalog();    if (catalog != null) {        PDAcroForm acroForm = catalog.getAcroForm();        if (acroForm != null) {            checkNeedAppearences(ctx, acroForm);            try {                exploreFields(ctx, acroForm.getFields());            } catch (IOException e) {                throw new ValidationException("Unable to get the list of fields : " + e.getMessage(), e);            }        }    } else {        ctx.addValidationError(new ValidationError(ERROR_SYNTAX_NOCATALOG, "There is no Catalog entry in the Document"));    }}
protected void pdfbox_f8925_0(PreflightContext ctx, PDAcroForm acroForm)
{    if (acroForm.getCOSObject().getBoolean(ACROFORM_DICTIONARY_KEY_NEED_APPEARANCES, false)) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_DICT_INVALID, "NeedAppearance is present with the value \"true\""));    }}
protected boolean pdfbox_f8926_0(PreflightContext ctx, List<PDField> lFields) throws IOException
{    if (lFields != null) {                for (Object obj : lFields) {            if (obj instanceof PDField) {                if (!validateField(ctx, (PDField) obj)) {                    return false;                }            } else if (obj instanceof PDAnnotationWidget) {                                ContextHelper.validateElement(ctx, ((PDAnnotationWidget) obj).getCOSObject(), ANNOTATIONS_PROCESS);            } else {                addValidationError(ctx, new ValidationError(ERROR_SYNTAX_BODY, "Field can only have fields or widget annotations as KIDS"));            }        }    }    return true;}
protected boolean pdfbox_f8927_0(PreflightContext ctx, List<PDAnnotationWidget> widgets) throws IOException
{    for (PDAnnotationWidget widget : widgets) {                ContextHelper.validateElement(ctx, widget.getCOSObject(), ANNOTATIONS_PROCESS);    }    return true;}
protected boolean pdfbox_f8928_0(PreflightContext ctx, PDField field) throws IOException
{    boolean res = true;    PDFormFieldAdditionalActions aa = field.getActions();    if (aa != null) {        addValidationError(ctx, new ValidationError(ERROR_ACTION_FORBIDDEN_ADDITIONAL_ACTIONS_FIELD, "\"AA\" must not be used in a Field dictionary"));        res = false;    }    if (field instanceof PDTerminalField) {                List<PDAnnotationWidget> widgets = field.getWidgets();        if (res && widgets != null) {            for (PDAnnotationWidget widget : widgets) {                ContextHelper.validateElement(ctx, widget.getCOSObject(), ANNOTATIONS_PROCESS);                COSBase act = widget.getCOSObject().getDictionaryObject(COSName.A);                if (act != null) {                    addValidationError(ctx, new ValidationError(ERROR_ACTION_FORBIDDEN_WIDGET_ACTION_FIELD, "\"A\" must not be used in a widget annotation"));                    return false;                }            }        }        return exploreWidgets(ctx, field.getWidgets());    } else {        return res && exploreFields(ctx, ((PDNonTerminalField) field).getChildren());    }}
public void pdfbox_f8929_0(PreflightContext ctx) throws ValidationException
{    PDDocumentCatalog catalog = ctx.getDocument().getDocumentCatalog();    if (catalog != null) {        PDDocumentOutline outlineHierarchy = catalog.getDocumentOutline();        if (outlineHierarchy != null) {            COSDictionary dict = outlineHierarchy.getCOSObject();            if (!checkIndirectObjects(ctx, dict)) {                return;            }            COSObject firstObj = toCOSObject(dict.getItem(COSName.FIRST));            COSObject lastObj = toCOSObject(dict.getItem(COSName.LAST));                        if (!isCountEntryPresent(dict) && (outlineHierarchy.getFirstChild() != null || outlineHierarchy.getLastChild() != null)) {                addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Outline Hierarchy doesn't have Count entry"));            } else if (isCountEntryPositive(dict) && (outlineHierarchy.getFirstChild() == null || outlineHierarchy.getLastChild() == null)) {                addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Outline Hierarchy doesn't have First and/or Last entry(ies)"));            } else {                exploreOutlineLevel(ctx, outlineHierarchy.getFirstChild(), firstObj, lastObj);            }        }    } else {        ctx.addValidationError(new ValidationError(ERROR_SYNTAX_NOCATALOG, "There is no /Catalog entry in the Document"));    }}
private boolean pdfbox_f8930_0(COSDictionary outline)
{    return outline.getItem(COSName.COUNT) != null;}
private boolean pdfbox_f8931_0(COSDictionary outline)
{    COSBase countBase = outline.getDictionaryObject(COSName.COUNT);    return countBase instanceof COSInteger && ((COSInteger) countBase).intValue() > 0;}
protected boolean pdfbox_f8932_0(PreflightContext ctx, PDOutlineItem inputItem, COSObject firstObj, COSObject lastObj) throws ValidationException
{    PDOutlineItem currentItem = inputItem;    COSObject currentObj = firstObj;    Set<COSObject> levelObjects = new HashSet<>();    levelObjects.add(firstObj);    boolean result = true;    if (currentItem != null && inputItem.getPreviousSibling() != null) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "The value of /Prev of first object " + firstObj + " on a level is " + inputItem.getCOSObject().getItem(COSName.PREV) + ", but shouldn't exist"));        result = false;    }    while (currentItem != null) {        COSObject realPrevObject = currentObj;        if (!validateItem(ctx, currentItem)) {            result = false;        }        currentObj = toCOSObject(currentItem.getCOSObject().getItem(COSName.NEXT));        if (levelObjects.contains(currentObj)) {            addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Loop detected: /Next " + currentObj + " is already in the list"));            return false;        }        if (realPrevObject == null) {                        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Outline object before " + currentObj + " is null"));            return false;        }        levelObjects.add(currentObj);        currentItem = currentItem.getNextSibling();        if (currentItem == null) {            if (!realPrevObject.equals(lastObj)) {                addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Last object on a level isn't the expected /Last: " + lastObj + ", but is " + currentObj));                result = false;            }        } else {            COSObject prevObject = toCOSObject(currentItem.getCOSObject().getItem(COSName.PREV));            if (!realPrevObject.equals(prevObject)) {                addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "The value of /Prev at " + currentObj + " doesn't point to previous object " + realPrevObject + ", but to " + prevObject));                result = false;            }        }    }    return result;}
protected boolean pdfbox_f8933_0(PreflightContext ctx, PDOutlineItem inputItem) throws ValidationException
{    boolean isValid = true;                COSDictionary dictionary = inputItem.getCOSObject();    COSBase dest = dictionary.getItem(COSName.DEST);    COSBase action = dictionary.getItem(COSName.A);    if (!checkIndirectObjects(ctx, dictionary)) {        return false;    }    if (action != null && dest != null) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Dest entry isn't permitted if the A entry is present"));        return false;    } else if (action != null) {        ContextHelper.validateElement(ctx, dictionary, ACTIONS_PROCESS);    } else if (dest != null) {        ContextHelper.validateElement(ctx, dest, DESTINATION_PROCESS);    }            PDOutlineItem fChild = inputItem.getFirstChild();    if (fChild != null) {        if (!isCountEntryPresent(inputItem.getCOSObject())) {            addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Outline item doesn't have Count entry but has at least one descendant"));            isValid = false;        } else {            COSObject firstObj = toCOSObject(dictionary.getItem(COSName.FIRST));            COSObject lastObj = toCOSObject(dictionary.getItem(COSName.LAST));            if ((firstObj == null && lastObj != null) || (firstObj != null && lastObj == null)) {                addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "/First and /Last are both required if there are outline entries"));                isValid = false;            }                        isValid = isValid && exploreOutlineLevel(ctx, fChild, firstObj, lastObj);        }    }    return isValid;}
private boolean pdfbox_f8934_0(PreflightContext ctx, COSDictionary dictionary)
{        if (!checkIndirectObject(ctx, dictionary, COSName.PARENT)) {        return false;    }    if (!checkIndirectObject(ctx, dictionary, COSName.PREV)) {        return false;    }    if (!checkIndirectObject(ctx, dictionary, COSName.NEXT)) {        return false;    }    if (!checkIndirectObject(ctx, dictionary, COSName.FIRST)) {        return false;    }    return checkIndirectObject(ctx, dictionary, COSName.LAST);}
private boolean pdfbox_f8935_0(PreflightContext ctx, COSDictionary dictionary, COSName name)
{    COSBase item = dictionary.getItem(name);    if (item == null || item instanceof COSNull || item instanceof COSObject) {        return true;    }    addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "/" + name.getName() + " entry must be an indirect object"));    return false;}
private COSObject pdfbox_f8936_0(COSBase base)
{    if (base == null || base instanceof COSNull) {        return null;    }    if (!(base instanceof COSObject)) {        throw new IllegalArgumentException("Paremater " + base + " should be null, COSNull or a COSObject");    }    return (COSObject) base;}
protected boolean pdfbox_f8937_0(String name)
{    for (String iccStandard : listICC) {        if (iccStandard.contains(name)) {            return true;        }    }    return false;}
public void pdfbox_f8938_0(PreflightContext ctx) throws ValidationException
{    PDDocument pdfbox = ctx.getDocument();    this.catalog = pdfbox.getDocumentCatalog();    if (this.catalog == null) {        ctx.addValidationError(new ValidationError(ERROR_SYNTAX_NOCATALOG, "There are no Catalog entry in the Document"));    } else {        validateActions(ctx);        validateLang(ctx);        validateNames(ctx);        validateOCProperties(ctx);        validateOutputIntent(ctx);    }}
protected void pdfbox_f8939_0(PreflightContext ctx) throws ValidationException
{    ContextHelper.validateElement(ctx, catalog.getCOSObject(), ACTIONS_PROCESS);        COSBase aa = catalog.getCOSObject().getItem(COSName.AA);    if (aa != null) {        addValidationError(ctx, new ValidationError(ERROR_ACTION_FORBIDDEN_ADDITIONAL_ACTION, "The AA field is forbidden for the Catalog  when the PDF is a PDF/A"));    }}
protected void pdfbox_f8940_0(PreflightContext ctx) throws ValidationException
{    String lang = catalog.getLanguage();    if (lang != null && !"".equals(lang) && !lang.matches("[A-Za-z]{1,8}(-[A-Za-z]{1,8})*")) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_LANG_NOT_RFC1766));    }}
protected void pdfbox_f8941_0(PreflightContext ctx) throws ValidationException
{    PDDocumentNameDictionary names = catalog.getNames();    if (names != null) {        PDEmbeddedFilesNameTreeNode efs = names.getEmbeddedFiles();        if (efs != null) {            addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_CATALOG_EMBEDDEDFILES, "EmbeddedFile entry is present in the Names dictionary"));        }        if (names.getJavaScript() != null) {            addValidationError(ctx, new ValidationError(ERROR_ACTION_FORBIDDEN_ACTIONS_NAMED, "Javascript entry is present in the Names dictionary"));        }    }}
protected void pdfbox_f8942_0(PreflightContext ctx) throws ValidationException
{    if (catalog.getOCProperties() != null) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_CATALOG_OCPROPERTIES, "A Catalog shall not contain the OCPProperties entry"));    }}
public void pdfbox_f8943_0(PreflightContext ctx) throws ValidationException
{    COSArray outputIntents = catalog.getCOSObject().getCOSArray(COSName.OUTPUT_INTENTS);    Map<COSObjectKey, Boolean> tmpDestOutputProfile = new HashMap<>();    for (int i = 0; outputIntents != null && i < outputIntents.size(); ++i) {        COSDictionary outputIntentDict = (COSDictionary) outputIntents.getObject(i);        if (outputIntentDict == null) {            addValidationError(ctx, new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "OutputIntent object is null or isn't a dictionary"));        } else {                        String sValue = outputIntentDict.getNameAsString(OUTPUT_INTENT_DICTIONARY_KEY_S);            if (!OUTPUT_INTENT_DICTIONARY_VALUE_GTS_PDFA1.equals(sValue)) {                addValidationError(ctx, new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_S_VALUE_INVALID, "The S entry of the OutputIntent isn't GTS_PDFA1"));                continue;            }                        String outputConditionIdentifier = outputIntentDict.getString(OUTPUT_INTENT_DICTIONARY_KEY_OUTPUT_CONDITION_IDENTIFIER);            if (outputConditionIdentifier == null) {                                addValidationError(ctx, new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "The OutputIntentCondition is missing"));                continue;            }            /*                 * If OutputConditionIdentifier is "Custom" or a non Standard ICC Characterization : DestOutputProfile                 * and Info are mandatory DestOutputProfile must be a ICC Profile                 *                  * Because of PDF/A conforming file needs to specify the color characteristics, the DestOutputProfile is                 * checked even if the OutputConditionIdentifier isn't "Custom"                 */            COSBase destOutputProfile = outputIntentDict.getItem(COSName.DEST_OUTPUT_PROFILE);            validateICCProfile(destOutputProfile, tmpDestOutputProfile, ctx);            PreflightConfiguration config = ctx.getConfig();            if (config.isLazyValidation() && !isStandardICCCharacterization(outputConditionIdentifier)) {                String info = outputIntentDict.getString(COSName.getPDFName(OUTPUT_INTENT_DICTIONARY_KEY_INFO));                if (info == null || "".equals(info)) {                    ValidationError error = new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "The Info entry of a OutputIntent dictionary is missing");                    error.setWarning(true);                    addValidationError(ctx, error);                }            }        }    }}
protected void pdfbox_f8944_0(COSBase destOutputProfile, Map<COSObjectKey, Boolean> mapDestOutputProfile, PreflightContext ctx) throws ValidationException
{    try {        if (destOutputProfile == null) {            return;        }        COSBase localDestOutputProfile = destOutputProfile;                if (localDestOutputProfile instanceof COSObject) {            if (mapDestOutputProfile.containsKey(new COSObjectKey((COSObject) localDestOutputProfile))) {                                return;            } else if (!mapDestOutputProfile.isEmpty()) {                                addValidationError(ctx, new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_ICC_PROFILE_MULTIPLE, "More than one ICCProfile is defined: " + destOutputProfile));                return;            }                        localDestOutputProfile = ((COSObject) localDestOutputProfile).getObject();        }                mapDestOutputProfile.put(new COSObjectKey((COSObject) destOutputProfile), true);        if (!(localDestOutputProfile instanceof COSStream)) {            addValidationError(ctx, new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "OutputIntent object must be a stream"));            return;        }        COSStream stream = (COSStream) localDestOutputProfile;        COSArray array = new COSArray();        array.add(COSName.ICCBASED);        array.add(stream);        PDICCBased iccBased = PDICCBased.create(array, null);        PreflightConfiguration cfg = ctx.getConfig();        ColorSpaceHelperFactory csFact = cfg.getColorSpaceHelperFact();        ColorSpaceHelper csHelper = csFact.getColorSpaceHelper(ctx, iccBased, ColorSpaceRestriction.NO_RESTRICTION);        csHelper.validate();        if (ctx.getIccProfileWrapper() == null) {            try (InputStream is = stream.createInputStream()) {                ctx.setIccProfileWrapper(new ICCProfileWrapper(ICC_Profile.getInstance(is)));            }        }    } catch (IllegalArgumentException e) {                addValidationError(ctx, new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_ICC_PROFILE_INVALID, "DestOutputProfile isn't a valid ICCProfile: " + e.getMessage(), e));    } catch (IOException e) {        throw new ValidationException("Unable to parse the ICC Profile.", e);    }}
public void pdfbox_f8946_0(PreflightContext ctx) throws ValidationException
{    PDDocument pdfDoc = ctx.getDocument();    COSDocument cDoc = pdfDoc.getDocument();    List<?> lCOSObj = cDoc.getObjects();    for (Object o : lCOSObj) {        COSBase cBase = ((COSObject) o).getObject();        if (cBase instanceof COSDictionary) {            COSDictionary dic = (COSDictionary) cBase;            String type = dic.getNameAsString(COSName.TYPE);            if (FILE_SPECIFICATION_VALUE_TYPE.equals(type) || COSName.F.getName().equals(type)) {                                validateFileSpecification(ctx, dic);            }        }    }}
public List<ValidationError> pdfbox_f8947_0(PreflightContext ctx, COSDictionary fileSpec)
{    List<ValidationError> result = new ArrayList<>(0);        if (fileSpec.getItem(COSName.getPDFName(FILE_SPECIFICATION_KEY_EMBEDDED_FILE)) != null) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_EMBEDDED_FILES, "EmbeddedFile entry is present in a FileSpecification dictionary"));    }    return result;}
public void pdfbox_f8948_0(PreflightContext ctx) throws ValidationException
{    try {        PDDocument document = ctx.getDocument();        InputStream is = getXpacket(document);        DomXmpParser builder = new DomXmpParser();        XMPMetadata metadata = builder.parse(is);        is.close();        ctx.setMetadata(metadata);                if (metadata.getXpacketBytes() != null) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_XPACKET_DEPRECATED, "bytes attribute is forbidden"));        }        if (metadata.getXpacketEncoding() != null) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_XPACKET_DEPRECATED, "encoding attribute is forbidden"));        }        checkThumbnails(ctx, metadata);                addValidationErrors(ctx, new SynchronizedMetaDataValidation().validateMetadataSynchronization(document, metadata));                addValidationErrors(ctx, new PDFAIdentificationValidation().validatePDFAIdentifer(metadata));                try {            new RDFAboutAttributeConcordanceValidation().validateRDFAboutAttributes(metadata);        } catch (DifferentRDFAboutException e) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_RDF_ABOUT_ATTRIBUTE_INEQUAL_VALUE, e.getMessage(), e));        }    } catch (XpacketParsingException e) {        if (e.getError() != null) {            addValidationError(ctx, e.getError());        } else {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_MAIN, "Unexpected error", e));        }    } catch (XmpParsingException e) {        if (e.getErrorType() == ErrorType.NoValueType) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_UNKNOWN_VALUETYPE, e.getMessage(), e));        } else if (e.getErrorType() == ErrorType.RequiredProperty) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_PROPERTY_MISSING, e.getMessage(), e));        } else if (e.getErrorType() == ErrorType.InvalidPrefix) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_ABSENT_DESCRIPTION_SCHEMA, e.getMessage(), e));        } else if (e.getErrorType() == ErrorType.InvalidType) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_PROPERTY_UNKNOWN, e.getMessage(), e));        } else if (e.getErrorType() == ErrorType.XpacketBadEnd) {            throw new ValidationException("Unable to parse font metadata due to : " + e.getMessage(), e);        } else if (e.getErrorType() == ErrorType.NoSchema) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_ABSENT_DESCRIPTION_SCHEMA, e.getMessage(), e));        } else if (e.getErrorType() == ErrorType.InvalidPdfaSchema) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_WRONG_NS_URI, e.getMessage(), e));        } else {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, e.getMessage(), e));        }    } catch (IOException e) {        throw new ValidationException("Failed while validating", e);    }}
private void pdfbox_f8949_0(PreflightContext ctx, XMPMetadata metadata)
{    XMPBasicSchema xmp = metadata.getXMPBasicSchema();    if (xmp == null) {        return;    }    List<ThumbnailType> tbProp;    try {        tbProp = xmp.getThumbnailsProperty();    } catch (BadFieldValueException e) {                addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, e.getMessage(), e));        return;    }    if (tbProp == null) {        return;    }    for (ThumbnailType tb : tbProp) {        checkThumbnail(tb, ctx);    }}
private void pdfbox_f8950_0(ThumbnailType tb, PreflightContext ctx)
{    byte[] binImage;    try {        binImage = Hex.decodeBase64(tb.getImage());    } catch (IllegalArgumentException e) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "xapGImg:image is not correct base64 encoding"));        return;    }    if (!hasJpegMagicNumber(binImage)) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "xapGImg:image decoded base64 content is not in JPEG format"));        return;    }    BufferedImage bim;    try {        bim = ImageIO.read(new ByteArrayInputStream(binImage));    } catch (IOException e) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, e.getMessage(), e));        return;    }    if (!"JPEG".equals(tb.getFormat())) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "xapGImg:format must be 'JPEG'"));    }    if (bim.getHeight() != tb.getHeight()) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "xapGImg:height does not match the actual base64-encoded thumbnail image data"));    }    if (bim.getWidth() != tb.getWidth()) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "xapGImg:witdh does not match the actual base64-encoded thumbnail image data"));    }}
private boolean pdfbox_f8951_0(byte[] binImage)
{    if (binImage.length < 4) {        return false;    }    return (binImage[0] == (byte) 0xFF && binImage[1] == (byte) 0xD8 && binImage[binImage.length - 2] == (byte) 0xFF && binImage[binImage.length - 1] == (byte) 0xD9);}
private static InputStream pdfbox_f8952_0(PDDocument document) throws IOException, XpacketParsingException
{    PDDocumentCatalog catalog = document.getDocumentCatalog();    PDMetadata metadata = catalog.getMetadata();    if (metadata == null) {        COSBase metaObject = catalog.getCOSObject().getDictionaryObject(COSName.METADATA);        if (!(metaObject instanceof COSStream)) {                        ValidationError error = new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "Metadata is not a stream");            throw new XpacketParsingException("Failed while retrieving xpacket", error);        }                ValidationError error = new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "Missing Metadata Key in catalog");        throw new XpacketParsingException("Failed while retrieving xpacket", error);    }        if (metadata.getFilters() != null) {                ValidationError error = new ValidationError(PreflightConstants.ERROR_SYNTAX_STREAM_INVALID_FILTER, "Filter specified in metadata dictionnary");        throw new XpacketParsingException("Failed while retrieving xpacket", error);    }    return metadata.exportXMPMetadata();}
protected List<ValidationError> pdfbox_f8953_0(PDDocument doc)
{    List<ValidationError> ve = new ArrayList<>();    List<?> filters = doc.getDocumentCatalog().getMetadata().getFilters();    if (filters != null && !filters.isEmpty()) {        ve.add(new ValidationError(PreflightConstants.ERROR_METADATA_MAIN, "Using stream filter on metadata dictionary is forbidden"));    }    return ve;}
public void pdfbox_f8954_0(PreflightContext context) throws ValidationException
{    PDDocumentCatalog catalog = context.getDocument().getDocumentCatalog();    if (catalog != null) {        COSDictionary catalogDict = catalog.getCOSObject();        if (!(catalogDict.getDictionaryObject(COSName.PAGES) instanceof COSDictionary)) {            addValidationError(context, new ValidationError(ERROR_PDF_PROCESSING_MISSING, "/Pages dictionary entry is missing in document catalog"));            return;        }        int p = 0;        for (PDPage page : context.getDocument().getPages()) {            context.setCurrentPageNumber(p);            validatePage(context, page);            if (context.getDocument().getResult().getErrorsList().size() > context.getConfig().getMaxErrors()) {                context.addValidationError(new ValidationError(PreflightConstants.ERROR_UNKOWN_ERROR, "Over " + context.getConfig().getMaxErrors() + " errors, page tree validation process aborted"));                break;            }            context.setCurrentPageNumber(null);            ++p;        }    } else {        context.addValidationError(new ValidationError(ERROR_SYNTAX_NOCATALOG, "There are no Catalog entry in the Document"));    }}
protected void pdfbox_f8955_0(PreflightContext context, PDPage page) throws ValidationException
{    ContextHelper.validateElement(context, page, PAGE_PROCESS);}
public void pdfbox_f8956_0(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    } else if (!vPath.isExpectedType(COSDictionary.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_ACTION_INVALID_TYPE, "Action validation process needs at least one COSDictionary object"));    } else {        COSDictionary actionsDict = (COSDictionary) vPath.peek();                boolean aaEntryAuth = ((vPath.size() - vPath.getClosestTypePosition(PDPage.class)) == 2);        PreflightConfiguration config = context.getConfig();        ActionManagerFactory factory = config.getActionFact();        List<AbstractActionManager> la = factory.getActionManagers(context, actionsDict);        for (AbstractActionManager aMng : la) {            aMng.valid(aaEntryAuth);        }    }}
public void pdfbox_f8957_0(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    } else if (!vPath.isExpectedType(COSDictionary.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_ANNOT_INVALID_ELEMENT, "Annotation validation process needs at least one COSDictionary object"));    } else {        COSDictionary annotDict = (COSDictionary) vPath.peek();        PreflightConfiguration config = context.getConfig();        AnnotationValidatorFactory factory = config.getAnnotFact();        AnnotationValidator annotValidator = factory.getAnnotationValidator(context, annotDict);        if (annotValidator != null) {            annotValidator.validate();        }    }}
public void pdfbox_f8958_0(PreflightContext ctx) throws ValidationException
{    PreflightPath vPath = ctx.getValidationPath();    if (vPath.isEmpty()) {        return;    }    if (!vPath.isExpectedType(COSBase.class)) {        ctx.addValidationError(new ValidationResult.ValidationError(PreflightConstants.ERROR_ACTION_INVALID_TYPE, "Destination validation process needs at least one COSBase object"));        return;    }    COSBase dest = (COSBase) vPath.peek();    if (!(dest instanceof COSName || dest instanceof COSString || dest instanceof COSArray)) {        ctx.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, "Destination type entry " + dest.getClass().getSimpleName() + " is invalid"));        return;    }    if (dest instanceof COSArray) {        COSArray ar = (COSArray) dest;        if (ar.size() < 2) {            ctx.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, "Destination array must have at least 2 elements"));            return;        }        if (!(ar.get(1) instanceof COSName)) {            ctx.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, "Second element of destination array must be a name"));            return;        }        validateExplicitDestination(ctx, ar);    }    try {        PDDestination.create(dest);    } catch (IOException e) {        ctx.addValidationError(new ValidationResult.ValidationError(PreflightConstants.ERROR_SYNTAX_DICT_INVALID, e.getMessage(), e));    }}
 void pdfbox_f8959_0(PreflightContext ctx, COSArray ar)
{        if (ar.get(0) instanceof COSObject) {        COSObject ob = (COSObject) ar.get(0);        COSBase type = ob.getDictionaryObject(COSName.TYPE);        if (COSName.PAGE.equals(type)) {            try {                PDDestination.create(ar);            } catch (IOException e) {                ctx.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, e.getMessage(), e));            }            return;        }    }    ctx.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, "First element in Destination array entry must be an indirect reference to a dictionary of /Type /Page, but is " + ar.getName(0)));}
public void pdfbox_f8960_0(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    }    if (!vPath.isExpectedType(COSDictionary.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_GRAPHIC_XOBJECT_INVALID_TYPE, "ExtGState validation required at least a Resource dictionary"));    } else {        COSDictionary extGStatesDict = (COSDictionary) vPath.peek();        List<COSDictionary> listOfExtGState = extractExtGStateDictionaries(extGStatesDict);        validateTransparencyRules(context, listOfExtGState);        validateFonts(context, listOfExtGState);    }}
public List<COSDictionary> pdfbox_f8961_0(COSDictionary extGStates) throws ValidationException
{    List<COSDictionary> listOfExtGState = new ArrayList<>(0);    if (extGStates != null) {        for (COSName key : extGStates.keySet()) {            COSDictionary gsDict = extGStates.getCOSDictionary(key);            if (gsDict == null) {                throw new ValidationException("The Extended Graphics State dictionary is invalid");            }            listOfExtGState.add(gsDict);        }    }    return listOfExtGState;}
protected void pdfbox_f8962_0(PreflightContext context, List<COSDictionary> listOfExtGState)
{    for (COSDictionary egs : listOfExtGState) {        checkSoftMask(context, egs);        checkUpperCA(context, egs);        checkLowerCA(context, egs);        checkBlendMode(context, egs);        checkTRKey(context, egs);        checkTR2Key(context, egs);    }}
protected void pdfbox_f8963_0(PreflightContext context, List<COSDictionary> listOfExtGState) throws ValidationException
{    for (COSDictionary egs : listOfExtGState) {        checkFont(context, egs);    }}
private void pdfbox_f8964_0(PreflightContext context, COSDictionary egs) throws ValidationException
{    COSBase base = egs.getItem(COSName.FONT);    if (base == null) {        return;    }    if (!(base instanceof COSArray) || ((COSArray) base).size() != 2) {        context.addValidationError(new ValidationError(ERROR_SYNTAX_COMMON, "/Font entry in /ExtGState must be an array with 2 elements"));        return;    }    COSArray ar = (COSArray) base;    COSBase base0 = ar.get(0);    if (!(base0 instanceof COSObject)) {        context.addValidationError(new ValidationError(ERROR_SYNTAX_COMMON, "1st element in /Font entry in /ExtGState must be an indirect object"));        return;    }    COSBase base1 = ar.getObject(1);    if (!(base1 instanceof COSNumber)) {        context.addValidationError(new ValidationError(ERROR_SYNTAX_COMMON, "2nd element in /Font entry in /ExtGState must be a number"));        return;    }    COSNumber fontSize = (COSNumber) ar.getObject(1);    if (fontSize.floatValue() > MAX_POSITIVE_FLOAT || fontSize.floatValue() < MAX_NEGATIVE_FLOAT) {        context.addValidationError(new ValidationError(ERROR_SYNTAX_NUMERIC_RANGE, "invalid float range in 2nd element in /Font entry in /ExtGState"));    }    if (ar.getObject(0) instanceof COSDictionary) {        COSDictionary fontDict = (COSDictionary) ar.getObject(0);        try {            PDFont newFont = PDFontFactory.createFont(fontDict);            ContextHelper.validateElement(context, newFont, FONT_PROCESS);        } catch (IOException e) {            addFontError(fontDict, context, e);        }    }}
private void pdfbox_f8965_0(PreflightContext context, COSDictionary egs)
{    COSBase smVal = egs.getDictionaryObject(COSName.SMASK);    if (smVal != null && !(smVal instanceof COSName && COSName.NONE.equals(smVal))) {                context.addValidationError(new ValidationError(ERROR_TRANSPARENCY_EXT_GS_SOFT_MASK, "SoftMask must be null or None"));    }}
private void pdfbox_f8966_0(PreflightContext context, COSDictionary egs)
{    COSName bmVal = egs.getCOSName(COSName.BM);        if (bmVal != null && !(COSName.NORMAL.equals(bmVal) || COSName.COMPATIBLE.equals(bmVal))) {        context.addValidationError(new ValidationError(ERROR_TRANSPARENCY_EXT_GS_BLEND_MODE, "BlendMode value isn't valid (only Normal and Compatible are authorized)"));    }}
private void pdfbox_f8967_0(PreflightContext context, COSDictionary egs)
{    COSBase uCA = egs.getDictionaryObject(COSName.CA);    if (uCA != null) {                Float fca = uCA instanceof COSFloat ? ((COSFloat) uCA).floatValue() : null;        Integer ica = uCA instanceof COSInteger ? ((COSInteger) uCA).intValue() : null;        if (!(fca != null && Float.compare(fca, 1.0f) == 0) && !(ica != null && ica == 1)) {            context.addValidationError(new ValidationError(ERROR_TRANSPARENCY_EXT_GS_CA, "CA entry in a ExtGState is invalid"));        }    }}
private void pdfbox_f8968_0(PreflightContext context, COSDictionary egs)
{    COSBase lCA = egs.getDictionaryObject(COSName.CA_NS);    if (lCA != null) {                Float fca = lCA instanceof COSFloat ? ((COSFloat) lCA).floatValue() : null;        Integer ica = lCA instanceof COSInteger ? ((COSInteger) lCA).intValue() : null;        if (!(fca != null && Float.compare(fca, 1.0f) == 0) && !(ica != null && ica == 1)) {            context.addValidationError(new ValidationError(ERROR_TRANSPARENCY_EXT_GS_CA, "ca entry in a ExtGState is invalid"));        }    }}
protected void pdfbox_f8969_0(PreflightContext context, COSDictionary egs)
{    if (egs.getItem(COSName.TR) != null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_KEY, "No TR key expected in Extended graphics state"));    }}
protected void pdfbox_f8970_0(PreflightContext context, COSDictionary egs)
{    if (egs.getItem("TR2") != null) {        String s = egs.getNameAsString("TR2");        if (!"Default".equals(s)) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "TR2 key only expect 'Default' value, not '" + s + "'"));        }    }}
public void pdfbox_f8971_0(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    }    if (!vPath.isExpectedType(PDFont.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_FONTS_INVALID_DATA, "Font validation process needs at least one PDFont object"));    } else {        PDFont font = (PDFont) vPath.peek();        FontContainer<?> fontContainer = context.getFontContainer(font.getCOSObject());        if (fontContainer == null) {                        FontValidator<? extends FontContainer<? extends PDFont>> validator = getFontValidator(context, font);            if (validator != null) {                validator.validate();            }        }    }}
protected FontValidator<? extends FontContainer<? extends PDFont>> pdfbox_f8972_0(PreflightContext context, PDFont font)
{    String subtype = font.getSubType();    if (FONT_DICTIONARY_VALUE_TRUETYPE.equals(subtype)) {        return new TrueTypeFontValidator(context, (PDTrueTypeFont) font);    }    if (FONT_DICTIONARY_VALUE_MMTYPE.equals(subtype) || FONT_DICTIONARY_VALUE_TYPE1.equals(subtype)) {        return new Type1FontValidator(context, (PDSimpleFont) font);    }    if (FONT_DICTIONARY_VALUE_TYPE3.equals(subtype)) {        return new Type3FontValidator(context, (PDType3Font) font);    }    if (FONT_DICTIONARY_VALUE_COMPOSITE.equals(subtype)) {        return new Type0FontValidator(context, font);    }    if (FONT_DICTIONARY_VALUE_TYPE2.equals(subtype) || FONT_DICTIONARY_VALUE_TYPE1C.equals(subtype) || FONT_DICTIONARY_VALUE_TYPE0C.equals(subtype) || FONT_DICTIONARY_VALUE_TYPE0.equals(subtype)) {                return null;    }    context.addValidationError(new ValidationError(PreflightConstants.ERROR_FONTS_UNKNOWN_FONT_TYPE, "Unknown font type: " + subtype));    return null;}
public void pdfbox_f8973_0(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    XObjectValidator validator = null;    if (!vPath.isEmpty() && vPath.isExpectedType(PDImageXObject.class)) {        validator = new XObjImageValidator(context, (PDImageXObject) vPath.peek());    } else if (!vPath.isEmpty() && vPath.isExpectedType(PDFormXObject.class)) {        validator = new XObjFormValidator(context, (PDFormXObject) vPath.peek());    } else if (!vPath.isEmpty() && vPath.isExpectedType(PDPostScriptXObject.class)) {        validator = new XObjPostscriptValidator(context, (PDPostScriptXObject) vPath.peek());    } else if (!vPath.isEmpty() && vPath.isExpectedType(COSStream.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_GRAPHIC_XOBJECT_INVALID_TYPE, "Invalid XObject subtype"));    } else {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_GRAPHIC_MISSING_OBJECT, "Graphic validation process needs at least one PDXObject"));    }    if (validator != null) {        validator.validate();    }}
public void pdfbox_f8974_0(PreflightContext ctx) throws ValidationException
{    PreflightPath vPath = ctx.getValidationPath();    if (vPath.isEmpty()) {    } else if (!vPath.isExpectedType(PDResources.class)) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_PDF_PROCESSING_MISSING, "Resources validation process needs at least one PDResources object"));    } else {        PDResources resources = (PDResources) vPath.peek();        validateFonts(ctx, resources);        validateExtGStates(ctx, resources);        validateShadingPattern(ctx, resources);        validateTilingPattern(ctx, resources);        validateXObjects(ctx, resources);    }}
protected void pdfbox_f8975_0(PreflightContext context, PDResources resources) throws ValidationException
{    Map<String, PDFont> mapOfFonts = getFonts(resources.getCOSObject(), context);    for (Entry<String, PDFont> entry : mapOfFonts.entrySet()) {        ContextHelper.validateElement(context, entry.getValue(), FONT_PROCESS);    }}
private Map<String, PDFont> pdfbox_f8976_0(COSDictionary resources, PreflightContext context)
{    Map<String, PDFont> fonts = new HashMap<>();    COSDictionary fontsDictionary = (COSDictionary) resources.getDictionaryObject(COSName.FONT);    if (fontsDictionary == null) {        fontsDictionary = new COSDictionary();        resources.setItem(COSName.FONT, fontsDictionary);    }    for (COSName fontName : fontsDictionary.keySet()) {        COSBase font = fontsDictionary.getDictionaryObject(fontName);                if (font instanceof COSDictionary) {            PDFont newFont = null;            try {                newFont = PDFontFactory.createFont((COSDictionary) font);            } catch (IOException e) {                addFontError((COSDictionary) font, context, e);            }            if (newFont != null) {                fonts.put(fontName.getName(), newFont);            }        }    }    return fonts;}
protected void pdfbox_f8977_0(PreflightContext context, PDResources resources) throws ValidationException
{    COSDictionary extGState = resources.getCOSObject().getCOSDictionary(COSName.EXT_G_STATE);    if (extGState != null) {        ContextHelper.validateElement(context, extGState, EXTGSTATE_PROCESS);    }}
protected void pdfbox_f8978_0(PreflightContext context, PDResources resources) throws ValidationException
{    try {        for (COSName name : resources.getShadingNames()) {            PDShading shading = resources.getShading(name);            ContextHelper.validateElement(context, shading, SHADING_PATTERN_PROCESS);        }    } catch (IOException e) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_PATTERN_DEFINITION, e.getMessage(), e));    }}
protected void pdfbox_f8979_0(PreflightContext context, PDResources resources) throws ValidationException
{    try {        for (COSName name : resources.getPatternNames()) {            PDAbstractPattern pattern = resources.getPattern(name);            if (pattern instanceof PDTilingPattern) {                ContextHelper.validateElement(context, pattern, TILING_PATTERN_PROCESS);            }        }    } catch (IOException e) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_PATTERN_DEFINITION, e.getMessage(), e));    }}
protected void pdfbox_f8980_0(PreflightContext context, PDResources resources) throws ValidationException
{    COSDictionary mapOfXObj = resources.getCOSObject().getCOSDictionary(COSName.XOBJECT);    if (mapOfXObj == null) {        return;    }    for (Entry<COSName, COSBase> entry : mapOfXObj.entrySet()) {        COSBase xobj = entry.getValue();        if (xobj instanceof COSObject) {            xobj = ((COSObject) xobj).getObject();        }        if (xobj instanceof COSStream) {            try {                PDXObject pdXObject = PDXObject.createXObject(xobj, resources);                ContextHelper.validateElement(context, pdXObject, GRAPHIC_PROCESS);            } catch (IOException e) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_MAIN, e.getMessage() + " for entry '" + entry.getKey().getName() + "'", e));            }        }    }}
public void pdfbox_f8981_0(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    }    if (!vPath.isExpectedType(PDShading.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_GRAPHIC_MISSING_OBJECT, "ShadingPattern validation required at least a PDResources"));    } else {        PDShading shadingResource = (PDShading) vPath.peek();        PDPage page = vPath.getClosestPathElement(PDPage.class);        checkColorSpace(context, page, shadingResource);        checkGraphicState(context, page, shadingResource);    }}
protected void pdfbox_f8982_1(PreflightContext context, PDPage page, PDShading shadingRes) throws ValidationException
{    try {        PDColorSpace pColorSpace = shadingRes.getColorSpace();        PreflightConfiguration config = context.getConfig();        ColorSpaceHelperFactory csFact = config.getColorSpaceHelperFact();        ColorSpaceHelper csh = csFact.getColorSpaceHelper(context, pColorSpace, ColorSpaceRestriction.NO_PATTERN);        csh.validate();    } catch (IOException e) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_UNKNOWN_COLOR_SPACE, e.getMessage()));    }}
protected void pdfbox_f8983_0(PreflightContext context, PDPage page, PDShading shadingRes) throws ValidationException
{    COSDictionary resources = (COSDictionary) shadingRes.getCOSObject().getDictionaryObject(COSName.EXT_G_STATE);    if (resources != null) {        ContextHelper.validateElement(context, resources, EXTGSTATE_PROCESS);    }}
public void pdfbox_f8984_0(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    }    if (!vPath.isExpectedType(PDPage.class)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_PDF_PROCESSING_MISSING, "Page validation required at least a PDPage"));    } else {        PDPage page = (PDPage) vPath.peek();        validateActions(context, page);        validateAnnotation(context, page);        validateColorSpaces(context, page);        validateResources(context, page);        validateGraphicObjects(context, page);        validateGroupTransparency(context, page);                        validateContent(context, page);    }}
protected void pdfbox_f8985_0(PreflightContext context, PDPage page) throws ValidationException
{    ContextHelper.validateElement(context, page.getCOSObject(), ACTIONS_PROCESS);}
protected void pdfbox_f8986_1(PreflightContext context, PDPage page)
{    PDResources resources = page.getResources();    if (resources != null) {        PreflightConfiguration config = context.getConfig();        ColorSpaceHelperFactory colorSpaceFactory = config.getColorSpaceHelperFact();        for (COSName name : resources.getColorSpaceNames()) {            try {                PDColorSpace pdCS = resources.getColorSpace(name);                ColorSpaceHelper csHelper = colorSpaceFactory.getColorSpaceHelper(context, pdCS, ColorSpaceRestriction.NO_RESTRICTION);                csHelper.validate();            } catch (IOException e) {                                            }        }    }}
protected void pdfbox_f8987_1(PreflightContext context, PDPage page) throws ValidationException
{    COSBase thumbBase = page.getCOSObject().getItem(COSName.THUMB);    if (thumbBase != null) {        try {            if (thumbBase instanceof COSObject) {                thumbBase = ((COSObject) thumbBase).getObject();            }            PDXObject thumbImg = PDImageXObject.createThumbnail((COSStream) thumbBase);            ContextHelper.validateElement(context, thumbImg, GRAPHIC_PROCESS);        } catch (IOException e) {                        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID, "Unable to read Thumb image : " + e.getMessage()));        }    }}
protected void pdfbox_f8988_0(PreflightContext context, PDPage page) throws ValidationException
{    ContextHelper.validateElement(context, page.getResources(), RESOURCES_PROCESS);}
protected void pdfbox_f8989_1(PreflightContext context, PDPage page) throws ValidationException
{        try {        PreflightContentStream csWrapper = new PreflightContentStream(context, page);        csWrapper.validatePageContentStream();    } catch (IOException e) {                context.addValidationError(new ValidationError(ERROR_UNKOWN_ERROR, e.getMessage(), e));    }}
protected void pdfbox_f8990_0(PreflightContext context, PDPage page) throws ValidationException
{    try {        List<?> lAnnots = page.getAnnotations();        for (Object object : lAnnots) {            if (object instanceof PDAnnotation) {                COSDictionary cosAnnot = ((PDAnnotation) object).getCOSObject();                ContextHelper.validateElement(context, cosAnnot, ANNOTATIONS_PROCESS);            }        }    } catch (ValidationException e) {        throw e;    } catch (IOException e) {                throw new ValidationException("Unable to access Annotation", e);    }}
protected void pdfbox_f8991_0(PreflightContext context, PDPage page) throws ValidationException
{    COSDictionary groupDictionary = page.getCOSObject().getCOSDictionary(COSName.GROUP);    if (groupDictionary != null) {        COSName sVal = groupDictionary.getCOSName(COSName.S);        if (COSName.TRANSPARENCY.equals(sVal)) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_TRANSPARENCY_GROUP, "Group has a transparency S entry or the S entry is null"));        }    }}
public void pdfbox_f8992_0(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    } else if (!vPath.isExpectedType(PDTilingPattern.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_GRAPHIC_MISSING_OBJECT, "Tiling pattern validation required at least a PDPage"));    } else {        PDTilingPattern tilingPattern = (PDTilingPattern) vPath.peek();        PDPage page = vPath.getClosestPathElement(PDPage.class);        checkMandatoryFields(context, page, tilingPattern);        parseResources(context, page, tilingPattern);        parsePatternContent(context, page, tilingPattern);    }}
protected void pdfbox_f8993_0(PreflightContext context, PDPage page, PDTilingPattern pattern) throws ValidationException
{    PDResources resources = pattern.getResources();    if (resources != null) {        ContextHelper.validateElement(context, resources, RESOURCES_PROCESS);    }}
protected void pdfbox_f8994_0(PreflightContext context, PDPage page, PDTilingPattern pattern) throws ValidationException
{    PreflightContentStream csWrapper = new PreflightContentStream(context, page);    csWrapper.validatePatternContentStream(pattern);}
protected void pdfbox_f8995_0(PreflightContext context, PDPage page, PDTilingPattern pattern)
{    COSDictionary dictionary = pattern.getCOSObject();    boolean res = dictionary.getItem(COSName.RESOURCES) != null;    res = res && dictionary.getItem(COSName.BBOX) != null;    res = res && dictionary.getItem(COSName.PAINT_TYPE) != null;    res = res && dictionary.getItem(COSName.TILING_TYPE) != null;    res = res && dictionary.getItem(COSName.X_STEP) != null;    res = res && dictionary.getItem(COSName.Y_STEP) != null;    if (!res) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_PATTERN_DEFINITION));    }}
public void pdfbox_f8996_0(PreflightContext ctx) throws ValidationException
{    PDDocument pdfDoc = ctx.getDocument();    List<COSObject> lCOSObj = pdfDoc.getDocument().getObjects();    for (COSObject cObj : lCOSObj) {                COSBase cBase = cObj.getObject();        if (cBase instanceof COSStream) {            validateStreamObject(ctx, cObj);        }    }}
public void pdfbox_f8997_0(PreflightContext context, COSObject cObj) throws ValidationException
{    COSStream streamObj = (COSStream) cObj.getObject();                checkDictionaryEntries(context, streamObj);        checkFilters(streamObj, context);}
protected void pdfbox_f8998_0(COSStream stream, PreflightContext context)
{    COSBase bFilter = stream.getDictionaryObject(COSName.FILTER);    if (bFilter != null) {        if (bFilter instanceof COSArray) {            COSArray afName = (COSArray) bFilter;            for (int i = 0; i < afName.size(); ++i) {                FilterHelper.isAuthorizedFilter(context, afName.getString(i));            }        } else if (bFilter instanceof COSName) {            String fName = ((COSName) bFilter).getName();            FilterHelper.isAuthorizedFilter(context, fName);        } else {                        addValidationError(context, new ValidationError(ERROR_SYNTAX_STREAM_INVALID_FILTER, "Filter should be a Name or an Array"));        }    }}
protected void pdfbox_f8999_0(PreflightContext context, COSStream streamObj)
{    boolean len = streamObj.containsKey(COSName.LENGTH);    boolean f = streamObj.containsKey(COSName.F);    boolean ffilter = streamObj.containsKey(COSName.F_FILTER);    boolean fdecParams = streamObj.containsKey(COSName.F_DECODE_PARMS);    if (!len) {        addValidationError(context, new ValidationError(ERROR_SYNTAX_STREAM_LENGTH_MISSING, "Stream length is missing"));    }    if (f || ffilter || fdecParams) {        addValidationError(context, new ValidationError(ERROR_SYNTAX_STREAM_FX_KEYS, "F, FFilter or FDecodeParms keys are present in the stream dictionary"));    }}
public void pdfbox_f9000_0(PreflightContext ctx) throws ValidationException
{    PDDocument pdfDoc = ctx.getDocument();    COSDictionary linearizedDict = getLinearizedDictionary(pdfDoc);        if (linearizedDict != null && ctx.getXrefTrailerResolver().getTrailerCount() == 2 && ctx.getFileLen() == linearizedDict.getLong(COSName.L)) {                checkLinearizedDictionnary(ctx, linearizedDict);                                        float pdfVersion = pdfDoc.getVersion();        if (pdfVersion <= 1.4f) {            checkTrailersForLinearizedPDF14(ctx);        } else {            checkTrailersForLinearizedPDF15(ctx);        }    } else {                checkMainTrailer(ctx, pdfDoc.getDocument().getTrailer());    }}
protected void pdfbox_f9001_0(PreflightContext ctx)
{    COSDictionary first = ctx.getXrefTrailerResolver().getFirstTrailer();    if (first == null) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER, "There are no trailer in the PDF file"));    } else {        COSDictionary last = ctx.getXrefTrailerResolver().getLastTrailer();        checkMainTrailer(ctx, first);        if (!compareIds(first, last)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_ID_CONSISTENCY, "ID is different in the first and the last trailer"));        }    }}
protected void pdfbox_f9002_0(PreflightContext ctx)
{    PDDocument pdfDoc = ctx.getDocument();    COSDocument cosDocument = pdfDoc.getDocument();    List<COSObject> xrefs = cosDocument.getObjectsByType(COSName.XREF);    if (xrefs.isEmpty()) {                checkTrailersForLinearizedPDF14(ctx);    } else {        long min = Long.MAX_VALUE;        long max = Long.MIN_VALUE;        COSDictionary firstTrailer = null;        COSDictionary lastTrailer = null;                for (COSObject co : xrefs) {            long offset = cosDocument.getXrefTable().get(new COSObjectKey(co));            if (offset < min) {                min = offset;                firstTrailer = (COSDictionary) co.getObject();            }            if (offset > max) {                max = offset;                lastTrailer = (COSDictionary) co.getObject();            }        }        checkMainTrailer(ctx, firstTrailer);        if (!compareIds(firstTrailer, lastTrailer)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_ID_CONSISTENCY, "ID is different in the first and the last trailer"));        }    }}
protected boolean pdfbox_f9003_0(COSDictionary first, COSDictionary last)
{    COSBase idFirst = first.getDictionaryObject(COSName.ID);    COSBase idLast = last.getDictionaryObject(COSName.ID);        if (idFirst != null && idLast != null) {                if (!(idFirst instanceof COSArray) || !(idLast instanceof COSArray)) {            return false;        }                boolean isEqual = true;        for (COSBase of : ((COSArray) idFirst).toList()) {            boolean oneIsEquals = false;            for (COSBase ol : ((COSArray) idLast).toList()) {                                if (!oneIsEquals) {                    oneIsEquals = ((COSString) ol).getString().equals(((COSString) of).getString());                } else {                    break;                }            }            isEqual &= oneIsEquals;            if (!isEqual) {                break;            }        }        return isEqual;    } else {        return true;    }}
protected void pdfbox_f9004_0(PreflightContext ctx, COSDictionary trailer)
{    boolean id = false;    boolean root = false;    boolean size = false;    boolean prev = false;    boolean info = false;    boolean encrypt = false;    for (COSName cosName : trailer.keySet()) {        if (cosName.equals(COSName.ENCRYPT)) {            encrypt = true;        }        if (cosName.equals(COSName.SIZE)) {            size = true;        }        if (cosName.equals(COSName.PREV)) {            prev = true;        }        if (cosName.equals(COSName.ROOT)) {            root = true;        }        if (cosName.equals(COSName.INFO)) {            info = true;        }        if (cosName.equals(COSName.ID)) {            id = true;        }    }        if (!id) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_MISSING_ID, "The trailer dictionary doesn't contain ID"));    } else {        COSBase trailerId = trailer.getDictionaryObject(COSName.ID);        if (!(trailerId instanceof COSArray)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_TYPE_INVALID, "The trailer dictionary contains an id but it isn't an array"));        }    }        if (encrypt) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_ENCRYPT, "The trailer dictionary contains Encrypt"));    }        if (!size) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_MISSING_SIZE, "The trailer dictionary doesn't contain Size"));    } else {        COSBase trailerSize = trailer.getDictionaryObject(COSName.SIZE);        if (!(trailerSize instanceof COSInteger)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_TYPE_INVALID, "The trailer dictionary contains a size but it isn't an integer"));        }    }        if (!root) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_MISSING_ROOT, "The trailer dictionary doesn't contain Root"));    } else {        COSBase trailerRoot = trailer.getDictionaryObject(COSName.ROOT);        if (!(trailerRoot instanceof COSDictionary)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_TYPE_INVALID, "The trailer dictionary contains a root but it isn't a dictionary"));        }    }        if (prev) {        COSBase trailerPrev = trailer.getDictionaryObject(COSName.PREV);        if (!(trailerPrev instanceof COSInteger)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_TYPE_INVALID, "The trailer dictionary contains a prev but it isn't an integer"));        }    }        if (info) {        COSBase trailerInfo = trailer.getDictionaryObject(COSName.INFO);        if (!(trailerInfo instanceof COSDictionary)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_TYPE_INVALID, "The trailer dictionary contains an info but it isn't a dictionary"));        }    }}
protected COSDictionary pdfbox_f9005_0(PDDocument document)
{        COSDocument cDoc = document.getDocument();    List<COSObject> lObj = cDoc.getObjects();    for (COSObject object : lObj) {        COSBase curObj = object.getObject();        if (curObj instanceof COSDictionary && ((COSDictionary) curObj).keySet().contains(COSName.getPDFName(DICTIONARY_KEY_LINEARIZED))) {            return (COSDictionary) curObj;        }    }    return null;}
protected void pdfbox_f9006_0(PreflightContext ctx, COSDictionary linearizedDict)
{            boolean l = false;    boolean h = false;    boolean o = false;    boolean e = false;    boolean n = false;    boolean t = false;    for (COSName key : linearizedDict.keySet()) {        String cosName = key.getName();        if (cosName.equals(DICTIONARY_KEY_LINEARIZED_L)) {            l = true;        }        if (cosName.equals(DICTIONARY_KEY_LINEARIZED_H)) {            h = true;        }        if (cosName.equals(DICTIONARY_KEY_LINEARIZED_O)) {            o = true;        }        if (cosName.equals(DICTIONARY_KEY_LINEARIZED_E)) {            e = true;        }        if (cosName.equals(DICTIONARY_KEY_LINEARIZED_N)) {            n = true;        }        if (cosName.equals(DICTIONARY_KEY_LINEARIZED_T)) {            t = true;        }    }    if (!(l && h && o && e && t && n)) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_DICT_INVALID, "Invalid key in The Linearized dictionary"));    }}
public void pdfbox_f9007_0(PreflightContext ctx) throws ValidationException
{    COSDocument document = ctx.getDocument().getDocument();    if (document.isXRefStream()) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER, "/XRef cross reference streams are not allowed"));    }    if (document.getObjects().size() > PreflightConstants.MAX_INDIRECT_OBJ) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_INDIRECT_OBJ_RANGE, "Too many indirect objects"));    }}
public static void pdfbox_f9008_0(PreflightContext context, Object element, String processName) throws ValidationException
{    if (element == null) {        context.addValidationError(new ValidationError(ERROR_PDF_PROCESSING_MISSING, "Unable to process an element if it is null."));    } else {        callValidation(context, element, processName);    }}
private static void pdfbox_f9009_0(PreflightContext context, Object element, String processName) throws ValidationException
{    PreflightPath validationPath = context.getValidationPath();    if (hasRecursion(context, element, validationPath)) {        return;    }        if (element instanceof COSObjectable &&     (PreflightConfiguration.GRAPHIC_PROCESS.equals(processName) ||     PreflightConfiguration.FONT_PROCESS.equals(processName))) {                COSBase cos = ((COSObjectable) element).getCOSObject();        if (context.isInProcessedSet(cos)) {            return;        }        context.addToProcessedSet(cos);    }    boolean needPop = validationPath.pushObject(element);    PreflightConfiguration config = context.getConfig();    ValidationProcess process = config.getInstanceOfProcess(processName);    process.validate(context);    if (needPop) {        validationPath.pop();    }}
private static boolean pdfbox_f9010_0(PreflightContext context, Object element, PreflightPath validationPath)
{    if (element instanceof PDResources || element instanceof PDFormXObject) {        for (int i = 0; i < validationPath.size(); ++i) {            Object obj = validationPath.getPathElement(i, Object.class);            if (obj instanceof COSObjectable) {                COSObjectable cos = (COSObjectable) obj;                if (cos.getCOSObject() == ((COSObjectable) element).getCOSObject()) {                    context.addValidationError(new ValidationError(ERROR_PDF_PROCESSING, element.getClass().getSimpleName() + " recursion"));                    return true;                }            }        }    }    return false;}
public static void pdfbox_f9011_0(PreflightContext context, String processName) throws ValidationException
{    callValidation(context, null, processName);}
public static void pdfbox_f9012_0(PreflightContext context, String filter)
{    PreflightDocument preflightDocument = context.getDocument();    switch(preflightDocument.getSpecification()) {        case PDF_A1A:            isAuthorizedFilterInPDFA(context, filter);            break;        default:                        isAuthorizedFilterInPDFA(context, filter);            break;    }}
public static void pdfbox_f9013_0(PreflightContext context, String filter)
{    if (filter != null) {                if (STREAM_DICTIONARY_VALUE_FILTER_LZW.equals(filter) || INLINE_DICTIONARY_VALUE_FILTER_LZW.equals(filter)) {            context.addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_INVALID_FILTER, "LZWDecode is forbidden"));            return;        }                if (!ALLOWED_FILTERS.contains(filter)) {            context.addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_UNDEFINED_FILTER, "This filter isn't defined in the PDF Reference Third Edition : " + filter));        }    }}
public static boolean pdfbox_f9014_0(String riArg)
{    return RENDERING_INTENTS.contains(riArg);}
public void pdfbox_f9015_0(ValidationResult otherResult)
{    if (otherResult != null) {        this.lErrors.addAll(otherResult.getErrorsList());        this.isValid &= otherResult.isValid();    }}
public XMPMetadata pdfbox_f9016_0()
{    return xmpMetaData;}
 void pdfbox_f9017_0(XMPMetadata xmpMetaData)
{    this.xmpMetaData = xmpMetaData;}
public boolean pdfbox_f9018_0()
{    return isValid;}
public void pdfbox_f9019_0(ValidationError error)
{    if (error != null) {        this.isValid &= error.isWarning();        this.lErrors.add(error);    }}
public void pdfbox_f9020_0(List<ValidationError> errors)
{    if (errors != null) {        for (ValidationError validationError : errors) {            addError(validationError);        }    }}
public List<ValidationError> pdfbox_f9021_0()
{    return this.lErrors;}
public Throwable pdfbox_f9022_0()
{    return t;}
public Throwable pdfbox_f9023_0()
{    return cause;}
public Integer pdfbox_f9024_0()
{    return pageNumber;}
public void pdfbox_f9025_0(Integer pageNumber)
{    this.pageNumber = pageNumber;}
public String pdfbox_f9026_0()
{    return errorCode;}
public String pdfbox_f9027_0()
{    return details;}
public void pdfbox_f9028_0(String details)
{    this.details = details;}
public boolean pdfbox_f9029_0()
{    return isWarning;}
public void pdfbox_f9030_0(boolean isWarning)
{    this.isWarning = isWarning;}
public int pdfbox_f9031_0()
{    return errorCode.hashCode();}
public boolean pdfbox_f9032_0(Object o)
{    if (o instanceof ValidationError) {        ValidationError ve = (ValidationError) o;                if (!errorCode.equals(ve.errorCode)) {            return false;        } else if (!details.equals(ve.details)) {            return false;        } else if (pageNumber != null && ve.pageNumber == null) {            return false;        } else if (pageNumber == null && ve.pageNumber != null) {            return false;        } else if (pageNumber != null && ve.pageNumber != null && pageNumber.compareTo(ve.pageNumber) != 0) {            return false;        }                return isWarning == ve.isWarning;    } else {        return false;    }}
public static void pdfbox_f9033_0(String[] args) throws IOException, TransformerException, ParserConfigurationException
{    if (args.length == 0) {        usage();        System.exit(1);    }        int posFile = 0;    boolean outputXml = "xml".equals(args[posFile]);    posFile += outputXml ? 1 : 0;        boolean isGroup = "group".equals(args[posFile]);    posFile += isGroup ? 1 : 0;        boolean isBatch = "batch".equals(args[posFile]);    posFile += isBatch ? 1 : 0;    if (isGroup || isBatch) {                List<File> ftp = listFiles(args[posFile]);        int status = 0;        if (!outputXml) {                        for (File file2 : ftp) {                status |= runSimple(file2);            }            System.exit(status);        } else {            Transformer transformer = TransformerFactory.newInstance().newTransformer();            transformer.setOutputProperty(OutputKeys.INDENT, "yes");            transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");            XmlResultParser xrp = new XmlResultParser();            if (isGroup) {                Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();                Element root = document.createElement("preflights");                document.appendChild(root);                root.setAttribute("count", String.format("%d", ftp.size()));                for (File file : ftp) {                    Element result = xrp.validate(document, file);                    root.appendChild(result);                }                transformer.transform(new DOMSource(document), new StreamResult(new File(args[posFile] + ".preflight.xml")));            } else {                                for (File file : ftp) {                    Element result = xrp.validate(file);                    Document document = result.getOwnerDocument();                    document.appendChild(result);                    transformer.transform(new DOMSource(document), new StreamResult(new File(file.getAbsolutePath() + ".preflight.xml")));                }            }        }    } else {        if (!outputXml) {                        System.exit(runSimple(new File(args[posFile])));        } else {                        XmlResultParser xrp = new XmlResultParser();            Element result = xrp.validate(new File(args[posFile]));            Document document = result.getOwnerDocument();            document.appendChild(result);            Transformer transformer = TransformerFactory.newInstance().newTransformer();            transformer.setOutputProperty(OutputKeys.INDENT, "yes");            transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");            transformer.transform(new DOMSource(document), new StreamResult(System.out));        }    }}
private static void pdfbox_f9034_0() throws IOException
{    String version = Version.getVersion();    System.out.println("Usage : java org.apache.pdfbox.preflight.Validator_A1b [xml] [<mode>] <file path>");    System.out.println();    System.out.println(" * xml : if set, generate xml output instead of text");    System.out.println(" * <mode> : if set, <file path> must be a file containing the PDF files to parse. <mode> can have 2 values:");    System.out.println("       batch : generate xml result files for each PDF file in the list");    System.out.println("       group : generate one xml result file for all the PDF files in the list.");    System.out.println("Version : " + version);}
private static int pdfbox_f9035_0(File file) throws IOException
{    ValidationResult result;    PreflightParser parser = new PreflightParser(file);    try {        parser.parse();        try (PreflightDocument document = parser.getPreflightDocument()) {            document.validate();            result = document.getResult();        }    } catch (SyntaxValidationException e) {        result = e.getResult();    }    if (result.isValid()) {        System.out.println("The file " + file.getName() + " is a valid PDF/A-1b file");        System.out.println();        return 0;    } else {        System.out.println("The file " + file.getName() + " is not a valid PDF/A-1b file, error(s) :");        for (ValidationError error : result.getErrorsList()) {            System.out.print(error.getErrorCode() + " : " + error.getDetails());            if (error.getPageNumber() != null) {                System.out.println(" on page " + (error.getPageNumber() + 1));            } else {                System.out.println();            }        }        System.out.println();        return -1;    }}
private static List<File> pdfbox_f9036_0(String path) throws IOException
{    List<File> files = new ArrayList<>();    File f = new File(path);    if (f.isFile()) {        FileReader fr = new FileReader(f);        BufferedReader buf = new BufferedReader(fr);        while (buf.ready()) {            File fn = new File(buf.readLine());            if (fn.exists()) {                files.add(fn);            }                }        IOUtils.closeQuietly(buf);    } else {        File[] fileList = f.listFiles();        if (fileList != null) {            files.addAll(Arrays.asList(fileList));        }    }    return files;}
protected void pdfbox_f9037_0()
{    COSBase smask = xobject.getCOSDictionary(COSName.SMASK);    if (smask != null && !(smask instanceof COSName && COSName.NONE.equals(smask))) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_TRANSPARENCY_SMASK, "Soft Mask must be null or None [" + xobject.toString() + "]"));    }}
protected void pdfbox_f9038_0()
{        if (this.xobject.getItem(COSName.getPDFName("OPI")) != null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_KEY, "Unexpected 'OPI' Key"));    }}
protected void pdfbox_f9039_0()
{        if (this.xobject.getItem("Ref") != null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_KEY, "No reference XObject allowed in PDF/A"));    }}
protected void pdfbox_f9040_0()
{        COSName subtype = this.xobject.getCOSName(COSName.SUBTYPE);    if (COSName.PS.equals(subtype)) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "No Postscript XObject allowed in PDF/A"));    } else if (this.xobject.getItem(COSName.getPDFName("Subtype2")) != null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "No Postscript XObject allowed in PDF/A (Subtype2)"));    }}
public void pdfbox_f9041_0() throws ValidationException
{    checkMandatoryFields();    checkOPI();    checkSMask();    checkReferenceXObject();    checkPostscriptXObject();}
public void pdfbox_f9042_0() throws ValidationException
{    super.validate();    checkGroup();    checkSubtype2Value();    validateXObjectResources();    validateXObjectContent();}
protected void pdfbox_f9043_0()
{    boolean lastMod = this.xobject.getItem(COSName.LAST_MODIFIED) != null;    boolean pieceInfo = this.xobject.getItem("PieceInfo") != null;        if (lastMod ^ pieceInfo) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_MISSING_FIELD));        return;    }    COSArray bbArray = this.xobject.getCOSArray(COSName.BBOX);        if (bbArray == null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_BBOX));    }}
protected void pdfbox_f9044_0() throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    PreflightContentStream csWrapper = new PreflightContentStream(context, vPath.getClosestPathElement(PDPage.class));    csWrapper.validateXObjContentStream(pdXObj);}
protected void pdfbox_f9045_0()
{    COSDictionary groupDictionary = this.xobject.getCOSDictionary(COSName.GROUP);    if (groupDictionary != null) {        if (!COSName.GROUP.equals(groupDictionary.getCOSName(COSName.TYPE))) {            context.addValidationError(new ValidationError(PreflightConstants.ERROR_GRAPHIC_MISSING_FIELD, "The Group dictionary hasn't Group as Type value"));        } else {            COSName sVal = groupDictionary.getCOSName(COSName.S);            if (sVal == null || COSName.TRANSPARENCY.equals(sVal)) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_TRANSPARENCY_GROUP, "Group has a transparency S entry or the S entry is null [" + xobject.toString() + "]"));            }        }    }}
protected void pdfbox_f9046_0()
{        if (this.xobject.getItem(COSName.PS) != null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_KEY, "Unexpected 'PS' Key"));    }}
protected void pdfbox_f9047_0()
{        if (this.xobject.getItem(COSName.getPDFName("Subtype2")) != null && "PS".equals(this.xobject.getNameAsString("Subtype2"))) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "Unexpected 'PS' value for 'Subtype2' Key"));    }}
protected void pdfbox_f9048_0() throws ValidationException
{    PDResources resources = this.pdXObj.getResources();    if (resources != null) {        ContextHelper.validateElement(context, resources, RESOURCES_PROCESS);    }}
protected void pdfbox_f9049_0()
{    boolean res = this.xobject.getItem(COSName.WIDTH) != null;    res = res && this.xobject.getItem(COSName.HEIGHT) != null;        if (!res) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_MISSING_FIELD));    }}
protected void pdfbox_f9050_0() throws ValidationException
{    if (this.xobject.getItem("Alternates") != null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_KEY, "Unexpected 'Alternates' Key"));    }}
protected void pdfbox_f9051_0() throws ValidationException
{    if (this.xobject.getItem(COSName.INTERPOLATE) != null && this.xobject.getBoolean(COSName.INTERPOLATE, true)) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "Unexpected 'true' value for 'Interpolate' Key"));    }}
protected void pdfbox_f9052_0() throws ValidationException
{    if (this.xobject.getItem("Intent") != null) {        String s = this.xobject.getNameAsString("Intent");        if (!RenderingIntents.contains(s)) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "Unexpected value '" + s + "' for Intent key in image"));        }    }}
protected void pdfbox_f9053_1() throws ValidationException
{    COSBase csImg = this.xobject.getItem(COSName.COLORSPACE);    COSBase bitsPerComp = this.xobject.getDictionaryObject(COSName.BITS_PER_COMPONENT);    COSBase mask = this.xobject.getItem(COSName.MASK);    if (isImageMaskTrue()) {        if (csImg != null || mask != null) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_KEY, "ImageMask entry is true, ColorSpace and Mask are forbidden."));        }        if (bitsPerComp instanceof COSInteger && ((COSInteger) bitsPerComp).intValue() != 1) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "ImageMask entry is true, BitsPerComponent must be absent or 1."));        }    } else {        try {            PreflightConfiguration config = context.getConfig();            ColorSpaceHelperFactory csFact = config.getColorSpaceHelperFact();            PDColorSpace pdCS = PDColorSpace.create(csImg);            ColorSpaceHelper csh = csFact.getColorSpaceHelper(context, pdCS, ColorSpaceRestriction.NO_PATTERN);            csh.validate();        } catch (IOException e) {                        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_UNKNOWN_COLOR_SPACE));        }    }}
private boolean pdfbox_f9054_0()
{    COSBase imgMask = this.xobject.getItem("ImageMask");    if (imgMask instanceof COSBoolean) {        return ((COSBoolean) imgMask).getValue();    } else {        return false;    }}
public void pdfbox_f9055_0() throws ValidationException
{    super.validate();    checkAlternates();    checkInterpolate();    checkIntent();    checkColorSpaceAndImageMask();}
protected PreflightContext pdfbox_f9057_0() throws Exception
{    PDDocument doc = PDDocument.load(new File("src/test/resources/pdfa-with-annotations-square.pdf"));    PreflightDocument preflightDocument = new PreflightDocument(doc.getDocument(), Format.PDF_A1B);    PreflightContext ctx = new PreflightContext();    ctx.setDocument(preflightDocument);    preflightDocument.setContext(ctx);    return ctx;}
protected void pdfbox_f9058_0(PDAction action, boolean valid) throws Exception
{    valid(action, valid, null);}
protected void pdfbox_f9059_0(COSDictionary action, boolean valid) throws Exception
{    valid(action, valid, null);}
protected void pdfbox_f9060_0(PDAction action, boolean valid, String expectedCode) throws Exception
{    valid(action.getCOSObject(), valid, expectedCode);}
protected void pdfbox_f9061_0(COSDictionary action, boolean valid, String expectedCode) throws Exception
{    ActionManagerFactory fact = new ActionManagerFactory();    PreflightContext ctx = createContext();    ctx.setConfig(PreflightConfiguration.createPdfA1BConfiguration());    COSDictionary dict = new COSDictionary();    dict.setItem(COSName.A, action);        List<AbstractActionManager> actions = fact.getActionManagers(ctx, dict);    for (AbstractActionManager abstractActionManager : actions) {        abstractActionManager.valid();    }        if (!valid) {        List<ValidationError> errors = ctx.getDocument().getResult().getErrorsList();        assertFalse(errors.isEmpty());        if (expectedCode != null || !"".equals(expectedCode)) {            boolean found = false;            for (ValidationError err : errors) {                if (err.getErrorCode().equals(expectedCode)) {                    found = true;                    break;                }            }            assertTrue(found);        }    } else {        if (ctx.getDocument().getResult() != null) {            List<ValidationError> errors = ctx.getDocument().getResult().getErrorsList();            assertTrue(errors.isEmpty());        }    }    ctx.getDocument().close();}
protected COSDictionary pdfbox_f9062_0(String type)
{    COSDictionary action = new COSDictionary();    action.setItem(COSName.TYPE, COSName.getPDFName("Action"));    action.setItem(COSName.S, COSName.getPDFName(type));    return action;}
public void pdfbox_f9063_0() throws Exception
{    COSDictionary action = createAction("Launch");    valid(action, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN);}
public void pdfbox_f9064_0() throws Exception
{    COSDictionary action = createAction("Sound");    valid(action, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN);}
public void pdfbox_f9065_0() throws Exception
{    COSDictionary action = createAction("Movie");    valid(action, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN);}
public void pdfbox_f9066_0() throws Exception
{    COSDictionary action = createAction("ImportData");    valid(action, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN);}
public void pdfbox_f9067_0() throws Exception
{    COSDictionary action = createAction("ResetForm");    valid(action, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN);}
public void pdfbox_f9068_0() throws Exception
{    COSDictionary action = createAction("JavaScript");    valid(action, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN);}
public void pdfbox_f9069_0() throws Exception
{    PDActionGoTo gotoAction = new PDActionGoTo();    gotoAction.setDestination(new PDDestination() {        @Override        public COSBase getCOSObject() {            return COSName.getPDFName("ADest");        }    });    valid(gotoAction, true);}
public COSBase pdfbox_f9070_0()
{    return COSName.getPDFName("ADest");}
public void pdfbox_f9071_0() throws Exception
{    PDActionGoTo gotoAction = new PDActionGoTo();    gotoAction.setDestination(new PDDestination() {        @Override        public COSBase getCOSObject() {            return new COSDictionary();        }    });    valid(gotoAction, false, PreflightConstants.ERROR_SYNTAX_DICT_INVALID);}
public COSBase pdfbox_f9072_0()
{    return new COSDictionary();}
public void pdfbox_f9073_0() throws Exception
{    PDActionGoTo gotoAction = new PDActionGoTo();    valid(gotoAction, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
public void pdfbox_f9074_0() throws Exception
{    PDActionRemoteGoTo gotoAction = new PDActionRemoteGoTo();    gotoAction.setD(COSName.getPDFName("ADest"));    gotoAction.setFile(new PDFileSpecification() {        public COSBase getCOSObject() {            return COSName.getPDFName("ADest");        }        @Override        public void setFile(String file) {        }        @Override        public String getFile() {            return "pouey";        }    });    valid(gotoAction, true);}
public COSBase pdfbox_f9075_0()
{    return COSName.getPDFName("ADest");}
public String pdfbox_f9077_0()
{    return "pouey";}
public void pdfbox_f9078_0() throws Exception
{    PDActionRemoteGoTo gotoAction = new PDActionRemoteGoTo();    gotoAction.setD(new COSDictionary());    gotoAction.setFile(new PDFileSpecification() {        public COSBase getCOSObject() {            return COSName.getPDFName("ADest");        }        @Override        public void setFile(String file) {        }        @Override        public String getFile() {            return "pouey";        }    });    valid(gotoAction, false, PreflightConstants.ERROR_ACTION_INVALID_TYPE);}
public COSBase pdfbox_f9079_0()
{    return COSName.getPDFName("ADest");}
public String pdfbox_f9081_0()
{    return "pouey";}
public void pdfbox_f9082_0() throws Exception
{    PDActionRemoteGoTo gotoAction = new PDActionRemoteGoTo();    gotoAction.setFile(new PDFileSpecification() {        public COSBase getCOSObject() {            return COSName.getPDFName("ADest");        }        @Override        public void setFile(String file) {        }        @Override        public String getFile() {            return "pouey";        }    });    valid(gotoAction, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
public COSBase pdfbox_f9083_0()
{    return COSName.getPDFName("ADest");}
public String pdfbox_f9085_0()
{    return "pouey";}
public void pdfbox_f9086_0() throws Exception
{    PDActionRemoteGoTo gotoAction = new PDActionRemoteGoTo();    gotoAction.setD(COSName.getPDFName("ADest"));    valid(gotoAction, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
protected COSDictionary pdfbox_f9087_0()
{    COSDictionary hideAction = new COSDictionary();    hideAction.setItem(COSName.TYPE, COSName.getPDFName("Action"));    hideAction.setItem(COSName.S, COSName.getPDFName("Hide"));    hideAction.setBoolean(COSName.H, false);    hideAction.setString(COSName.T, "avalue");    return hideAction;}
public void pdfbox_f9088_0() throws Exception
{    COSDictionary action = createHideAction();    valid(action, true);}
public void pdfbox_f9089_0() throws Exception
{    COSDictionary action = createHideAction();    action.setBoolean(COSName.H, true);    valid(action, false, PreflightConstants.ERROR_ACTION_HIDE_H_INVALID);}
public void pdfbox_f9090_0() throws Exception
{    COSDictionary action = createHideAction();    action.setBoolean(COSName.T, true);    valid(action, false, PreflightConstants.ERROR_ACTION_INVALID_TYPE);}
public void pdfbox_f9091_0() throws Exception
{    COSDictionary action = createHideAction();    action.removeItem(COSName.T);    valid(action, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
protected COSDictionary pdfbox_f9092_0()
{    COSDictionary namedAction = new COSDictionary();    namedAction.setItem(COSName.TYPE, COSName.getPDFName("Action"));    namedAction.setItem(COSName.S, COSName.getPDFName("Named"));    return namedAction;}
public void pdfbox_f9093_0() throws Exception
{    COSDictionary namedAction = createNamedAction();    namedAction.setItem(COSName.N, COSName.getPDFName(PreflightConstants.ACTION_DICTIONARY_VALUE_ATYPE_NAMED_FIRST));    valid(namedAction, true);}
public void pdfbox_f9094_0() throws Exception
{    COSDictionary namedAction = createNamedAction();    namedAction.setItem(COSName.N, COSName.getPDFName(PreflightConstants.ACTION_DICTIONARY_VALUE_ATYPE_NAMED_LAST));    valid(namedAction, true);}
public void pdfbox_f9095_0() throws Exception
{    COSDictionary namedAction = createNamedAction();    namedAction.setItem(COSName.N, COSName.getPDFName(PreflightConstants.ACTION_DICTIONARY_VALUE_ATYPE_NAMED_NEXT));    valid(namedAction, true);}
public void pdfbox_f9096_0() throws Exception
{    COSDictionary namedAction = createNamedAction();    namedAction.setItem(COSName.N, COSName.getPDFName(PreflightConstants.ACTION_DICTIONARY_VALUE_ATYPE_NAMED_PREV));    valid(namedAction, true);}
public void pdfbox_f9097_0() throws Exception
{    COSDictionary namedAction = createNamedAction();    valid(namedAction, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
public void pdfbox_f9098_0() throws Exception
{    COSDictionary namedAction = createNamedAction();    namedAction.setItem(COSName.N, COSName.getPDFName("unknown"));    valid(namedAction, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_NAMED);}
protected COSDictionary pdfbox_f9099_0()
{    COSDictionary action = new COSDictionary();    action.setItem(COSName.TYPE, COSName.getPDFName("Action"));    action.setItem(COSName.S, COSName.getPDFName("SubmitForm"));    action.setItem(COSName.F, new PDFileSpecification() {        public COSBase getCOSObject() {            return COSName.getPDFName("value");        }        @Override        public void setFile(String file) {        }        @Override        public String getFile() {            return null;        }    });    return action;}
public COSBase pdfbox_f9100_0()
{    return COSName.getPDFName("value");}
public String pdfbox_f9102_0()
{    return null;}
public void pdfbox_f9103_0() throws Exception
{    COSDictionary action = createSubmitAction();    valid(action, true);}
public void pdfbox_f9104_0() throws Exception
{    COSDictionary action = createSubmitAction();    action.removeItem(COSName.F);    valid(action, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
protected COSDictionary pdfbox_f9105_0()
{    COSDictionary action = new COSDictionary();    action.setItem(COSName.TYPE, COSName.getPDFName("Action"));    action.setItem(COSName.S, COSName.getPDFName("Thread"));    action.setInt(COSName.D, 1);    return action;}
public void pdfbox_f9106_0() throws Exception
{    COSDictionary action = createSubmitAction();    valid(action, true);}
public void pdfbox_f9107_0() throws Exception
{    COSDictionary action = createSubmitAction();    action.removeItem(COSName.D);    valid(action, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
public void pdfbox_f9108_0() throws Exception
{    COSDictionary action = createSubmitAction();    action.setBoolean(COSName.D, false);    valid(action, false, PreflightConstants.ERROR_ACTION_INVALID_TYPE);}
